0#0#"static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { VAR6 * const VAR7 = VAR2 -> VAR7 ; unsigned VAR8 = 0 ; int VAR9 = 0 ; int VAR10 , VAR11 = 0 ; VAR2 -> VAR12 = VAR2 -> VAR13 ; if ( ! ( VAR7 -> VAR14 & VAR15 ) ) { VAR2 -> VAR16 = 0 ; if ( ! VAR2 -> VAR17 ) VAR2 -> VAR18 = NULL ; FUN2 ( & VAR2 -> VAR19 ) ; } VAR11 = FUN3 ( & VAR2 -> VAR20 , VAR4 , VAR5 , VAR7 , VAR2 -> VAR21 , VAR2 -> VAR22 , VAR7 -> VAR23 ) ; if ( VAR11 < 0 ) { FUN4 ( VAR7 , VAR24 , ) ; VAR11 = -1 ; goto VAR44 ; } FUN6 ( VAR2 ) ; case VAR45 : VAR32 -> VAR46 = VAR29 -> VAR46 ; if ( ( VAR34 = FUN7 ( VAR2 , VAR32 ) ) ) break ; if ( VAR2 -> VAR19 . VAR47 . VAR48 >= 0 && VAR2 -> VAR49 < 0 ) { VAR2 -> VAR49 = ( VAR2 -> VAR50 . VAR51 + VAR2 -> VAR19 . VAR47 . VAR48 ) & ( ( 1 << VAR2 -> VAR52 . VAR53 -> VAR54 ) - 1 ) ; } VAR2 -> VAR18 -> VAR55 -> VAR56 |= ( VAR29 -> VAR38 == VAR43 ) || ( VAR2 -> VAR19 . VAR47 . VAR48 >= 0 ) ; if ( VAR29 -> VAR38 == VAR43 || VAR2 -> VAR49 == VAR2 -> VAR50 . VAR51 ) { VAR2 -> VAR49 = -1 ; VAR2 -> VAR18 -> VAR57 = 1 ; } if ( VAR29 -> VAR38 == VAR43 ) VAR2 -> VAR58 |= VAR59 ; VAR2 -> VAR18 -> VAR57 |= ! ! ( VAR2 -> VAR58 & VAR59 ) ; if ( VAR2 -> VAR16 == 1 ) { if ( ! ( VAR7 -> VAR14 & VAR15 ) ) FUN8 ( VAR2 , VAR10 >= VAR9 ) ; if ( VAR2 -> VAR7 -> VAR60 && ( VAR11 = VAR2 -> VAR7 -> VAR60 -> FUN9 ( VAR2 -> VAR7 , NULL , 0 ) ) < 0 ) return VAR11 ; } if ( VAR32 -> VAR61 == 0 && ( VAR7 -> VAR35 < VAR36 || VAR29 -> VAR37 ) && ( VAR7 -> VAR35 < VAR62 || VAR32 -> VAR63 != VAR64 ) && ( VAR7 -> VAR35 < VAR65 || VAR2 -> VAR18 -> VAR55 -> VAR56 ) && VAR7 -> VAR35 < VAR66 ) { if ( VAR7 -> VAR60 ) { VAR11 = VAR7 -> VAR60 -> FUN10 ( VAR7 , VAR29 -> VAR67 , VAR29 -> VAR68 ) ; if ( VAR11 < 0 ) return VAR11 ; } else VAR8 ++ ; } break ; case VAR69 : case VAR70 : case VAR71 : FUN11 ( VAR7 , , VAR29 -> VAR38 , VAR29 -> VAR77 ) ; } if ( VAR8 == VAR2 -> VAR12 ) { VAR11 = FUN16 ( VAR2 , VAR8 ) ; if ( VAR11 < 0 && ( VAR2 -> VAR7 -> VAR73 & VAR74 ) ) goto VAR44 ; VAR8 = 0 ; } if ( VAR34 < 0 ) { FUN4 ( VAR2 -> VAR7 , VAR24 , "" "" ) ; VAR32 -> VAR86 [ 0 ] = VAR32 -> VAR86 [ 1 ] = VAR32 -> VAR87 = 0 ; } else if ( VAR34 == 1 ) { VAR32 = & VAR2 -> VAR33 [ 0 ] ; goto VAR40 ; } } if ( VAR8 ) { VAR11 = FUN16 ( VAR2 , VAR8 ) ; if ( VAR11 < 0 && ( VAR2 -> VAR7 -> VAR73 & VAR74 ) ) goto VAR44 ; } VAR11 = 0 ; VAR44 : if ( VAR2 -> VAR18 && ! VAR2 -> VAR88 ) { FUN17 ( & VAR2 -> VAR18 -> VAR89 , VAR90 , VAR2 -> VAR91 == VAR92 ) ; } return ( VAR11 < 0 ) ? VAR11 : VAR5 ; } "#1
1#1#static VAR1 * FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { size_t VAR6 ; void * VAR7 ; VAR1 * VAR8 = NULL ; unsigned char * VAR9 = NULL ; if ( VAR3 -> VAR10 == 0 ) return NULL ; VAR3 -> VAR10 += sizeof ( * VAR8 ) ; if ( VAR3 -> VAR11 ) VAR7 = FUN2 ( VAR3 -> VAR10 ) ; else VAR7 = FUN3 ( VAR3 -> VAR10 ) ; if ( VAR7 == NULL ) return NULL ; VAR8 = VAR7 ; VAR9 = ( unsigned char * ) VAR7 + ( sizeof ( * VAR8 ) * ( VAR3 -> VAR12 + 1 ) ) ; for ( VAR6 = 0 ; VAR6 < VAR3 -> VAR12 ; VAR6 ++ ) { if ( ! FUN4 ( ( VAR9 - ( unsigned char * ) VAR7 ) + VAR3 -> VAR13 [ VAR6 ] . VAR14 <= VAR3 -> VAR10 ) ) goto VAR15 ; if ( FUN5 ( VAR3 -> VAR13 [ VAR6 ] . VAR16 , VAR9 , VAR3 -> VAR13 [ VAR6 ] . VAR14 ) < 0 ) goto VAR15 ; VAR8 [ VAR6 ] = FUN6 ( VAR3 -> VAR13 [ VAR6 ] . VAR17 , VAR9 , VAR3 -> VAR13 [ VAR6 ] . VAR14 ) ; VAR9 += VAR3 -> VAR13 [ VAR6 ] . VAR14 ; } VAR8 [ VAR6 ] = FUN7 ( ) ; if ( VAR5 != NULL ) * VAR5 = VAR3 -> VAR10 ; return VAR8 ; VAR15 : if ( VAR3 -> VAR11 ) FUN8 ( VAR8 ) ; else FUN9 ( VAR8 , VAR3 -> VAR10 ) ; return NULL ; } #1
2#2#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 = 0 , VAR4 ; VAR5 * VAR6 , * VAR7 ; VAR8 * VAR9 = NULL ; int ( * VAR10 ) ( int VAR11 , VAR1 * VAR12 ) ; VAR10 = VAR2 -> VAR13 ; VAR4 = FUN2 ( VAR2 -> VAR14 ) - 1 ; VAR2 -> VAR15 = VAR4 ; VAR7 = FUN3 ( VAR2 -> VAR14 , VAR4 ) ; if ( VAR2 -> VAR16 ) { VAR6 = VAR7 ; VAR7 = NULL ; goto VAR17 ; } if ( VAR2 -> FUN4 ( VAR2 , VAR7 , VAR7 ) ) VAR6 = VAR7 ; else { if ( VAR2 -> VAR18 -> VAR19 & VAR20 ) { VAR6 = VAR7 ; goto VAR17 ; } if ( VAR4 <= 0 ) { VAR2 -> VAR21 = VAR22 ; VAR2 -> VAR23 = VAR7 ; VAR3 = FUN5 ( 0 , VAR2 ) ; goto VAR24 ; } else { VAR4 -- ; VAR2 -> VAR15 = VAR4 ; VAR6 = FUN3 ( VAR2 -> VAR14 , VAR4 ) ; } } while ( VAR4 >= 0 ) { VAR2 -> VAR15 = VAR4 ; if ( VAR6 != VAR7 || ( VAR2 -> VAR18 -> VAR19 & VAR25 ) ) { if ( ( VAR9 = FUN6 ( VAR7 ) ) == NULL ) { VAR2 -> VAR21 = VAR26 ; VAR2 -> VAR23 = VAR7 ; VAR3 = ( * VAR10 ) ( 0 , VAR2 ) ; if ( ! VAR3 ) goto VAR24 ; } else if ( FUN7 ( VAR6 , VAR9 ) <= 0 ) { VAR2 -> VAR21 = VAR27 ; VAR2 -> VAR23 = VAR6 ; VAR3 = ( * VAR10 ) ( 0 , VAR2 ) ; if ( ! VAR3 ) goto VAR24 ; } } VAR17 : VAR3 = FUN8 ( VAR2 , VAR6 , 0 ) ; if ( ! VAR3 ) goto VAR24 ; VAR2 -> VAR28 = VAR7 ; VAR2 -> VAR23 = VAR6 ; VAR3 = ( * VAR10 ) ( 1 , VAR2 ) ; if ( ! VAR3 ) goto VAR24 ; VAR4 -- ; if ( VAR4 >= 0 ) { VAR7 = VAR6 ; VAR6 = FUN3 ( VAR2 -> VAR14 , VAR4 ) ; } } VAR3 = 1 ; VAR24 : return VAR3 ; } #0
3#3#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 [ 0 ] ; VAR6 * VAR7 = VAR4 -> VAR8 ; VAR9 * VAR10 = VAR2 -> VAR11 ; uint8_t VAR12 [ 80 ] ; int VAR13 , VAR14 , VAR15 = 1 , VAR16 = 0 , VAR17 = 0 , VAR18 = 0 , VAR19 ; switch ( VAR7 -> VAR20 ) { case VAR21 : VAR13 = 8 ; VAR14 = 2 ; break ; case VAR22 : VAR13 = 16 ; VAR14 = 2 ; VAR16 = 32768 ; break ; case VAR23 : case VAR24 : VAR13 = 8 ; VAR14 = 3 ; VAR17 = 1 ; if ( VAR7 -> VAR20 == VAR23 ) { VAR15 = 3 ; } else { VAR15 = 4 ; } break ; case VAR25 : case VAR26 : VAR13 = 16 ; VAR14 = 3 ; VAR17 = 1 ; if ( VAR7 -> VAR20 == VAR25 ) { VAR15 = 3 ; } else { VAR15 = 4 ; } VAR16 = 32768 ; break ; default : return FUN2 ( VAR27 ) ; } if ( VAR10 -> VAR28 ) { memcpy ( VAR12 , , 20 ) ; memset ( VAR12 + 20 , ' ' , 60 ) ; FUN3 ( VAR2 -> VAR29 , VAR12 , sizeof ( VAR12 ) ) ; } VAR18 ++ ; FUN4 ( VAR2 , , VAR14 , & VAR18 ) ; FUN4 ( VAR2 , , VAR7 -> VAR31 , & VAR18 ) ; if ( VAR17 ) FUN4 ( VAR2 , , 0 , & VAR18 ) ; FUN4 ( VAR2 , , VAR16 , & VAR18 ) ; if ( VAR17 ) { memcpy ( VAR12 , , 3 ) ; memset ( VAR12 + 3 , ' ' , 77 ) ; FUN3 ( VAR2 -> VAR29 , VAR12 , sizeof ( VAR12 ) ) ; VAR18 ++ ; VAR19 = ( ( VAR18 + 35 ) / 36 ) * 36 - VAR18 ; memset ( VAR12 , ' ' , 80 ) ; while ( VAR19 > 0 ) { FUN3 ( VAR2 -> VAR29 , VAR12 , sizeof ( VAR12 ) ) ; VAR19 -- ; } return 0 ; } #0
4#4#"static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { ssize_t VAR5 ; ngx_int_t VAR6 ; VAR7 * VAR8 ; VAR8 = VAR4 -> VAR9 . VAR10 ; FUN2 ( VAR11 , VAR8 -> VAR12 , 0 , ; if ( VAR8 -> read -> VAR14 ) { FUN3 ( VAR2 , VAR4 , VAR15 ) ; return ; } if ( ! VAR4 -> VAR16 && FUN4 ( VAR8 ) != VAR17 ) { FUN3 ( VAR2 , VAR4 , VAR18 ) ; return ; } if ( VAR4 -> VAR19 . VAR20 == NULL ) { VAR4 -> VAR19 . VAR20 = FUN5 ( VAR2 -> VAR21 , VAR4 -> VAR22 -> VAR23 ) ; if ( VAR4 -> VAR19 . VAR20 == NULL ) { FUN6 ( VAR2 , VAR4 , VAR24 ) ; return ; } VAR4 -> VAR19 . VAR25 = VAR4 -> VAR19 . VAR20 ; VAR4 -> VAR19 . VAR26 = VAR4 -> VAR19 . VAR20 ; VAR4 -> VAR19 . VAR27 = VAR4 -> VAR19 . VAR20 + VAR4 -> VAR22 -> VAR23 ; VAR4 -> VAR19 . VAR28 = 1 ; VAR4 -> VAR19 . VAR29 = VAR4 -> VAR30 . VAR29 ; if ( FUN7 ( & VAR4 -> VAR31 . VAR32 , VAR2 -> VAR21 , 8 , sizeof ( VAR33 ) ) != VAR17 ) { FUN6 ( VAR2 , VAR4 , VAR24 ) ; return ; } #if ( VAR34 ) if ( VAR2 - > VAR35 ) { VAR4 - > VAR19 . VAR25 + = VAR2 - > VAR35 - > VAR36 ; VAR4 - > VAR19 . VAR26 = VAR4 - > VAR19 . VAR25 ; } #endif }  for ( ;; ) {  VAR5 = VAR8->recv(VAR8, VAR4->VAR19.VAR26, VAR4->VAR19.VAR27 - VAR4->VAR19.VAR26);  if (VAR5 == VAR37) { #if 0 FUN8(VAR38, VAR4->VAR39); #endif  if (FUN9(VAR8->read, 0) != VAR17) { FUN6(VAR2, VAR4, VAR24); return; }  return; }  if (VAR5 == 0) { FUN10(VAR40, VAR8->VAR12, 0, );  FUN3(VAR2, VAR4, VAR46); return; }  continue; }  break; }  if (VAR6 == VAR47) { FUN3(VAR2, VAR4, VAR46); return; }  if (VAR6 == VAR41) { FUN6(VAR2, VAR4, VAR24); return; }    VAR4->VAR42->VAR48 = VAR49 - VAR4->VAR42->VAR50;  if (VAR4->VAR31.VAR51 >= VAR52) {  if (FUN12(VAR2, VAR4) == VAR17) { return; }  if (FUN13(VAR2, VAR4) == VAR17) { return; } }  if (FUN14(VAR2, VAR4) != VAR17) { return; }  if (!VAR2->VAR53) { FUN15(VAR2, VAR4); return; }    if (VAR4->VAR54 == NULL) { VAR4->VAR55 = VAR56; VAR4->VAR54 = VAR57; VAR4->VAR58 = VAR2; }  if (VAR4->FUN16(VAR4->VAR58) == VAR41) { FUN6(VAR2, VAR4, VAR41); return; }  VAR5 = VAR4->VAR19.VAR26 - VAR4->VAR19.VAR25;  if (VAR5) { VAR4->VAR19.VAR26 = VAR4->VAR19.VAR25;  VAR4->VAR42->VAR59 += VAR5;  if (VAR4->FUN17(VAR4->VAR58, VAR5) == VAR41) { FUN6(VAR2, VAR4, VAR41); return; } }  if (VAR4->VAR60 == 0) { FUN6(VAR2, VAR4, 0); return; }  VAR4->VAR61 = VAR62;  FUN18(VAR2, VAR4); } "#1
5#5#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = & VAR2 -> VAR5 ; VAR6 * VAR7 = VAR2 -> VAR8 ; int VAR9 , VAR10 ; double VAR11 = FUN2 ( VAR2 -> VAR8 ) ; double VAR12 [ 5 ] = { 0 } ; uint64_t VAR13 [ 5 ] = { 0 } ; uint64_t VAR14 ; uint64_t VAR15 = ( VAR16 ) ( VAR2 -> VAR17 * ( double ) VAR4 -> VAR18 / VAR11 ) ; double VAR19 = 0 ; double VAR20 ; const int VAR21 = ( int ) ( VAR7 -> VAR22 * 4 ) | 1 ; double VAR23 = 0 ; double * VAR24 , * VAR25 , VAR26 ; for ( VAR9 = 0 ; VAR9 < VAR4 -> VAR18 ; VAR9 ++ ) { VAR27 * VAR28 = & VAR4 -> VAR29 [ VAR9 ] ; VAR28 -> VAR30 = VAR28 -> VAR31 ; VAR4 -> VAR32 [ VAR28 -> VAR31 ] += VAR28 -> VAR33 * VAR28 -> VAR24 ; VAR4 -> VAR34 [ VAR28 -> VAR31 ] += VAR28 -> VAR35 * VAR28 -> VAR24 ; VAR4 -> VAR36 [ VAR28 -> VAR31 ] += VAR28 -> VAR37 ; VAR4 -> VAR38 [ VAR28 -> VAR31 ] ++ ; VAR12 [ VAR28 -> VAR30 ] += ( VAR28 -> VAR33 + VAR28 -> VAR35 ) * ( double ) VAR28 -> VAR24 ; VAR13 [ VAR28 -> VAR30 ] += VAR28 -> VAR37 + VAR28 -> VAR39 ; } VAR14 = VAR13 [ VAR40 ] + VAR13 [ VAR41 ] + VAR13 [ VAR42 ] ; if ( VAR15 < VAR14 ) { FUN3 ( VAR2 -> VAR8 , VAR43 , , VAR23 , ( int ) VAR15 , VAR19 ) ; if ( VAR23 > VAR15 ) { VAR19 -= VAR20 ; ++ VAR10 ; } } FUN13 ( VAR24 ) ; FUN13 ( VAR25 ) ; VAR26 = 0.0 ; for ( VAR9 = 0 ; VAR9 < VAR4 -> VAR18 ; VAR9 ++ ) { FUN12 ( VAR2 , , VAR2 -> VAR17 , ( int ) ( VAR23 / ( ( double ) VAR15 / VAR2 -> VAR17 ) ) ) ; FUN3 ( VAR2 -> VAR8 , VAR58 , ) ; return -1 ; } return 0 ; } #1
6#6#"void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { void ( * VAR5 ) ( VAR1 * , VAR3 * ) ; VAR6 * VAR7 = VAR2 -> VAR8 ; int VAR9 ; FUN2 ( NULL , VAR5 ) ; FUN3 ( NULL , VAR2 , 1 ) ; if ( ! ( VAR5 = VAR7 -> VAR5 ) ) VAR5 = VAR10 ; if ( ( VAR7 -> VAR11 & VAR4 -> VAR12 ) != VAR7 -> VAR11 || VAR7 -> VAR13 & VAR4 -> VAR12 ) { FUN4 ( VAR2 -> VAR7 , VAR14 , "" "" , VAR4 -> VAR12 , VAR2 -> VAR8 -> VAR11 , VAR2 -> VAR8 -> VAR13 ) ; VAR2 -> VAR15 = FUN5 ( VAR2 , VAR7 -> VAR11 , VAR4 -> VAR16 -> VAR17 ) ; VAR2 -> VAR15 -> VAR18 = VAR4 -> VAR18 ; VAR2 -> VAR15 -> VAR16 -> VAR19 = VAR4 -> VAR16 -> VAR19 ; for ( VAR9 = 0 ; VAR4 -> VAR20 [ VAR9 ] ; VAR9 ++ ) memcpy ( VAR2 -> VAR15 -> VAR20 [ VAR9 ] , VAR4 -> VAR20 [ VAR9 ] , VAR4 -> VAR21 [ 0 ] ) ; FUN6 ( VAR4 ) ; } else VAR2 -> VAR15 = VAR4 ; FUN7 ( VAR2 , VAR2 -> VAR15 ) ; } "#1
7#7#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; uint32_t VAR8 , VAR9 ; int VAR10 = 8 ; int VAR11 , VAR12 , VAR13 , VAR14 ; VAR14 = 32768 ; if ( VAR2 -> VAR15 > 0 ) VAR14 = ( FUN2 ( VAR4 ) - VAR2 -> VAR16 ) % VAR2 -> VAR15 + 3 ; VAR11 = VAR12 = VAR13 = -1 ; while ( VAR14 -- > 0 ) { VAR11 = VAR12 ; VAR12 = VAR13 ; VAR13 = FUN3 ( VAR4 ) ; if ( VAR11 == 0x82 && ! VAR12 && ! VAR13 ) break ; } if ( VAR11 != 0x82 ) { if ( VAR4 -> VAR17 == FUN4 ( VAR18 ) ) return FUN4 ( VAR18 ) ; if ( ! VAR4 -> VAR19 ) FUN5 ( VAR2 , VAR20 , , VAR11 , FUN2 ( VAR4 ) ) ; } if ( ( VAR11 & 0x8f ) == 0x82 ) { if ( VAR12 || VAR13 ) { if ( ! VAR4 -> VAR19 ) FUN5 ( VAR2 , VAR20 , VAR21VAR21VAR21 , VAR2 -> VAR15 , VAR6 -> VAR31 , VAR6 -> VAR28 ) ; return 0 ; } #0
8#8#int FUN1 ( VAR1 * VAR2 , const char * VAR3 , int VAR4 , VAR5 * VAR6 , const VAR7 * VAR8 , const VAR9 * VAR10 , int VAR11 ) { unsigned char * VAR12 , VAR13 [ VAR14 ] ; const unsigned char * VAR15 ; int VAR16 , VAR17 , VAR18 ; int VAR19 = 0 ; unsigned int VAR20 = 0 ; int VAR21 , VAR22 ; VAR23 * VAR24 = NULL ; const VAR9 * VAR25 ; if ( FUN2 ( VAR2 ) == NULL ) { FUN3 ( VAR26 , VAR27 ) ; goto VAR28 ; } VAR20 = FUN4 ( VAR2 ) ; FUN5 ( VAR20 <= sizeof VAR13 ) ; if ( ! VAR6 || ( VAR6 -> VAR29 != VAR30 ) ) { FUN3 ( VAR26 , VAR31 ) ; goto VAR28 ; } VAR15 = VAR6 -> VAR32 . VAR33 -> VAR34 ; VAR18 = VAR6 -> VAR32 . VAR33 -> VAR35 ; if ( ! ( VAR24 = FUN6 ( NULL , & VAR15 , VAR18 ) ) ) { FUN3 ( VAR26 , VAR31 ) ; goto VAR28 ; } VAR20 = FUN4 ( VAR2 ) ; if ( VAR24 -> VAR36 && ( FUN7 ( VAR24 -> VAR36 ) != ( int ) VAR20 ) ) { FUN3 ( VAR26 , VAR37 ) ; goto VAR28 ; } if ( VAR24 -> VAR38 ) VAR21 = FUN8 ( VAR24 -> VAR38 -> VAR39 ) ; else VAR21 = VAR40 ; if ( ! FUN9 ( VAR41 , VAR21 , NULL , & VAR22 , 0 ) ) { FUN3 ( VAR26 , VAR42 ) ; goto VAR28 ; } VAR25 = FUN10 ( VAR22 ) ; if ( VAR25 == NULL ) { FUN3 ( VAR26 , VAR42 ) ; goto VAR28 ; } if ( VAR24 -> VAR12 -> VAR29 != VAR43 ) { FUN3 ( VAR26 , VAR44 ) ; goto VAR28 ; } VAR12 = VAR24 -> VAR12 -> VAR32 . VAR45 -> VAR34 ; VAR16 = VAR24 -> VAR12 -> VAR32 . VAR45 -> VAR35 ; VAR17 = FUN7 ( VAR24 -> VAR17 ) ; if ( ! FUN11 ( VAR3 , VAR4 , VAR12 , VAR16 , VAR17 , VAR25 , VAR20 , VAR13 ) ) goto VAR28 ; VAR19 = FUN12 ( VAR2 , NULL , NULL , VAR13 , NULL , VAR11 ) ; VAR28 : FUN13 ( VAR13 , VAR20 ) ; FUN14 ( VAR24 ) ; return VAR19 ; } #0
9#9#int FUN1 ( VAR1 * VAR2 , int VAR3 , unsigned int VAR4 ) { int VAR5 = 1 ; VAR2 -> VAR6 = VAR7 ; VAR2 -> VAR4 = VAR4 ; VAR2 -> VAR3 = VAR3 ; switch ( VAR3 ) { default : FUN2 ( VAR8 , VAR9 ) ; return -2 ; case 0 : return 1 ; case VAR10 : case VAR11 : case VAR12 : VAR5 = FUN3 ( VAR2 ) ; break ; } if ( VAR5 < 0 ) FUN2 ( VAR8 , VAR13 ) ; return VAR5 ; } #0
10#10#int FUN1 ( int argc , char * * argv ) { VAR1 * VAR2 ; int VAR3 , VAR4 ; FUNC_TYPE VAR5 ; char * VAR6 ; HELPLIST_CHOICE VAR7 ; VAR6 = FUN2 ( argc , argv , VAR8 ) ; while ( ( VAR7 = FUN3 ( ) ) != VAR9 ) { switch ( VAR7 ) { default : FUN4 ( VAR10 , , VAR6 ) ; return 1 ; } FUN4 ( VAR10 , ) ; VAR4 = 1 ; } if ( VAR2 -> VAR16 != VAR5 ) { VAR5 = VAR2 -> VAR16 ; if ( ! VAR4 ) FUN4 ( VAR10 , ) ; } else if ( VAR5 == VAR18 ) { VAR3 = 1 ; FUN4 ( VAR10 , ) ; return 0 ; } #0
11#11#"void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; FUN2 ( VAR2 , "" "" , VAR5 ) ; FUN3 ( VAR2 -> VAR10 , VAR11 << 6 ) ; FUN3 ( VAR2 -> VAR10 , ( VAR8 -> VAR12 & 0x7f ) | ( ( VAR6 & 0x01 ) << 7 ) ) ; FUN4 ( VAR2 -> VAR10 , VAR8 -> VAR13 ) ; FUN5 ( VAR2 -> VAR10 , VAR8 -> VAR14 ) ; FUN5 ( VAR2 -> VAR10 , VAR8 -> VAR15 ) ; FUN6 ( VAR2 -> VAR10 , VAR4 , VAR5 ) ; FUN7 ( VAR2 -> VAR10 ) ; VAR8 -> VAR13 = ( VAR8 -> VAR13 + 1 ) & 0xffff ; VAR8 -> VAR16 += VAR5 ; VAR8 -> VAR17 ++ ; } "#1
12#12#int FUN1 ( VAR1 * VAR2 [ 4 ] , int VAR3 [ 4 ] , int VAR4 , int VAR5 , enum AVPixelFormat VAR6 , int VAR7 ) { const VAR8 * VAR9 = FUN2 ( VAR6 ) ; int VAR10 , VAR11 ; VAR1 * VAR12 ; if ( ! VAR9 ) return FUN3 ( VAR13 ) ; if ( ( VAR11 = FUN4 ( VAR4 , VAR5 , 0 , NULL ) ) < 0 ) return VAR11 ; if ( ( VAR11 = FUN5 ( VAR3 , VAR6 , VAR7 > 7 ? FUN6 ( VAR4 , 8 ) : VAR4 ) ) < 0 ) return VAR11 ; for ( VAR10 = 0 ; VAR10 < 4 ; VAR10 ++ ) VAR3 [ VAR10 ] = FUN6 ( VAR3 [ VAR10 ] , VAR7 ) ; if ( ( VAR11 = FUN7 ( VAR2 , VAR6 , VAR5 , NULL , VAR3 ) ) < 0 ) return VAR11 ; VAR12 = FUN8 ( VAR11 + VAR7 ) ; if ( ! VAR12 ) return FUN3 ( VAR14 ) ; if ( ( VAR11 = FUN7 ( VAR2 , VAR6 , VAR5 , VAR12 , VAR3 ) ) < 0 ) { FUN9 ( VAR12 ) ; return VAR11 ; } if ( VAR9 -> VAR15 & VAR16 || VAR9 -> VAR15 & VAR17 ) FUN10 ( ( VAR18 * ) VAR2 [ 1 ] , VAR6 ) ; if ( ( VAR9 -> VAR15 & VAR16 || VAR9 -> VAR15 & VAR17 ) && VAR2 [ 1 ] - VAR2 [ 0 ] > VAR3 [ 0 ] * VAR5 ) { memset ( VAR2 [ 0 ] + VAR3 [ 0 ] * VAR5 , 0 , VAR2 [ 1 ] - VAR2 [ 0 ] - VAR3 [ 0 ] * VAR5 ) ; } return VAR11 ; } #0
13#13#"static int FUN1 ( void ) { #if HAVE_TERMIOS_H int VAR1 = 1 ; unsigned char VAR2 ; struct timeval VAR3 ; fd_set VAR4 ; FUN2 ( & VAR4 ) ; FUN3 ( 0 , & VAR4 ) ; VAR3 . VAR5 = 0 ; VAR3 . VAR6 = 0 ; VAR1 = FUN4 ( 1 , & VAR4 , NULL , NULL , & VAR3 ) ; if ( VAR1 > 0 ) { VAR1 = read ( 0 , & VAR2 , 1 ) ; if ( VAR1 == 1 ) return VAR2 ; return VAR1 ; } #elif VAR7 if(kbhit()) return(getch()); #endif return -1; } "#1
14#14#static int FUN1 ( VAR1 * VAR2 ) { const char * VAR3 = VAR2 -> VAR4 ; const char * VAR5 = VAR2 -> VAR4 + VAR2 -> VAR6 ; while ( VAR3 < VAR5 ) { int VAR7 ; if ( ! memcmp ( VAR3 , , 7 ) ) return VAR8 / 3 ; VAR7 = FUN2 ( VAR3 ) ; if ( ! VAR7 ) break ; VAR3 += VAR7 ; } return 0 ; } #0
15#15#"int FUN1 ( BN_ULONG VAR1 ) { static const char VAR2 [ 256 ] = { 0 , 1 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 5 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , } ; #if FUN2 ( VAR3 ) if ( VAR1 & 0xffffffff00000000L ) { if ( VAR1 & 0xffff000000000000L ) { if ( VAR1 & 0xff00000000000000L ) { return ( VAR2 [ ( int ) ( VAR1 >> 56 ) ] +56 ) ; } else return ( VAR2 [ ( int ) ( VAR1 >> 48 ) ] + 48 ) ; } else { if ( VAR1 & 0x0000ff0000000000L ) { return ( VAR2 [ ( int ) ( VAR1 >> 40 ) ] + 40 ) ; } else return ( VAR2 [ ( int ) ( VAR1 >> 32 ) ] + 32 ) ; } } else #else #ifdef SIXTY_FOUR_BIT if ( VAR1 & 0xffffffff00000000LL ) { if ( VAR1 & 0xffff000000000000LL ) { if ( VAR1 & 0xff00000000000000LL ) { return ( VAR2 [ ( int ) ( VAR1 >> 56 ) ] + 56 ) ; } else return ( VAR2 [ ( int ) ( VAR1 >> 48 ) ] + 48 ) ; } else { if ( VAR1 & 0x0000ff0000000000LL ) { return ( VAR2 [ ( int ) ( VAR1 >> 40 ) ] + 40 ) ; } else return ( VAR2 [ ( int ) ( VAR1 >> 32 ) ] + 32 ) ; } } else #endif #endif { #if FUN2(VAR4) || FUN2(VAR5) || FUN2(VAR3) if (VAR1 & 0xffff0000L) { if (VAR1 & 0xff000000L) return(VAR2[(int)(VAR1>>24L)]+24); else	return(VAR2[(int)(VAR1>>16L)]+16); } else #endif { #if FUN2(VAR6) || FUN2(VAR4) || FUN2(VAR5) || FUN2(VAR3) if (VAR1 & 0xff00L) return(VAR2[(int)(VAR1>>8)]+8); else #endif return(VAR2[(int)(VAR1   )]  ); } } } "#1
16#16#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 ; int VAR5 = 0 ; if ( FUN2 ( & VAR2 -> VAR6 , 32 ) != FUN3 ( ) ; return VAR9 ; } VAR2 -> VAR10 = 0 ; VAR2 -> VAR11 = VAR12 ; VAR2 -> VAR13 = -1 ; VAR2 -> VAR14 = FUN5 ( & VAR2 -> VAR6 , 8 ) ; VAR2 -> VAR15 = FUN6 ( VAR2 , VAR16 ) ; VAR2 -> VAR17 = FUN6 ( VAR2 , VAR18 ) ; if ( ! VAR2 -> VAR17 ) { FUN4 ( VAR2 -> VAR7 , VAR8 , , VAR2 -> VAR17 ) ; VAR2 -> VAR17 = 0 ; return VAR9 ; } VAR2 -> VAR7 -> VAR17 = VAR2 -> VAR17 ; if ( VAR2 -> VAR14 > 0 ) { int VAR20 ; unsigned VAR11 ; VAR11 = FUN6 ( VAR2 , FUN7 ( VAR12 ) ) ; if ( ! VAR11 || VAR11 > VAR21 ) { FUN4 ( VAR2 -> VAR7 , VAR8 , , VAR5 ) ; return VAR9 ; } VAR2 -> VAR13 = FUN6 ( VAR2 , 0 ) ; VAR20 = FUN6 ( VAR2 , VAR24 ) ; if ( ( unsigned ) VAR20 > FUN9 ( & VAR2 -> VAR6 ) / 8 ) { FUN4 ( VAR2 -> VAR7 , VAR8 , ) ; return VAR9 ; } VAR2 -> VAR32 = FUN14 ( & VAR2 -> VAR6 , VAR33 ) ; if ( VAR2 -> VAR32 >= VAR34 || VAR2 -> VAR32 < VAR35 ) { FUN4 ( VAR2 -> VAR7 , VAR8 , VAR38 , FUN15 ( VAR2 -> VAR36 ) ) ; return VAR39 ; } VAR29 : VAR2 -> VAR40 = 0 ; VAR2 -> VAR41 = 0 ; VAR2 -> VAR42 = 1 ; return 0 ; } #0
17#17#VAR1 * FUN1 ( void ) { VAR1 * VAR2 ; VAR2 = ( VAR1 * ) FUN2 ( sizeof ( VAR1 ) ) ; if ( VAR2 == NULL ) { FUN3 ( VAR3 , VAR4 ) ; return NULL ; } memset ( VAR2 , 0 , sizeof ( VAR1 ) ) ; VAR2 -> VAR5 = 1 ; return VAR2 ; } #1
18#18#"int FUN1 ( int VAR1 , char * * VAR2 ) { int VAR3 = VAR4 ; static struct sockaddr_in VAR5 ; unsigned long VAR6 ; unsigned short VAR7 ; int VAR8 ; char * VAR9 ; memset ( ( char * ) & VAR5 , 0 , sizeof ( VAR5 ) ) ; VAR8 = sizeof ( VAR5 ) ; VAR3 = FUN2 ( VAR1 , ( struct VAR10 * ) & VAR5 , ( void * ) & VAR8 ) ; if ( VAR3 == VAR4 ) { if ( FUN3 ( VAR3 ) ) return -2 ; FUN4 ( VAR11 , FUN5 ( ) ) ; FUN6 ( VAR12 , VAR13 ) ; goto VAR14 ; } if ( VAR2 == NULL ) goto VAR14 ; VAR6 = FUN7 ( VAR5 . VAR15 . VAR16 ) ; VAR7 = FUN8 ( VAR5 . VAR17 ) ; if ( * VAR2 == NULL ) { if ( ( VAR9 = FUN9 ( 24 ) ) == NULL ) { FUN6 ( VAR12 , VAR18 ) ; goto VAR14 ; } * VAR2 = VAR9 ; } FUN10 ( * VAR2 , 24 , "" "" , ( unsigned char ) ( VAR6 >> 24L ) & 0xff , ( unsigned char ) ( VAR6 >> 16L ) & 0xff , ( unsigned char ) ( VAR6 >> 8L ) & 0xff , ( unsigned char ) ( VAR6 ) & 0xff , VAR7 ) ; VAR14 : return ( VAR3 ) ; } "#0
19#19#"static VAR1 * FUN1 ( ) { APP_INFO VAR2 ; VAR1 * VAR3 = NULL ; if ( VAR4 != NULL ) { VAR2 . VAR5 = FUN2 ( ) ; if ( ( VAR3 = ( VAR1 * ) FUN3 ( VAR4 , ( char * ) & VAR2 ) ) ! = NULL ) { VAR1 * VAR6 = VAR3 -> VAR6 ; if ( VAR6 != NULL ) { VAR6 -> VAR7 ++ ; FUN4 ( VAR4 , ( char * ) VAR6 ) ; } #ifdef LEVITTE_DEBUG if ( VAR3 -> VAR5 != VAR2 . VAR5 ) { fprintf ( VAR8 , "" "" , VAR3 -> VAR5 , VAR2 . VAR5 ) ; FUN5 ( ) ; } #endif if ( -- ( VAR3 -> VAR7 ) <= 0 ) { VAR3 -> VAR6 = NULL ; if ( VAR6 != NULL ) VAR6 -> VAR7 -- ; FUN6 ( VAR3 ) ; } } } return ( VAR3 ) ; } "#0
20#20#"static av_always_inline void FUN1 ( VAR1 * VAR2 , int VAR3 , unsigned VAR4 , unsigned VAR5 , unsigned VAR6 , unsigned VAR7 , const void * VAR8 , const void * VAR9 , const void * VAR10 , int VAR11 , enum PixelFormat VAR12 , int VAR13 ) { if ( VAR12 == VAR14 || VAR12 == VAR15 || VAR12 == VAR16 || VAR12 == VAR17 ) { VAR18 * VAR19 = ( VAR18 * ) VAR2 ; const VAR18 * VAR20 = ( const VAR18 * ) VAR8 ; const VAR18 * VAR21 = ( const VAR18 * ) VAR9 ; const VAR18 * VAR22 = ( const VAR18 * ) VAR10 ; #if CONFIG_SMALL int VAR23 = VAR13 ? ( ( VAR12 == VAR24 || VAR12 == VAR25 ) ? 0 : 24 ) : 0 ; VAR19 [ VAR3 * 2 + 0 ] = VAR20 [ VAR4 ] + VAR21 [ VAR4 ] + VAR22 [ VAR4 ] + ( VAR13 ? VAR6 << VAR23 : 0 ) ; VAR19 [ VAR3 * 2 + 1 ] = VAR20 [ VAR5 ] + VAR21 [ VAR5 ] + VAR22 [ VAR5 ] + ( VAR13 ? VAR7 << VAR23 : 0 ) ; #else if (VAR13) { int VAR23 = (VAR12 == VAR24 || VAR12 == VAR25) ? 0 : 24;  VAR19[VAR3 * 2 + 0] = VAR20[VAR4] + VAR21[VAR4] + VAR22[VAR4] + (VAR6 << VAR23); VAR19[VAR3 * 2 + 1] = VAR20[VAR5] + VAR21[VAR5] + VAR22[VAR5] + (VAR7 << VAR23); } else { VAR19[VAR3 * 2 + 0] = VAR20[VAR4] + VAR21[VAR4] + VAR22[VAR4]; VAR19[VAR3 * 2 + 1] = VAR20[VAR5] + VAR21[VAR5] + VAR22[VAR5]; } #endif } else if (VAR12 == VAR26 || VAR12 == VAR27) { VAR1 *VAR19 = (VAR1 *) VAR2; const VAR1 *VAR20 = (const VAR1 *) VAR8; const VAR1 *VAR21 = (const VAR1 *) VAR9; const VAR1 *VAR22 = (const VAR1 *) VAR10;  #define FUN2 ((VAR12 == VAR26) ? VAR20 : VAR22) #define FUN3 ((VAR12 == VAR26) ? VAR22 : VAR20)  VAR19[VAR3 * 6 + 0] = VAR28[VAR4]; VAR19[VAR3 * 6 + 1] =   VAR21[VAR4]; VAR19[VAR3 * 6 + 2] = VAR29[VAR4]; VAR19[VAR3 * 6 + 3] = VAR28[VAR5]; VAR19[VAR3 * 6 + 4] =   VAR21[VAR5]; VAR19[VAR3 * 6 + 5] = VAR29[VAR5]; #undef VAR28 #undef VAR29 } else if (VAR12 == VAR30 || VAR12 == VAR31 || VAR12 == VAR32 || VAR12 == VAR33 || VAR12 == VAR34 || VAR12 == VAR35) { VAR36 *VAR19 = (VAR36 *) VAR2; const VAR36 *VAR20 = (const VAR36 *) VAR8; const VAR36 *VAR21 = (const VAR36 *) VAR9; const VAR36 *VAR22 = (const VAR36 *) VAR10; int VAR37, VAR38, VAR39, VAR40, VAR41, VAR42;  if (VAR12 == VAR30 || VAR12 == VAR31) { VAR37 = VAR43[ VAR11 & 1     ][0]; VAR38 = VAR44[ VAR11 & 1     ][0]; VAR39 = VAR43[(VAR11 & 1) ^ 1][0]; VAR40 = VAR43[ VAR11 & 1     ][1]; VAR41 = VAR44[ VAR11 & 1     ][1]; VAR42 = VAR43[(VAR11 & 1) ^ 1][1]; } else if (VAR12 == VAR32 || VAR12 == VAR33) { VAR37 = VAR43[ VAR11 & 1     ][0]; VAR38 = VAR43[ VAR11 & 1     ][1]; VAR39 = VAR43[(VAR11 & 1) ^ 1][0]; VAR40 = VAR43[ VAR11 & 1     ][1]; VAR41 = VAR43[ VAR11 & 1     ][0]; VAR42 = VAR43[(VAR11 & 1) ^ 1][1]; } else { VAR37 = VAR45[ VAR11 & 3     ][0]; VAR38 = VAR45[ VAR11 & 3     ][1]; VAR39 = VAR45[(VAR11 & 3) ^ 3][0]; VAR40 = VAR45[ VAR11 & 3     ][1]; VAR41 = VAR45[ VAR11 & 3     ][0]; VAR42 = VAR45[(VAR11 & 3) ^ 3][1]; }  VAR19[VAR3 * 2 + 0] = VAR20[VAR4 + VAR37] + VAR21[VAR4 + VAR38] + VAR22[VAR4 + VAR39]; VAR19[VAR3 * 2 + 1] = VAR20[VAR5 + VAR40] + VAR21[VAR5 + VAR41] + VAR22[VAR5 + VAR42]; } else  { VAR1 *VAR19 = (VAR1 *) VAR2; const VAR1 *VAR20 = (const VAR1 *) VAR8; const VAR1 *VAR21 = (const VAR1 *) VAR9; const VAR1 *VAR22 = (const VAR1 *) VAR10; int VAR37, VAR38, VAR39, VAR40, VAR41, VAR42;  if (VAR12 == VAR46 || VAR12 == VAR47) { const VAR1 * const VAR48 = VAR49[VAR11 & 7]; const VAR1 * const VAR50 = VAR51[VAR11 & 7]; VAR37 = VAR38 = VAR50[(VAR3 * 2 + 0) & 7]; VAR39 =       VAR48[(VAR3 * 2 + 0) & 7]; VAR40 = VAR41 = VAR50[(VAR3 * 2 + 1) & 7]; VAR42 =       VAR48[(VAR3 * 2 + 1) & 7]; } else { const VAR1 * const VAR48  = VAR49 [VAR11 & 7]; const VAR1 * const VAR52 = VAR53[VAR11 & 7]; VAR37 = VAR39 = VAR52[(VAR3 * 2 + 0) & 7]; VAR38 =        VAR48[(VAR3 * 2 + 0) & 7]; VAR40 = VAR42 = VAR52[(VAR3 * 2 + 1) & 7]; VAR41 =        VAR48[(VAR3 * 2 + 1) & 7]; }  if (VAR12 == VAR54 || VAR12 == VAR55) { VAR19[VAR3] = VAR20[VAR4 + VAR37] + VAR21[VAR4 + VAR38] + VAR22[VAR4 + VAR39] + ((VAR20[VAR5 + VAR40] + VAR21[VAR5 + VAR41] + VAR22[VAR5 + VAR42]) << 4); } else { VAR19[VAR3 * 2 + 0] = VAR20[VAR4 + VAR37] + VAR21[VAR4 + VAR38] + VAR22[VAR4 + VAR39]; VAR19[VAR3 * 2 + 1] = VAR20[VAR5 + VAR40] + VAR21[VAR5 + VAR41] + VAR22[VAR5 + VAR42]; } } } "#1
21#21#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 = 1 ; int VAR9 = FUN2 ( VAR4 ) ; int64_t VAR10 , VAR11 ; VAR6 -> VAR12 -- ; VAR6 -> VAR13 = VAR9 >> 7 ; VAR6 -> VAR14 = VAR6 -> VAR15 [ VAR9 & 0x7f ] ; FUN3 ( VAR6 -> VAR16 >> 4 , VAR6 -> VAR17 , 0 ) ; FUN3 ( VAR6 -> VAR16 >> 2 , VAR6 -> VAR18 , 0 ) ; FUN3 ( VAR6 -> VAR16 , VAR6 -> VAR19 , 0 ) ; if ( VAR6 -> VAR19 >= 8 ) { VAR6 -> VAR20 = FUN4 ( VAR4 ) ; if ( VAR6 -> VAR20 >= ( 1 << 24 ) || VAR6 -> VAR20 <= 0 ) { FUN5 ( VAR2 , VAR21 , , VAR6 -> VAR19 ) ; return -1 ; } if ( VAR6 -> VAR27 & 0x01 ) { FUN3 ( VAR6 -> VAR28 >> 6 , VAR6 -> VAR29 , 0 ) ; if ( VAR6 -> VAR29 > VAR6 -> VAR30 - VAR8 ) { if ( VAR6 -> VAR29 > VAR6 -> VAR30 - VAR8 + VAR6 -> VAR31 ) { FUN5 ( VAR2 , VAR21 , "" "" , VAR6 -> VAR30 , VAR8 ) ; return -1 ; } else { int VAR32 = VAR6 -> VAR29 - ( VAR6 -> VAR30 - VAR8 ) ; VAR6 -> VAR30 += VAR32 ; VAR6 -> VAR31 -= VAR32 ; } } } else { VAR6 -> VAR29 = VAR6 -> VAR30 - VAR8 ; } if ( VAR6 -> VAR19 == 1 ) { VAR6 -> VAR33 = VAR6 -> VAR29 ; if ( VAR6 -> VAR33 > VAR6 -> VAR30 ) return -1 ; } VAR6 -> VAR30 -= VAR8 ; return 0 ; } "#1
22#22#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 ; int VAR7 , VAR8 , VAR9 ; FUN2 ( VAR4 ) ; for ( ; ; ) { VAR6 = VAR2 -> VAR10 ; if ( VAR6 ) { if ( ! VAR6 -> VAR11 || ! VAR6 -> VAR12 ) { * VAR4 = VAR6 -> VAR13 ; VAR6 -> VAR13 . VAR14 = NULL ; FUN3 ( VAR2 , VAR6 , NULL , VAR4 ) ; VAR2 -> VAR10 = NULL ; if ( ( VAR2 -> VAR15 -> VAR16 & VAR17 ) && ( VAR4 -> VAR16 & VAR18 ) && VAR4 -> VAR19 != VAR20 ) { FUN4 ( VAR2 , VAR6 -> VAR21 ) ; FUN5 ( VAR6 , VAR4 -> VAR22 , VAR4 -> VAR19 , 0 , 0 , VAR23 ) ; } break ; } else if ( VAR6 -> VAR24 > 0 && VAR6 -> VAR25 < VAR26 ) { VAR7 = FUN6 ( VAR6 -> VAR12 , VAR6 -> VAR27 , & VAR4 -> VAR14 , & VAR4 -> VAR28 , VAR6 -> VAR29 , VAR6 -> VAR24 , VAR6 -> VAR13 . VAR30 , VAR6 -> VAR13 . VAR19 , VAR6 -> VAR13 . VAR22 ) ; VAR6 -> VAR13 . VAR30 = VAR20 ; VAR6 -> VAR13 . VAR19 = VAR20 ; VAR6 -> VAR29 += VAR7 ; VAR6 -> VAR24 -= VAR7 ; if ( VAR4 -> VAR28 ) { VAR31 : VAR4 -> VAR32 = 0 ; if ( VAR6 -> VAR27 -> VAR33 == VAR34 ) { if ( VAR6 -> VAR27 -> VAR35 > 0 ) { VAR4 -> VAR32 = FUN7 ( VAR6 -> VAR12 -> VAR32 , ( VAR36 ) { 1 , VAR6 -> VAR27 -> VAR35 } , VAR6 -> VAR37 , VAR38 ) ; } } else if ( VAR6 -> VAR27 -> VAR37 . VAR39 != 0 && VAR6 -> VAR27 -> VAR37 . VAR40 != 0 ) { VAR4 -> VAR32 = FUN7 ( VAR6 -> VAR12 -> VAR32 , VAR6 -> VAR27 -> VAR37 , VAR6 -> VAR37 , VAR38 ) ; } VAR4 -> VAR41 = VAR6 -> VAR21 ; VAR4 -> VAR30 = VAR6 -> VAR12 -> VAR30 ; VAR4 -> VAR19 = VAR6 -> VAR12 -> VAR19 ; VAR4 -> VAR22 = VAR6 -> VAR12 -> VAR22 ; if ( VAR6 -> VAR12 -> VAR42 == 1 || ( VAR6 -> VAR12 -> VAR42 == -1 && VAR6 -> VAR12 -> VAR43 == VAR44 ) ) VAR4 -> VAR16 |= VAR18 ; if ( VAR4 -> VAR14 == VAR6 -> VAR13 . VAR14 && VAR4 -> VAR28 == VAR6 -> VAR13 . VAR28 ) { VAR2 -> VAR10 = NULL ; VAR4 -> VAR45 = VAR6 -> VAR13 . VAR45 ; VAR6 -> VAR13 . VAR45 = NULL ; VAR6 -> VAR13 . VAR14 = NULL ; assert ( VAR6 -> VAR24 == 0 ) ; } else { VAR4 -> VAR45 = NULL ; } FUN3 ( VAR2 , VAR6 , VAR6 -> VAR12 , VAR4 ) ; if ( ( VAR2 -> VAR15 -> VAR16 & VAR17 ) && VAR4 -> VAR16 & VAR18 ) { FUN4 ( VAR2 , VAR6 -> VAR21 ) ; FUN5 ( VAR6 , VAR6 -> VAR12 -> VAR46 , VAR4 -> VAR19 , 0 , 0 , VAR23 ) ; } break ; } } else { FUN8 ( & VAR6 -> VAR13 ) ; VAR2 -> VAR10 = NULL ; } } else { AVPacket VAR13 ; VAR8 = FUN9 ( VAR2 , & VAR13 ) ; if ( VAR8 < 0 ) { if ( VAR8 == FUN10 ( VAR47 ) ) return VAR8 ; for ( VAR9 = 0 ; VAR9 < VAR2 -> VAR48 ; VAR9 ++ ) { VAR6 = VAR2 -> VAR49 [ VAR9 ] ; if ( VAR6 -> VAR12 && VAR6 -> VAR11 ) { FUN6 ( VAR6 -> VAR12 , VAR6 -> VAR27 , & VAR4 -> VAR14 , & VAR4 -> VAR28 , NULL , 0 , VAR20 , VAR20 , VAR20 ) ; if ( VAR4 -> VAR28 ) goto VAR31 ; } } return VAR8 ; } VAR6 = VAR2 -> VAR49 [ VAR13 . VAR41 ] ; VAR6 -> VAR13 = VAR13 ; if ( VAR6 -> VAR13 . VAR30 != VAR20 && VAR6 -> VAR13 . VAR19 != VAR20 && VAR6 -> VAR13 . VAR30 < VAR6 -> VAR13 . VAR19 ) { FUN11 ( VAR2 , VAR50 , VAR51VAR51 , VAR6 -> VAR13 . VAR41 , VAR6 -> VAR13 . VAR30 , VAR6 -> VAR13 . VAR19 , VAR6 -> VAR13 . VAR28 , VAR6 -> VAR13 . VAR32 , VAR6 -> VAR13 . VAR16 ) ; VAR2 -> VAR10 = VAR6 ; VAR6 -> VAR29 = VAR6 -> VAR13 . VAR14 ; VAR6 -> VAR24 = VAR6 -> VAR13 . VAR28 ; if ( VAR6 -> VAR11 && ! VAR6 -> VAR12 && ! ( VAR2 -> VAR16 & VAR55 ) ) { VAR6 -> VAR12 = FUN12 ( VAR6 -> VAR27 -> VAR56 ) ; if ( ! VAR6 -> VAR12 ) { VAR6 -> VAR11 = VAR57 ; } else if ( VAR6 -> VAR11 == VAR58 ) { VAR6 -> VAR12 -> VAR16 |= VAR59 ; } else if ( VAR6 -> VAR11 == VAR60 ) { VAR6 -> VAR12 -> VAR16 |= VAR61 ; } } } } if ( VAR2 -> VAR52 & VAR53 ) FUN11 ( VAR2 , VAR54 , VAR51 "" "" , VAR4 -> VAR41 , VAR4 -> VAR30 , VAR4 -> VAR19 , VAR4 -> VAR28 , VAR4 -> VAR32 , VAR4 -> VAR16 ) ; return 0 ; } "#1
23#23#static VAR1 FUN1 ( int ( * VAR2 ) [ 2 ] , int VAR3 ) { SoftFloat VAR4 ; int64_t VAR5 = 0 ; int VAR6 , VAR7 , VAR8 ; for ( VAR6 = 0 ; VAR6 < VAR3 ; VAR6 += 2 ) { FUN2 ( FUN3 ( VAR2 [ VAR6 + 0 ] [ 0 ] ) >> 29 == 0 ) ; VAR5 += ( VAR9 ) VAR2 [ VAR6 + 0 ] [ 0 ] * VAR2 [ VAR6 + 0 ] [ 0 ] ; FUN2 ( FUN3 ( VAR2 [ VAR6 + 0 ] [ 1 ] ) >> 29 == 0 ) ; VAR5 += ( VAR9 ) VAR2 [ VAR6 + 0 ] [ 1 ] * VAR2 [ VAR6 + 0 ] [ 1 ] ; FUN2 ( FUN3 ( VAR2 [ VAR6 + 1 ] [ 0 ] ) >> 29 == 0 ) ; VAR5 += ( VAR9 ) VAR2 [ VAR6 + 1 ] [ 0 ] * VAR2 [ VAR6 + 1 ] [ 0 ] ; FUN2 ( FUN3 ( VAR2 [ VAR6 + 1 ] [ 1 ] ) >> 29 == 0 ) ; VAR5 += ( VAR9 ) VAR2 [ VAR6 + 1 ] [ 1 ] * VAR2 [ VAR6 + 1 ] [ 1 ] ; } VAR6 = ( int ) ( VAR5 >> 32 ) ; if ( VAR6 == 0 ) { VAR7 = 1 ; } else { VAR7 = 0 ; while ( FUN3 ( VAR6 ) < 0x40000000 ) { VAR6 <<= 1 ; VAR7 ++ ; } VAR7 = 32 - VAR7 ; } VAR8 = 1 << ( VAR7 - 1 ) ; VAR6 = ( int ) ( ( VAR5 + VAR8 ) >> VAR7 ) ; VAR6 >>= 1 ; VAR4 = FUN4 ( VAR6 , 15 - VAR7 ) ; return VAR4 ; } #1
24#24#"void FUN1 ( char * VAR1 , const char * VAR2 , int VAR3 , char * VAR4 ) { static const unsigned char VAR5 [ 17 ] = , VAR8 ) ; FUN2 ( VAR1 , VAR2 , VAR8 ) ; FUN2 ( VAR1 , "" "" , VAR8 ) ; VAR7 = strlen ( VAR1 ) ; if ( VAR7 + ( VAR3 * 2 ) + 1 > VAR8 ) return ; for ( VAR6 = 0 ; VAR6 < VAR3 ; VAR6 ++ ) { VAR1 [ VAR7 + VAR6 * 2 ] = VAR5 [ ( VAR4 [ VAR6 ] >> 4 ) & 0x0f ] ; VAR1 [ VAR7 + VAR6 * 2 + 1 ] = VAR5 [ ( VAR4 [ VAR6 ] ) & 0x0f ] ; } VAR1 [ VAR7 + VAR6 * 2 ] = ' ' ; VAR1 [ VAR7 + VAR6 * 2 + 1 ] = ' ' ; } "#0
25#25#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , tmsize_t VAR5 , uint16 VAR6 ) { tmsize_t VAR7 = FUN2 ( VAR2 ) ; if ( VAR7 == 0 ) return 0 ; assert ( VAR5 % VAR7 == 0 ) ; while ( VAR5 && ( * VAR2 -> VAR8 ) ( VAR2 , VAR4 , VAR7 , VAR6 ) == 1 ) { VAR4 += VAR7 ; VAR5 -= VAR7 ; } return ( VAR5 == 0 ) ; } #1
26#26#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR3 * VAR5 , int * VAR6 , int VAR7 , int VAR8 , int VAR9 ) { int VAR10 , VAR11 ; int VAR12 = VAR2 -> VAR12 ; int VAR13 = VAR2 -> VAR13 ; int VAR14 = VAR2 -> VAR15 % VAR2 -> VAR16 ; int VAR15 = VAR2 -> VAR15 / VAR2 -> VAR16 ; int VAR17 = VAR2 -> VAR17 ; if ( ! VAR4 != ! VAR5 ) return FUN2 ( VAR18 ) ; if ( VAR17 == 0 && VAR2 -> VAR19 == 1 && VAR2 -> VAR20 == 0 ) { int64_t VAR21 = ( ( VAR22 ) VAR12 ) << 32 ; int64_t VAR23 = ( 1LL << 32 ) * VAR2 -> VAR15 / VAR2 -> VAR16 ; VAR8 = FUN3 ( VAR8 , ( VAR7 - 1 - VAR12 ) * ( VAR22 ) VAR2 -> VAR16 / VAR2 -> VAR15 ) ; if ( VAR4 ) { for ( VAR10 = 0 ; VAR10 < VAR8 ; VAR10 ++ ) { VAR4 [ VAR10 ] = VAR5 [ VAR21 >> 32 ] ; VAR21 += VAR23 ; } } else { VAR10 = VAR8 ; } VAR12 += VAR10 * VAR15 ; VAR12 += ( VAR13 + VAR10 * ( VAR22 ) VAR14 ) / VAR2 -> VAR16 ; VAR13 = ( VAR13 + VAR10 * ( VAR22 ) VAR14 ) % VAR2 -> VAR16 ; } else { for ( VAR10 = 0 ; VAR10 < VAR8 ; VAR10 ++ ) { VAR24 * VAR25 = VAR2 -> VAR26 + VAR2 -> VAR19 * ( VAR12 & VAR2 -> VAR27 ) ; int VAR28 = VAR12 >> VAR2 -> VAR20 ; if ( ! VAR4 && ( VAR28 + VAR2 -> VAR19 > VAR7 || - VAR28 >= VAR7 ) ) break ; if ( VAR4 ) { FELEM2 VAR29 = 0 ; if ( VAR28 < 0 ) { for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR19 ; VAR11 ++ ) VAR29 += VAR5 [ FUN4 ( VAR28 + VAR11 ) % VAR7 ] * ( VAR30 ) VAR25 [ VAR11 ] ; } else if ( VAR28 + VAR2 -> VAR19 > VAR7 ) { break ; } else if ( VAR2 -> VAR31 ) { FELEM2 VAR32 = 0 ; for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR19 ; VAR11 ++ ) { VAR29 += VAR5 [ FUN5 ( VAR28 + VAR11 ) ] * ( VAR30 ) VAR25 [ VAR11 ] ; VAR32 += VAR5 [ FUN5 ( VAR28 + VAR11 ) ] * ( VAR30 ) VAR25 [ VAR11 + VAR2 -> VAR19 ] ; } VAR29 += ( VAR32 - VAR29 ) * ( VAR33 ) VAR13 / VAR2 -> VAR16 ; } else { for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR19 ; VAR11 ++ ) VAR29 += VAR5 [ VAR28 + VAR11 ] * ( VAR30 ) VAR25 [ VAR11 ] ; } #ifdef CONFIG_RESAMPLE_FLT VAR4 [ VAR10 ] = FUN6 ( FUN7 ( VAR29 ) ) ; #else VAR29 = ( VAR29 + ( 1 << ( VAR34 - 1 ) ) ) >> VAR34 ; VAR4 [ VAR10 ] = FUN6 ( VAR29 ) ; #endif } VAR13 += VAR14 ; VAR12 += VAR15 ; if ( VAR13 >= VAR2 -> VAR16 ) { VAR13 -= VAR2 -> VAR16 ; VAR12 ++ ; } if ( VAR10 + 1 == VAR17 ) { VAR17 = 0 ; VAR14 = VAR2 -> VAR35 % VAR2 -> VAR16 ; VAR15 = VAR2 -> VAR35 / VAR2 -> VAR16 ; } } } if ( VAR6 ) * VAR6 = FUN8 ( VAR12 , 0 ) >> VAR2 -> VAR20 ; if ( VAR9 ) { if ( VAR12 >= 0 ) VAR12 &= VAR2 -> VAR27 ; if ( VAR17 ) { VAR17 -= VAR10 ; if ( VAR17 <= 0 ) return VAR36 ; } VAR2 -> VAR13 = VAR13 ; VAR2 -> VAR12 = VAR12 ; VAR2 -> VAR15 = VAR14 + VAR2 -> VAR16 * VAR15 ; VAR2 -> VAR17 = VAR17 ; } return VAR10 ; } "#1
27#27#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { int VAR6 ; if ( VAR2 -> VAR7 > 0 ) { int64_t VAR8 = VAR2 -> VAR7 - FUN2 ( VAR2 ) ; if ( VAR8 >= 0 ) VAR5 = FUN3 ( VAR5 , VAR8 ) ; } VAR6 = FUN4 ( VAR4 , VAR5 ) ; if ( VAR6 < 0 ) return VAR6 ; VAR4 -> VAR9 = FUN2 ( VAR2 ) ; VAR6 = FUN5 ( VAR2 , VAR4 -> VAR10 , VAR5 ) ; if ( VAR6 <= 0 ) FUN6 ( VAR4 ) ; else FUN7 ( VAR4 , VAR6 ) ; return VAR6 ; } #0
28#28#static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { ebml_master VAR6 , VAR7 ; int64_t VAR8 ; int VAR9 ; VAR8 = FUN2 ( VAR3 ) ; if ( VAR5 -> VAR10 > 0 ) { if ( FUN3 ( VAR3 , VAR5 -> VAR11 , VAR12 ) < 0 ) { VAR8 = -1 ; goto VAR13 ; } } VAR6 = FUN4 ( VAR3 , VAR14 , VAR5 -> VAR10 ) ; for ( VAR9 = 0 ; VAR9 < VAR5 -> VAR15 ; VAR9 ++ ) { VAR16 * VAR17 = & VAR5 -> VAR18 [ VAR9 ] ; VAR7 = FUN4 ( VAR3 , VAR19 , VAR20 ) ; FUN5 ( VAR3 , VAR21 ) ; FUN6 ( VAR3 , FUN7 ( VAR17 -> VAR22 ) , 0 ) ; FUN5 ( VAR3 , VAR17 -> VAR22 ) ; FUN8 ( VAR3 , VAR23 , VAR17 -> VAR24 ) ; FUN9 ( VAR3 , VAR7 ) ; } FUN9 ( VAR3 , VAR6 ) ; if ( VAR5 -> VAR10 > 0 ) { uint64_t VAR25 = VAR5 -> VAR11 + VAR5 -> VAR10 - FUN2 ( VAR3 ) ; FUN10 ( VAR3 , VAR25 ) ; FUN3 ( VAR3 , VAR8 , VAR12 ) ; VAR8 = VAR5 -> VAR11 ; } VAR13 : FUN11 ( & VAR5 -> VAR18 ) ; FUN12 ( VAR5 ) ; return VAR8 ; } #1
29#29#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , int VAR9 , int VAR10 , int VAR11 , int VAR12 ) { int VAR13 = 2 , VAR14 , VAR15 , VAR16 , VAR17 = 0 , VAR18 , VAR19 ; int64_t VAR20 = 0 ; for ( VAR16 = 0 ; VAR16 < VAR10 + 2 ; VAR16 ++ ) memset ( VAR4 -> VAR21 [ VAR16 ] , 0 , ( VAR9 + 2 ) * sizeof ( int ) ) ; for ( VAR16 = 0 ; VAR16 < VAR10 ; VAR16 ++ ) { for ( VAR15 = 0 ; VAR15 < VAR9 ; VAR15 ++ ) { if ( VAR4 -> VAR22 [ VAR16 ] [ VAR15 ] < 0 ) { VAR4 -> VAR21 [ VAR16 + 1 ] [ VAR15 + 1 ] |= VAR23 ; VAR4 -> VAR22 [ VAR16 ] [ VAR15 ] = - VAR4 -> VAR22 [ VAR16 ] [ VAR15 ] ; } VAR17 = FUN2 ( VAR17 , VAR4 -> VAR22 [ VAR16 ] [ VAR15 ] ) ; } } if ( VAR17 == 0 ) { VAR6 -> VAR24 = 0 ; VAR19 = 0 ; } else { VAR6 -> VAR24 = FUN3 ( VAR17 ) + 1 - VAR25 ; VAR19 = VAR6 -> VAR24 - 1 ; } FUN4 ( & VAR4 -> VAR26 , VAR6 -> VAR22 ) ; for ( VAR14 = 0 ; VAR19 >= 0 ; VAR14 ++ ) { VAR18 = 0 ; switch ( VAR13 ) { case 0 : FUN5 ( VAR4 , VAR9 , VAR10 , VAR11 , & VAR18 , VAR19 ) ; break ; case 1 : FUN6 ( VAR4 , VAR9 , VAR10 , & VAR18 , VAR19 ) ; break ; case 2 : FUN7 ( VAR4 , VAR9 , VAR10 , VAR11 , & VAR18 , VAR19 ) ; break ; } VAR6 -> VAR27 [ VAR14 ] . VAR28 = FUN8 ( & VAR4 -> VAR26 , VAR6 -> VAR27 [ VAR14 ] . VAR29 , & VAR6 -> VAR27 [ VAR14 ] . VAR30 ) ; VAR20 += ( VAR31 ) VAR18 << ( 2 * VAR19 ) ; VAR6 -> VAR27 [ VAR14 ] . VAR32 = VAR20 ; if ( ++ VAR13 == 3 ) { VAR13 = 0 ; VAR19 -- ; } } VAR6 -> VAR33 = VAR14 ; VAR6 -> VAR34 = VAR14 ; VAR6 -> VAR27 [ VAR14 - 1 ] . VAR28 = FUN8 ( & VAR4 -> VAR26 , VAR6 -> VAR27 [ VAR14 - 1 ] . VAR29 , & VAR6 -> VAR27 [ VAR14 - 1 ] . VAR30 ) ; } #1
30#30#"void * FUN1 ( void * VAR1 , FF_INTERNAL_MEM_TYPE VAR2 ) { #if CONFIG_MEMALIGN_HACK int VAR3 ; #endif if(VAR2 > (VAR4-16) ) return NULL;  #if VAR5  if(!VAR1) return FUN2(VAR2); VAR3= ((char*)VAR1)[-1]; return (char*)realloc((char*)VAR1 - VAR3, VAR2 + VAR3) + VAR3; #else return realloc(VAR1, VAR2); #endif } "#1
31#31#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR2 -> VAR8 [ 0 ] -> VAR9 ; if ( VAR7 -> VAR10 != VAR11 && VAR7 -> VAR10 != VAR12 && VAR7 -> VAR10 != VAR13 && VAR7 -> VAR10 != VAR14 ) { FUN2 ( VAR2 , VAR15 , ) ; return -1 ; } VAR4 -> VAR17 = FUN3 ( VAR7 -> VAR10 ) / 8 ; if ( VAR4 -> VAR17 == 1 && VAR4 -> VAR18 == VAR19 ) { FUN2 ( VAR2 , VAR15 , ) ; FUN7 ( VAR2 ) ; return FUN4 ( VAR28 ) ; } #0
32#32#"int FUN1 ( VAR1 * * VAR2 , const char * VAR3 , int VAR4 , const VAR5 * VAR6 ) { VAR7 * VAR8 = NULL ; char VAR9 [ 128 ] , VAR10 [ 128 ] , * VAR11 ; size_t VAR12 = strspn ( VAR3 , VAR13 ) ; if ( VAR3 [ VAR12 ] != ' ' || FUN2 ( VAR3 ) ) strcpy ( VAR9 , "" "" ) ; else FUN3 ( VAR9 , VAR3 , FUN4 ( VAR12 + 1 , sizeof ( VAR9 ) ) ) ; FUN3 ( VAR10 , VAR9 , sizeof ( VAR10 ) ) ; if ( ( VAR11 = strchr ( VAR10 , ' ' ) ) ) * VAR11 = ' ' ; while ( VAR8 = FUN5 ( VAR8 ) ) { if ( ! strcmp ( VAR9 , VAR8 -> VAR14 ) ) return FUN6 ( VAR2 , VAR8 , VAR3 , VAR4 , VAR6 ) ; if ( VAR8 -> VAR4 & VAR15 && ! strcmp ( VAR10 , VAR8 -> VAR14 ) ) return FUN6 ( VAR2 , VAR8 , VAR3 , VAR4 , VAR6 ) ; } * VAR2 = NULL ; return VAR16 ; } "#1
33#33#int FUN1 ( int argc , char * * argv ) { VAR1 * VAR2 = NULL ; VAR3 * VAR4 = NULL ; VAR5 * VAR6 = NULL ; VAR7 * VAR8 = NULL ; VAR9 * VAR10 = NULL ; char * VAR11 = NULL , * VAR12 = NULL ; char * VAR13 = NULL , * VAR14 = NULL , * VAR15 = NULL , * VAR16 = NULL ; char * VAR17 = NULL , * VAR18 ; const char * VAR19 = ; int VAR21 , VAR22 = 1 , VAR23 = 0 , VAR24 = 0 , VAR25 = 0 ; int VAR26 = VAR27 ; OPTION_CHOICE VAR28 ; VAR18 = FUN2 ( argc , argv , VAR29 ) ; while ( ( VAR28 = FUN3 ( ) ) != VAR30 ) { switch ( VAR28 ) { case VAR30 : case VAR31 : VAR32 : FUN4 ( VAR33 , ) ; goto VAR34 ; } if ( VAR12 != NULL ) { VAR8 = FUN11 ( strcmp ( VAR12 , ) ; if ( VAR8 == NULL ) goto VAR34 ; VAR10 = FUN12 ( ) ; if ( VAR10 == NULL ) goto VAR34 ; if ( VAR11 != NULL ) FUN13 ( VAR10 -> VAR19 -> VAR11 , VAR11 , ( int ) strlen ( VAR11 ) ) ; FUN14 ( VAR10 , VAR8 ) ; FUN15 ( VAR10 , VAR8 , FUN16 ( ) ) ; VAR17 = FUN17 ( VAR10 ) ; if ( VAR17 == NULL ) goto VAR34 ; VAR2 = FUN18 ( VAR14 , ' ' , VAR49 ) ; if ( VAR2 == NULL ) { FUN19 ( VAR17 ) ; goto VAR34 ; } FUN4 ( VAR2 , % VAR50 ) ; FUN22 ( VAR33 ) ; goto VAR34 ; } VAR2 = FUN18 ( VAR14 , ' ' , VAR49 ) ; if ( VAR2 == NULL ) goto VAR34 ; if ( ! VAR24 ) FUN24 ( VAR2 , VAR10 ) ; VAR8 = FUN25 ( VAR10 ) ; if ( VAR23 ) { VAR21 = FUN26 ( VAR10 , VAR8 ) ; if ( VAR21 > 0 ) { FUN4 ( VAR33 , ) ; FUN22 ( VAR33 ) ; goto VAR34 ; } } if ( VAR25 ) FUN27 ( VAR2 , VAR8 ) ; VAR22 = 0 ; VAR34 : FUN28 ( VAR4 ) ; FUN29 ( VAR10 ) ; FUN30 ( VAR2 ) ; FUN31 ( VAR8 ) ; FUN32 ( VAR6 ) ; FUN19 ( VAR16 ) ; return ( VAR22 ) ; } #0
34#34#"void * FUN1 ( size_t VAR1 ) { void * VAR2 = NULL ; #if CONFIG_MEMALIGN_HACK long VAR3 ; #endif if (VAR1 > (VAR4 - 32)) return NULL;  #if CONFIG_MEMALIGN_HACK VAR2 = malloc(VAR1 + VAR5); if (!VAR2) return VAR2; VAR3              = ((~(long)VAR2)&(VAR5 - 1)) + 1; VAR2               = (char *)VAR2 + VAR3; ((char *)VAR2)[-1] = VAR3; #elif HAVE_POSIX_MEMALIGN if (VAR1)  if (FUN2(&VAR2, VAR5, VAR1)) VAR2 = NULL; #elif HAVE_ALIGNED_MALLOC VAR2 = FUN3(VAR1, VAR5); #elif VAR6 #ifndef __DJGPP__ VAR2 = memalign(VAR5, VAR1); #else VAR2 = memalign(VAR1, VAR5); #endif    #else VAR2 = malloc(VAR1); #endif if(!VAR2 && !VAR1) { VAR1 = 1; VAR2= FUN1(1); } #if CONFIG_MEMORY_POISONING if (VAR2) memset(VAR2, VAR7, VAR1); #endif return VAR2; } "#1
35#35#static int FUN1 ( int VAR1 , VAR2 * * VAR3 , const VAR4 * VAR5 ) { VAR6 * VAR7 = ( VAR6 * ) * VAR3 ; if ( ! VAR7 || ! VAR7 -> VAR8 ) return 1 ; switch ( VAR1 ) { case VAR9 : FUN2 ( VAR7 -> VAR8 , VAR10 ) ; break ; } return 1 ; } #0
36#36#static int FUN1 ( VAR1 * VAR2 , int VAR3 , VAR1 * VAR4 , int VAR5 , int VAR6 ) { int VAR7 = 1 ; int VAR8 = 0 ; int VAR9 = 0 ; int VAR10 ; int VAR11 ; for ( VAR10 = 0 ; VAR10 < VAR3 ; VAR10 += VAR11 ) { if ( VAR7 && VAR8 < VAR5 ) { VAR11 = FUN2 ( VAR2 + VAR10 , VAR4 + VAR8 , VAR6 , 1 ) ; VAR7 = ! VAR11 ; VAR8 ++ ; } else if ( VAR9 < VAR5 ) { VAR11 = FUN2 ( VAR2 + VAR10 , VAR4 + VAR9 , VAR12 - VAR6 , 0 ) ; VAR7 = VAR11 ; VAR9 ++ ; } else { break ; } } return VAR10 ; } #1
37#37#"int FUN1 ( int * VAR1 , int VAR2 , int VAR3 , const char * VAR4 , int VAR5 ) { int VAR6 = 0 ; if ( VAR7 != NULL ) { #ifdef LOCK_DEBUG int VAR8 = * VAR1 ; #endif VAR6 = FUN2 ( VAR1 , VAR2 , VAR3 , VAR4 , VAR5 ) ; #ifdef VAR9 { CRYPTO_THREADID VAR10 ; FUN3 ( & VAR10 ) ; fprintf ( VAR11 , , FUN4 ( & VAR10 ) , * VAR1 , VAR2 , VAR6 , FUN5 ( VAR3 ) , VAR4 , VAR5 ) ; } #endif * VAR1 = VAR6 ; FUN6 ( VAR14 | VAR13 , VAR3 , VAR4 , VAR5 ) ; } return ( VAR6 ) ; } "#1
38#38#"static int FUN1 ( VAR1 * VAR2 , char * * VAR3 ) { VAR4 * VAR5 = NULL ; int VAR6 = 1 ; while ( VAR5 = FUN2 ( VAR2 , , VAR5 , VAR7 ) ) FUN6 ( * VAR3 , VAR6 , "" "" , VAR5 -> VAR8 , VAR5 -> VAR9 ) ; return 0 ; } "#1
39#39#int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 ) { int VAR5 , VAR6 , VAR7 ; BN_ULONG VAR8 , VAR9 , VAR10 , * VAR11 ; const VAR12 * VAR13 , * VAR14 ; FUN2 ( VAR3 ) ; FUN2 ( VAR4 ) ; VAR5 = VAR3 -> VAR15 ; VAR6 = VAR4 -> VAR15 ; VAR7 = VAR5 - VAR6 ; if ( VAR7 < 0 ) { FUN3 ( VAR16 , VAR17 ) ; return 0 ; } if ( FUN4 ( VAR2 , VAR5 ) == NULL ) return 0 ; VAR13 = VAR3 -> VAR18 ; VAR14 = VAR4 -> VAR18 ; VAR11 = VAR2 -> VAR18 ; VAR10 = FUN5 ( VAR11 , VAR13 , VAR14 , VAR6 ) ; VAR13 += VAR6 ; VAR11 += VAR6 ; while ( VAR7 ) { VAR7 -- ; VAR8 = * ( VAR13 ++ ) ; VAR9 = ( VAR8 - VAR10 ) & VAR19 ; * ( VAR11 ++ ) = VAR9 ; VAR10 &= ( VAR8 == 0 ) ; } VAR2 -> VAR15 = VAR5 ; VAR2 -> VAR20 = 0 ; FUN6 ( VAR2 ) ; return 1 ; } #0
40#40#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = NULL ; unsigned VAR8 ; int VAR9 ; FUN2 ( VAR10 ) if ( VAR4 -> VAR11 ) { for ( VAR8 = 0 ; VAR8 < FUN3 ( VAR4 -> VAR10 ) ; VAR8 ++ ) if ( ( VAR9 = FUN4 ( & VAR7 , VAR4 -> VAR10 [ VAR8 ] ) ) < 0 ) { FUN5 ( & VAR7 ) ; return VAR9 ; } FUN6 ( VAR2 , VAR7 ) ; } else { FUN7 ( VAR2 ) ; } return 0 ; } #0
41#41#int FUN1 ( VAR1 * VAR2 , unsigned char * * VAR3 , VAR4 * VAR5 , int VAR6 , int VAR7 , int VAR8 ) { int VAR9 = 0 , VAR10 ; int VAR11 ; unsigned char * VAR12 ; unsigned char * VAR13 , * VAR14 ; VAR15 * VAR16 ; int VAR17 ; if ( VAR2 == NULL ) return ( 0 ) ; for ( VAR11 = FUN2 ( VAR2 ) - 1 ; VAR11 >= 0 ; VAR11 -- ) VAR9 += FUN3 ( FUN4 ( VAR2 , VAR11 ) , NULL ) ; VAR10 = FUN5 ( 1 , VAR9 , VAR6 ) ; if ( VAR3 == NULL ) return ( VAR10 ) ; VAR12 = * VAR3 ; FUN6 ( & VAR12 , 1 , VAR9 , VAR6 , VAR7 ) ; if ( ! VAR8 || ( FUN2 ( VAR2 ) < 2 ) ) { for ( VAR11 = 0 ; VAR11 < FUN2 ( VAR2 ) ; VAR11 ++ ) FUN3 ( FUN4 ( VAR2 , VAR11 ) , & VAR12 ) ; * VAR3 = VAR12 ; return ( VAR10 ) ; } VAR13 = VAR12 ; VAR16 = ( VAR15 * ) FUN7 ( FUN2 ( VAR2 ) * sizeof ( VAR15 ) ) ; if ( VAR16 == NULL ) { FUN8 ( VAR18 , VAR19 ) ; return ( 0 ) ; } for ( VAR11 = 0 ; VAR11 < FUN2 ( VAR2 ) ; VAR11 ++ ) { VAR16 [ VAR11 ] . VAR20 = VAR12 ; FUN3 ( FUN4 ( VAR2 , VAR11 ) , & VAR12 ) ; VAR16 [ VAR11 ] . VAR21 = VAR12 - VAR16 [ VAR11 ] . VAR20 ; } * VAR3 = VAR12 ; VAR17 = VAR12 - VAR13 ; FUN9 ( VAR16 , FUN2 ( VAR2 ) , sizeof ( VAR15 ) , VAR22 ) ; if ( ! ( VAR14 = FUN7 ( VAR17 ) ) ) { FUN8 ( VAR18 , VAR19 ) ; return ( 0 ) ; } VAR12 = VAR14 ; for ( VAR11 = 0 ; VAR11 < FUN2 ( VAR2 ) ; ++ VAR11 ) { memcpy ( VAR12 , VAR16 [ VAR11 ] . VAR20 , VAR16 [ VAR11 ] . VAR21 ) ; VAR12 += VAR16 [ VAR11 ] . VAR21 ; } memcpy ( VAR13 , VAR14 , VAR17 ) ; FUN10 ( VAR14 ) ; FUN10 ( VAR16 ) ; return ( VAR10 ) ; } #1
42#42#static void FUN1 ( VAR1 * VAR2 ) { int VAR3 ; VAR4 * VAR5 = VAR2 -> VAR5 ; const VAR6 * VAR7 = FUN2 ( VAR5 -> VAR8 ) ; const int VAR9 = VAR7 -> VAR10 [ 0 ] . VAR9 ; if ( VAR9 == 8 && VAR5 -> VAR11 == VAR12 ) { VAR3 = 1 ; VAR2 -> VAR13 = 1 ; VAR2 -> VAR14 = 128 ; } else if ( VAR9 == 8 && ( VAR5 -> VAR11 == VAR15 || VAR5 -> VAR11 == VAR16 ) ) { VAR3 = 2 ; VAR2 -> VAR13 = 1 ; VAR2 -> VAR14 = 128 ; } else if ( VAR9 == 10 ) { VAR3 = 3 ; VAR2 -> VAR13 = 2 ; VAR2 -> VAR14 = 512 ; } else { VAR3 = 4 ; VAR2 -> VAR13 = 2 ; VAR2 -> VAR14 = 2048 ; } FUN3 ( & VAR2 -> VAR17 , 1 , ! VAR2 -> VAR18 ) ; if ( ! VAR2 -> VAR18 ) FUN4 ( & VAR2 -> VAR17 , VAR3 ) ; } #1
43#43#"int FUN1 ( VAR1 * VAR2 ) { if ( VAR2 == NULL ) return 1 ; if ( VAR2 -> VAR3 && VAR2 -> VAR3 -> VAR4 && ! FUN2 ( VAR2 , VAR5 ) ) VAR2 -> VAR3 -> FUN3 ( VAR2 ) ; if ( VAR2 -> VAR3 && VAR2 -> VAR3 -> VAR6 && VAR2 -> VAR7 && ! FUN2 ( VAR2 , VAR8 ) ) { FUN4 ( VAR2 -> VAR7 , VAR2 -> VAR3 -> VAR6 ) ; } FUN5 ( VAR2 -> VAR9 ) ; #ifndef VAR10 FUN6 ( VAR2 -> VAR11 ) ; #endif memset ( VAR2 , 0 , sizeof ( * VAR2 ) ) ; return 1 ; } "#0
44#44#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; struct sockaddr_storage VAR9 ; socklen_t VAR10 ; int VAR11 , VAR12 ; struct pollfd VAR13 [ 2 ] = { { VAR7 -> VAR14 , VAR15 , 0 } , { VAR7 -> VAR16 , VAR15 , 0 } } ; #if 0 for ( ; ; ) { VAR10 = sizeof ( VAR9 ) ; VAR11 = recvfrom ( VAR7 - > VAR14 , VAR4 , VAR5 , 0 , ( struct VAR17 * ) & VAR9 , & VAR10 ) ; if ( VAR11 < 0 ) { if ( FUN2 ( ) == FUN3 ( VAR18 ) || FUN2 ( ) == FUN3 ( VAR19 ) ) continue ; return FUN4 ( VAR20 ) ; } break ; } #else for(;;) { if (FUN5()) return FUN4(VAR19);  VAR12 = FUN6(VAR13, 2, 100); if (VAR12 > 0) {  if (VAR13[1].VAR21 & VAR15) { VAR10 = sizeof(VAR9); VAR11 = recvfrom (VAR7->VAR16, VAR4, VAR5, 0, (struct VAR17 *)&VAR9, &VAR10); if (VAR11 < 0) { if (FUN2() == FUN3(VAR18) || FUN2() == FUN3(VAR19)) continue; return FUN4(VAR20); } break; }  if (VAR13[0].VAR21 & VAR15) { VAR10 = sizeof(VAR9); VAR11 = recvfrom (VAR7->VAR14, VAR4, VAR5, 0, (struct VAR17 *)&VAR9, &VAR10); if (VAR11 < 0) { if (FUN2() == FUN3(VAR18) || FUN2() == FUN3(VAR19)) continue; return FUN4(VAR20); } break; } } else if (VAR12 < 0) { if (FUN2() == FUN3(VAR19)) continue; return FUN4(VAR20); } } #endif return VAR11; } "#0
45#45#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { int VAR5 , VAR6 ; int VAR7 , VAR8 ; int VAR9 [ VAR4 ] ; VAR10 * VAR11 = VAR2 -> VAR11 [ VAR3 ] ; for ( VAR5 = 0 ; VAR5 < VAR4 ; VAR5 ++ ) { VAR11 [ VAR5 ] = FUN2 ( & VAR2 -> VAR12 , VAR2 -> VAR13 ) ; } VAR7 = FUN3 ( & VAR2 -> VAR12 , 4 ) + 1 ; if ( VAR7 == 16 ) { FUN4 ( VAR2 -> VAR14 , VAR15 , , VAR8 ) ; return -1 ; } for ( VAR5 = 0 ; VAR5 < VAR4 ; VAR5 ++ ) { VAR9 [ VAR5 ] = FUN5 ( & VAR2 -> VAR12 , VAR7 ) ; } if ( FUN6 ( VAR2 , VAR3 , VAR4 ) < 0 ) return -1 ; if ( VAR2 -> VAR16 > 16 ) { int64_t VAR17 ; for ( VAR5 = VAR4 ; VAR5 < VAR2 -> VAR18 ; VAR5 ++ ) { VAR17 = 0 ; for ( VAR6 = 0 ; VAR6 < VAR4 ; VAR6 ++ ) VAR17 += ( VAR19 ) VAR9 [ VAR6 ] * VAR11 [ VAR5 - VAR6 - 1 ] ; VAR11 [ VAR5 ] += VAR17 >> VAR8 ; } } else { for ( VAR5 = VAR4 ; VAR5 < VAR2 -> VAR18 - 1 ; VAR5 += 2 ) { int VAR20 ; int VAR21 = VAR11 [ VAR5 - VAR4 ] ; int VAR22 = 0 , VAR23 = 0 ; for ( VAR6 = VAR4 - 1 ; VAR6 > 0 ; VAR6 -- ) { VAR20 = VAR9 [ VAR6 ] ; VAR22 += VAR20 * VAR21 ; VAR21 = VAR11 [ VAR5 - VAR6 ] ; VAR23 += VAR20 * VAR21 ; } VAR20 = VAR9 [ 0 ] ; VAR22 += VAR20 * VAR21 ; VAR21 = VAR11 [ VAR5 ] += VAR22 >> VAR8 ; VAR23 += VAR20 * VAR21 ; VAR11 [ VAR5 + 1 ] += VAR23 >> VAR8 ; } if ( VAR5 < VAR2 -> VAR18 ) { int VAR17 = 0 ; for ( VAR6 = 0 ; VAR6 < VAR4 ; VAR6 ++ ) VAR17 += VAR9 [ VAR6 ] * VAR11 [ VAR5 - VAR6 - 1 ] ; VAR11 [ VAR5 ] += VAR17 >> VAR8 ; } } return 0 ; } #1
46#46#"VAR1 * FUN1 ( VAR2 * VAR3 ) { VAR4 * VAR5 ; int VAR6 ; VAR5 = VAR3 -> VAR7 ; if ( ! VAR3 -> VAR8 || ! VAR3 -> VAR8 -> VAR9 . VAR10 ) return NULL ; FUN2 ( VAR3 , VAR3 -> VAR8 -> VAR9 . VAR10 ) ; #ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL if ( VAR5 -> VAR11 & VAR12 ) return VAR5 -> VAR13 ; #endif VAR6 = FUN3 ( VAR3 ) ; if ( VAR6 < 0 ) return NULL ; return & VAR5 -> VAR14 [ VAR6 ] ; } "#1
47#47#static VAR1 * FUN1 ( unsigned long VAR2 , int VAR3 ) { VAR1 * VAR4 = NULL ; unsigned char * VAR5 = NULL ; unsigned char * VAR6 = NULL ; VAR4 = ( VAR1 * ) FUN2 ( sizeof ( VAR1 ) ) ; if ( VAR4 == NULL ) return NULL ; if ( VAR2 ) { VAR5 = ( unsigned char * ) FUN2 ( VAR2 ) ; if ( VAR5 == NULL ) { FUN3 ( VAR4 ) ; return NULL ; } } VAR4 -> VAR7 = VAR5 ; if ( VAR3 ) { VAR6 = ( unsigned char * ) FUN2 ( FUN4 ( VAR2 ) ) ; if ( VAR6 == NULL ) { if ( VAR5 != NULL ) FUN3 ( VAR5 ) ; FUN3 ( VAR4 ) ; return NULL ; } memset ( VAR6 , 0 , FUN4 ( VAR2 ) ) ; } VAR4 -> VAR3 = VAR6 ; return VAR4 ; } #1
48#48#"void * FUN1 ( void * VAR1 , size_t VAR2 ) { #if CONFIG_MEMALIGN_HACK int VAR3 ; #endif if(VAR2 > (VAR4-16) ) return NULL;  #if VAR5  if(!VAR1) return FUN2(VAR2); VAR3= ((char*)VAR1)[-1]; return (char*)realloc((char*)VAR1 - VAR3, VAR2 + VAR3) + VAR3; #else return realloc(VAR1, VAR2); #endif } "#1
49#49#int FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 , VAR6 * VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR9 ; VAR10 * VAR11 ; X509_OBJECT VAR12 , * VAR13 ; int VAR14 , VAR15 ; VAR13 = FUN2 ( VAR9 -> VAR16 , VAR3 , VAR5 ) ; if ( VAR13 == NULL ) { for ( VAR14 = VAR2 -> VAR17 ; VAR14 < FUN3 ( VAR9 -> VAR18 ) ; VAR14 ++ ) { VAR11 = FUN4 ( VAR9 -> VAR18 , VAR14 ) ; VAR15 = FUN5 ( VAR11 , VAR3 , VAR5 , & VAR12 ) ; if ( VAR15 < 0 ) { VAR2 -> VAR17 = VAR15 ; return ( VAR15 ) ; } else if ( VAR15 ) { VAR13 = & VAR12 ; break ; } } VAR2 -> VAR17 = 0 ; if ( VAR13 == NULL ) return ( 0 ) ; } VAR7 -> VAR3 = VAR13 -> VAR3 ; VAR7 -> VAR19 . VAR20 = VAR13 -> VAR19 . VAR20 ; FUN6 ( VAR7 ) ; return ( 1 ) ; } #0
50#50#static int FUN1 ( VAR1 ) ( VAR2 * VAR3 , VAR4 * VAR5 , const VAR4 * VAR6 , int VAR7 , int VAR8 ) { int VAR9 ; int VAR10 = VAR3 -> VAR10 ; int VAR11 = VAR3 -> VAR11 ; int VAR12 = VAR10 >> VAR3 -> VAR13 ; VAR10 &= VAR3 -> VAR14 ; for ( VAR9 = 0 ; VAR9 < VAR7 ; VAR9 ++ ) { VAR15 * VAR16 = ( ( VAR15 * ) VAR3 -> VAR17 ) + VAR3 -> VAR18 * VAR10 ; FELEM2 VAR19 = 0 ; int VAR20 ; for ( VAR20 = 0 ; VAR20 < VAR3 -> VAR21 ; VAR20 ++ ) { VAR19 += VAR6 [ VAR12 + VAR20 ] * ( VAR22 ) VAR16 [ VAR20 ] ; } FUN2 ( VAR5 [ VAR9 ] , VAR19 ) ; VAR11 += VAR3 -> VAR23 ; VAR10 += VAR3 -> VAR24 ; if ( VAR11 >= VAR3 -> VAR25 ) { VAR11 -= VAR3 -> VAR25 ; VAR10 ++ ; } VAR12 += VAR10 >> VAR3 -> VAR13 ; VAR10 &= VAR3 -> VAR14 ; } if ( VAR8 ) { VAR3 -> VAR11 = VAR11 ; VAR3 -> VAR10 = VAR10 ; } return VAR12 ; } #1
51#51#static void FUN1 ( int VAR1 [ 256 + 2 * VAR2 ] , const int VAR3 , const int VAR4 ) { int VAR5 ; int VAR6 = - ( VAR4 >> 9 ) ; for ( VAR5 = 0 ; VAR5 < 256 + 2 * VAR2 ; VAR5 ++ ) { int64_t VAR7 = FUN2 ( VAR5 - VAR2 , 0 , 255 ) * VAR4 ; VAR1 [ VAR5 ] = VAR3 * ( VAR6 + ( VAR7 >> 16 ) ) ; } } #1
52#52#static void FUN1 ( VAR1 * VAR2 ) { unsigned int VAR3 , VAR4 ; int64_t VAR5 = VAR2 -> VAR6 + ( ( VAR2 -> VAR7 == VAR8 ) ? 0 : VAR2 -> VAR7 ) ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR9 ; VAR3 ++ ) if ( VAR2 -> VAR10 [ VAR3 ] -> VAR11 == VAR8 ) { VAR12 * VAR13 = VAR2 -> VAR10 [ VAR3 ] ; int64_t VAR11 = VAR5 ? FUN2 ( VAR5 , VAR14 , VAR13 -> VAR15 ) : VAR16 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR9 ; VAR4 ++ ) { VAR12 * VAR17 = VAR2 -> VAR10 [ VAR4 ] ; int64_t VAR18 = FUN2 ( VAR17 -> VAR19 , VAR17 -> VAR15 , VAR13 -> VAR15 ) ; if ( VAR4 != VAR3 && VAR18 > VAR13 -> VAR19 && VAR18 < VAR11 ) VAR11 = VAR18 ; } VAR13 -> VAR11 = ( VAR11 == VAR16 ) ? VAR13 -> VAR19 : VAR11 ; } } #1
53#53#"static void FUN1 ( VAR1 * VAR2 ) { int VAR3 = VAR2 -> VAR4 ? VAR2 -> VAR4 : VAR5 ; VAR6 * VAR7 = VAR2 -> VAR8 - VAR2 -> VAR9 + VAR3 < VAR2 -> VAR10 ? VAR2 -> VAR8 : VAR2 -> VAR9 ; int VAR11 = VAR2 -> VAR10 - ( VAR7 - VAR2 -> VAR9 ) ; if ( ! VAR2 -> VAR12 && VAR2 -> VAR13 >= VAR2 -> VAR8 ) VAR2 -> VAR14 = 1 ; if ( VAR2 -> VAR14 ) return ; if ( VAR2 -> VAR15 && VAR7 == VAR2 -> VAR9 ) { if ( VAR2 -> VAR8 > VAR2 -> VAR16 ) VAR2 -> VAR17 = VAR2 -> FUN2 ( VAR2 -> VAR17 , VAR2 -> VAR16 , VAR2 -> VAR8 - VAR2 -> VAR16 ) ; VAR2 -> VAR16 = VAR2 -> VAR9 ; } if ( VAR2 -> VAR12 && VAR2 -> VAR18 && VAR2 -> VAR10 > VAR2 -> VAR18 ) { if ( VAR7 == VAR2 -> VAR9 && VAR2 -> VAR13 != VAR7 ) { int VAR19 = FUN3 ( VAR2 , VAR2 -> VAR18 ) ; if ( VAR19 < 0 ) FUN4 ( VAR2 , VAR20 , "" "" ) ; VAR2 -> VAR16 = VAR7 = VAR2 -> VAR9 ; } FUN5 ( VAR11 >= VAR2 -> VAR18 ) ; VAR11 = VAR2 -> VAR18 ; } VAR11 = FUN6 ( VAR2 , VAR7 , VAR11 ) ; if ( VAR11 == VAR21 ) { VAR2 -> VAR14 = 1 ; } else if ( VAR11 < 0 ) { VAR2 -> VAR14 = 1 ; VAR2 -> VAR22 = VAR11 ; } else { VAR2 -> VAR23 += VAR11 ; VAR2 -> VAR13 = VAR7 ; VAR2 -> VAR8 = VAR7 + VAR11 ; VAR2 -> VAR24 += VAR11 ; } } "#0
54#54#VAR1 FUN1 ( int64_t VAR2 , AVRational VAR3 , AVRational VAR4 , enum AVRounding VAR5 ) { int64_t VAR6 = VAR3 . VAR7 * ( VAR1 ) VAR4 . VAR8 ; int64_t VAR9 = VAR4 . VAR7 * ( VAR1 ) VAR3 . VAR8 ; return FUN2 ( VAR2 , VAR6 , VAR9 , VAR5 ) ; } #1
55#55#VAR1 * FUN1 ( int VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 , double VAR7 ) { VAR1 * VAR8 = FUN2 ( sizeof ( VAR1 ) ) ; double VAR9 = FUN3 ( VAR2 * VAR7 / VAR3 , 1.0 ) ; int VAR10 = 1 << VAR5 ; if ( ! VAR8 ) return NULL ; VAR8 -> VAR5 = VAR5 ; VAR8 -> VAR11 = VAR10 - 1 ; VAR8 -> VAR6 = VAR6 ; VAR8 -> VAR12 = FUN4 ( ( int ) FUN5 ( VAR4 / VAR9 ) , 1 ) ; VAR8 -> VAR13 = FUN2 ( VAR8 -> VAR12 * ( VAR10 + 1 ) * sizeof ( VAR14 ) ) ; if ( ! VAR8 -> VAR13 ) goto VAR15 ; if ( FUN6 ( VAR8 -> VAR13 , VAR9 , VAR8 -> VAR12 , VAR10 , 1 << VAR16 , VAR17 ) ) goto VAR15 ; memcpy ( & VAR8 -> VAR13 [ VAR8 -> VAR12 * VAR10 + 1 ] , VAR8 -> VAR13 , ( VAR8 -> VAR12 - 1 ) * sizeof ( VAR14 ) ) ; VAR8 -> VAR13 [ VAR8 -> VAR12 * VAR10 ] = VAR8 -> VAR13 [ VAR8 -> VAR12 - 1 ] ; if ( ! FUN7 ( & VAR8 -> VAR18 , & VAR8 -> VAR19 , VAR2 , VAR3 * ( VAR20 ) VAR10 , VAR21 / 2 ) ) goto VAR15 ; VAR8 -> VAR22 = VAR8 -> VAR19 ; VAR8 -> VAR23 = - VAR10 * ( ( VAR8 -> VAR12 - 1 ) / 2 ) ; return VAR8 ; VAR15 : FUN8 ( VAR8 -> VAR13 ) ; FUN8 ( VAR8 ) ; return NULL ; } #0
56#56#int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , VAR4 * VAR5 , const unsigned char * VAR6 , size_t VAR7 ) { VAR8 * VAR9 = NULL ; const unsigned char * VAR10 = VAR6 ; unsigned char VAR11 [ 32 ] ; unsigned char VAR12 [ 4 ] , VAR13 [ 4 ] ; unsigned char VAR14 [ 8 ] ; int VAR15 ; const struct VAR16 * VAR17 ; gost_ctx VAR18 ; VAR19 * VAR20 = FUN2 ( ) ; VAR21 * VAR22 ; VAR21 * VAR23 = FUN3 ( VAR2 ) ; if ( ! VAR3 ) { * VAR5 = 32 ; return 1 ; } VAR20 -> VAR24 = FUN4 ( VAR23 -> VAR25 . VAR26 -> VAR24 ) ; VAR20 -> VAR10 = FUN4 ( VAR23 -> VAR25 . VAR26 -> VAR10 ) ; VAR20 -> VAR27 = FUN4 ( VAR23 -> VAR25 . VAR26 -> VAR27 ) ; VAR9 = FUN5 ( NULL , ( const unsigned char * * ) & VAR10 , VAR7 ) ; if ( ! VAR9 ) { FUN6 ( VAR28 , VAR29 ) ; FUN7 ( VAR20 ) ; return 0 ; } VAR22 = FUN8 ( VAR9 -> VAR30 -> VAR31 ) ; FUN9 ( VAR9 -> VAR30 -> VAR32 -> VAR33 == 8 ) ; memcpy ( VAR14 , VAR9 -> VAR30 -> VAR32 -> VAR34 , 8 ) ; FUN9 ( VAR9 -> VAR35 -> VAR36 -> VAR33 == 4 ) ; memcpy ( VAR12 , VAR9 -> VAR35 -> VAR36 -> VAR34 , 4 ) ; VAR15 = FUN10 ( VAR20 , VAR22 , VAR11 ) ; FUN11 ( VAR22 ) ; FUN7 ( VAR20 ) ; if ( ! VAR15 ) { FUN6 ( VAR28 , VAR37 ) ; FUN12 ( VAR9 ) ; return 0 ; } VAR17 = FUN13 ( VAR9 -> VAR30 -> VAR38 ) ; FUN14 ( & VAR18 , VAR17 -> VAR39 ) ; FUN15 ( & VAR18 , VAR11 ) ; if ( ! FUN16 ( VAR3 , * VAR5 , VAR9 -> VAR35 -> VAR40 -> VAR34 , VAR9 -> VAR35 -> VAR40 -> VAR33 , & VAR18 ) ) { FUN12 ( VAR9 ) ; return 0 ; } FUN12 ( VAR9 ) ; if ( ! FUN17 ( & VAR18 , 32 , VAR3 , 32 , VAR13 ) ) { FUN6 ( VAR28 , VAR41 ) ; return 0 ; } if ( memcmp ( VAR12 , VAR13 , 4 ) != 0 ) { FUN6 ( VAR28 , VAR42 ) ; return 0 ; } return 1 ; } #1
57#57#"static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , int VAR5 , int VAR6 ) { const char * VAR7 = VAR6 ? "" "" : VAR8 ; int64_t VAR9 ; VAR10 * VAR11 , * VAR12 ; FUN2 ( VAR4 , VAR13 , NULL ) ; VAR9 = FUN3 ( * VAR4 , VAR7 ) ; if ( VAR9 >= ( ( 1 << 24 ) - 4 ) ) return FUN4 ( VAR14 ) ; VAR12 = FUN5 ( VAR9 + 4 ) ; if ( ! VAR12 ) return FUN4 ( VAR15 ) ; VAR11 = VAR12 ; FUN6 ( & VAR11 , VAR5 ? 0x84 : 0x04 ) ; FUN7 ( & VAR11 , VAR9 ) ; FUN8 ( & VAR11 , VAR4 , VAR7 ) ; FUN9 ( VAR2 , VAR12 , VAR9 + 4 ) ; FUN10 ( & VAR12 ) ; VAR11 = NULL ; return 0 ; } "#0
58#58#static void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 ) { size_t VAR5 ; const VAR6 * VAR7 = ( const VAR6 * ) ( VAR4 ) ; FUN2 ( VAR2 ) ; FUN3 ( sizeof ( VAR3 ) == 64 ) ; for ( VAR5 = 0 ; VAR5 < 8 ; ++ VAR5 ) { VAR2 -> VAR8 [ VAR5 ] ^= FUN4 ( VAR7 + sizeof ( VAR2 -> VAR8 [ VAR5 ] ) * VAR5 ) ; } } #0
59#59#static int FUN1 ( VAR1 * VAR2 ) { char VAR3 [ VAR4 + 10 ] ; char * VAR5 , * VAR6 , * VAR7 ; int VAR8 ; VAR9 * VAR10 = VAR2 -> VAR10 ; int VAR11 = -1 , VAR12 = -1 , VAR13 = 0 , VAR14 = 0 , VAR15 = 0 , VAR16 = 0 ; enum AVPixelFormat VAR17 = VAR18 , VAR19 = VAR18 ; enum AVChromaLocation VAR20 = VAR21 ; VAR22 * VAR23 ; enum AVFieldOrder VAR24 ; for ( VAR8 = 0 ; VAR8 < VAR4 ; VAR8 ++ ) { VAR3 [ VAR8 ] = FUN2 ( VAR10 ) ; if ( VAR3 [ VAR8 ] == ' ' ) { VAR3 [ VAR8 + 1 ] = 0x20 ; VAR3 [ VAR8 + 2 ] = 0 ; break ; } } if ( VAR8 == VAR4 ) return -1 ; if ( FUN3 ( VAR3 , VAR25 , strlen ( VAR25 ) ) ) return -1 ; VAR7 = & VAR3 [ VAR8 + 1 ] ; for ( VAR5 = & VAR3 [ strlen ( VAR25 ) + 1 ] ; VAR5 < VAR7 ; VAR5 ++ ) { if ( * VAR5 == 0x20 ) continue ; switch ( * VAR5 ++ ) { case ' ' VAR11 = FUN4 ( VAR5 , & VAR6 , 10 ) ; VAR5 = VAR6 ; break ; case ' ' VAR12 = FUN4 ( VAR5 , & VAR6 , 10 ) ; VAR5 = VAR6 ; break ; case ' ' if ( FUN3 ( , VAR5 , 8 ) == 0 ) { VAR17 = VAR26 ; VAR20 = VAR28 ; } else if ( FUN3 ( , VAR5 , 3 ) == 0 ) { VAR17 = VAR26 ; VAR20 = VAR27 ; } else if ( FUN3 ( , VAR5 , 3 ) == 0 ) VAR17 = VAR31 ; else if ( FUN3 ( , VAR5 , 3 ) == 0 ) VAR17 = VAR33 ; else if ( FUN3 ( ) ; return -1 ; } break ; case ' ' sscanf ( VAR5 , , & VAR15 , & VAR16 ) ; while ( VAR5 < VAR7 && * VAR5 != 0x20 ) VAR5 ++ ; break ; case ' ' if ( FUN3 ( , VAR5 , 7 ) == 0 ) VAR19 = VAR26 ; else if ( FUN3 ( , VAR5 , 8 ) == 0 ) VAR19 = VAR26 ; else if ( FUN3 ( , VAR5 , 3 ) == 0 ) VAR19 = VAR31 ; else if ( FUN3 ( ) ; return -1 ; } if ( VAR17 == VAR18 ) { if ( VAR19 == VAR18 ) VAR17 = VAR26 ; else VAR17 = VAR19 ; } if ( VAR13 <= 0 || VAR14 <= 0 ) { VAR13 = 25 ; VAR14 = 1 ; } if ( VAR15 == 0 && VAR16 == 0 ) { VAR16 = 1 ; } VAR23 = FUN6 ( VAR2 , NULL ) ; if ( ! VAR23 ) return FUN7 ( VAR39 ) ; VAR23 -> VAR40 -> VAR11 = VAR11 ; VAR23 -> VAR40 -> VAR12 = VAR12 ; FUN8 ( & VAR13 , & VAR14 , VAR13 , VAR14 , ( 1UL << 31 ) - 1 ) ; FUN9 ( VAR23 , 64 , VAR14 , VAR13 ) ; VAR23 -> VAR41 = FUN10 ( VAR23 -> VAR42 ) ; VAR23 -> VAR40 -> VAR17 = VAR17 ; VAR23 -> VAR40 -> VAR43 = VAR44 ; VAR23 -> VAR40 -> VAR45 = VAR46 ; VAR23 -> VAR47 = ( VAR48 ) { VAR15 , VAR16 } ; VAR23 -> VAR40 -> VAR20 = VAR20 ; VAR23 -> VAR40 -> VAR24 = VAR24 ; return 0 ; } #1
60#60#"static void FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 , VAR5 ; int VAR6 ; if ( VAR3 == VAR7 && VAR2 -> VAR8 ) { int VAR9 = VAR2 -> VAR10 [ 0 ] . VAR11 ? 2 : 1 ; int VAR12 = VAR2 -> VAR10 [ 0 ] . VAR11 ? 12 : 24 ; for ( VAR5 = 1 ; VAR5 <= VAR2 -> VAR10 [ 0 ] . VAR13 ; VAR5 ++ ) { for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR14 [ VAR2 -> VAR10 [ 0 ] . VAR15 [ VAR5 ] ] ; VAR4 ++ ) { SoftFloat VAR16 , VAR17 , VAR18 ; VAR16 . VAR19 = VAR2 -> VAR10 [ 0 ] . VAR20 [ VAR5 ] [ VAR4 ] . VAR21 * VAR9 + 14 ; if ( VAR16 . VAR19 & 1 ) VAR16 . VAR21 = 759250125 ; else VAR16 . VAR21 = 0x20000000 ; VAR16 . VAR19 = ( VAR16 . VAR19 >> 1 ) + 1 ; if ( VAR16 . VAR19 > 66 ) { FUN2 ( NULL , VAR22 , ) ; VAR16 = VAR23 ; } VAR17 . VAR19 = 12 - VAR2 -> VAR10 [ 1 ] . VAR27 [ VAR5 ] [ VAR4 ] + 1 ; VAR17 . VAR21 = 0x20000000 ; VAR18 = FUN3 ( VAR16 , FUN4 ( VAR23 , VAR17 ) ) ; VAR2 -> VAR10 [ 0 ] . VAR28 [ VAR5 ] [ VAR4 ] = VAR18 ; VAR2 -> VAR10 [ 1 ] . VAR28 [ VAR5 ] [ VAR4 ] = FUN5 ( VAR18 , VAR17 ) ; } } } else { for ( VAR6 = 0 ; VAR6 < ( VAR3 == VAR7 ) + 1 ; VAR6 ++ ) { int VAR9 = VAR2 -> VAR10 [ VAR6 ] . VAR11 ? 2 : 1 ; for ( VAR5 = 1 ; VAR5 <= VAR2 -> VAR10 [ VAR6 ] . VAR13 ; VAR5 ++ ) for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR14 [ VAR2 -> VAR10 [ VAR6 ] . VAR15 [ VAR5 ] ] ; VAR4 ++ ) { SoftFloat VAR16 ; VAR16 . VAR19 = VAR9 * VAR2 -> VAR10 [ VAR6 ] . VAR20 [ VAR5 ] [ VAR4 ] . VAR21 + 12 ; if ( VAR16 . VAR19 & 1 ) VAR16 . VAR21 = 759250125 ; else VAR16 . VAR21 = 0x20000000 ; VAR16 . VAR19 = ( VAR16 . VAR19 >> 1 ) + 1 ; if ( VAR16 . VAR19 > 66 ) { FUN2 ( NULL , VAR22 , "" "" ) ; VAR16 = VAR23 ; } VAR2 -> VAR10 [ VAR6 ] . VAR20 [ VAR5 ] [ VAR4 ] = VAR16 ; } for ( VAR5 = 1 ; VAR5 <= VAR2 -> VAR10 [ VAR6 ] . VAR24 ; VAR5 ++ ) for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR25 ; VAR4 ++ ) { VAR2 -> VAR10 [ VAR6 ] . VAR28 [ VAR5 ] [ VAR4 ] . VAR19 = VAR26 - VAR2 -> VAR10 [ VAR6 ] . VAR27 [ VAR5 ] [ VAR4 ] + 1 ; VAR2 -> VAR10 [ VAR6 ] . VAR28 [ VAR5 ] [ VAR4 ] . VAR21 = 0x20000000 ; } } } } "#0
61#61#static void FUN1 ( VAR1 * VAR2 , int VAR3 , const VAR1 * VAR4 , int VAR5 , int VAR6 , int VAR7 , VAR8 * VAR9 ) { VAR10 * * VAR11 = VAR9 -> VAR11 ; uint32_t VAR12 [ ( VAR13 * VAR13 ) - 1 ] , VAR14 , VAR15 ; int32_t VAR16 ; int VAR17 , VAR18 , VAR19 ; const VAR1 * VAR20 = NULL ; if ( ! VAR9 -> VAR21 ) { if ( VAR3 == VAR5 ) memcpy ( VAR2 , VAR4 , VAR5 * VAR7 ) ; else for ( VAR18 = 0 ; VAR18 < VAR7 ; VAR18 ++ , VAR2 += VAR3 , VAR4 += VAR5 ) memcpy ( VAR2 , VAR4 , VAR6 ) ; return ; } for ( VAR18 = 0 ; VAR18 < 2 * VAR9 -> VAR22 ; VAR18 ++ ) memset ( VAR11 [ VAR18 ] , 0 , sizeof ( VAR11 [ VAR18 ] [ 0 ] ) * ( VAR6 + 2 * VAR9 -> VAR23 ) ) ; for ( VAR18 = - VAR9 -> VAR22 ; VAR18 < VAR7 + VAR9 -> VAR22 ; VAR18 ++ ) { if ( VAR18 < VAR7 ) VAR20 = VAR4 ; memset ( VAR12 , 0 , sizeof ( VAR12 [ 0 ] ) * ( 2 * VAR9 -> VAR23 - 1 ) ) ; for ( VAR17 = - VAR9 -> VAR23 ; VAR17 < VAR6 + VAR9 -> VAR23 ; VAR17 ++ ) { VAR14 = VAR17 <= 0 ? VAR20 [ 0 ] : VAR17 >= VAR6 ? VAR20 [ VAR6 - 1 ] : VAR20 [ VAR17 ] ; for ( VAR19 = 0 ; VAR19 < VAR9 -> VAR23 * 2 ; VAR19 += 2 ) { VAR15 = VAR12 [ VAR19 + 0 ] + VAR14 ; VAR12 [ VAR19 + 0 ] = VAR14 ; VAR14 = VAR12 [ VAR19 + 1 ] + VAR15 ; VAR12 [ VAR19 + 1 ] = VAR15 ; } for ( VAR19 = 0 ; VAR19 < VAR9 -> VAR22 * 2 ; VAR19 += 2 ) { VAR15 = VAR11 [ VAR19 + 0 ] [ VAR17 + VAR9 -> VAR23 ] + VAR14 ; VAR11 [ VAR19 + 0 ] [ VAR17 + VAR9 -> VAR23 ] = VAR14 ; VAR14 = VAR11 [ VAR19 + 1 ] [ VAR17 + VAR9 -> VAR23 ] + VAR15 ; VAR11 [ VAR19 + 1 ] [ VAR17 + VAR9 -> VAR23 ] = VAR15 ; } if ( VAR17 >= VAR9 -> VAR23 && VAR18 >= VAR9 -> VAR22 ) { const VAR1 * VAR24 = VAR4 - VAR9 -> VAR22 * VAR5 + VAR17 - VAR9 -> VAR23 ; VAR1 * VAR25 = VAR2 - VAR9 -> VAR22 * VAR3 + VAR17 - VAR9 -> VAR23 ; VAR16 = ( VAR26 ) * VAR24 + ( ( ( ( VAR26 ) * VAR24 - ( VAR26 ) ( ( VAR14 + VAR9 -> VAR27 ) >> VAR9 -> VAR28 ) ) * VAR9 -> VAR21 ) >> 16 ) ; * VAR25 = FUN2 ( VAR16 ) ; } } if ( VAR18 >= 0 ) { VAR2 += VAR3 ; VAR4 += VAR5 ; } } } #0
62#62#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , uint32 VAR5 , uint32 VAR6 , uint16 VAR7 , struct VAR8 * VAR9 ) { int VAR10 , VAR11 , VAR12 , VAR13 , VAR14 = 1 ; uint32 VAR15 ; int32 VAR16 = 0 ; uint16 VAR17 = 0 , VAR18 ; uint32 VAR19 ; uint32 VAR20 ; uint32 VAR21 , VAR22 , VAR23 , VAR24 ; uint32 VAR25 = 0 ; tsample_t VAR26 ; tstrip_t VAR27 ; tsize_t VAR28 = FUN2 ( VAR2 ) ; tsize_t VAR29 = FUN3 ( VAR2 ) ; unsigned char * VAR30 [ VAR31 ] ; unsigned char * VAR32 = NULL ; unsigned char * VAR33 = NULL ; if ( VAR4 == NULL ) { FUN4 ( ) ; return ( 0 ) ; } memset ( VAR30 , ' ' , sizeof ( VAR30 ) ) ; FUN5 ( VAR2 , VAR34 , & VAR17 ) ; FUN5 ( VAR2 , VAR35 , & VAR18 ) ; FUN5 ( VAR2 , VAR36 , & VAR24 ) ; if ( VAR24 > VAR5 ) VAR24 = VAR5 ; VAR11 = ( VAR17 + 7 ) / 8 ; VAR12 = ( ( VAR17 * VAR7 ) + 7 ) / 8 ; if ( VAR12 < ( VAR11 + 1 ) ) VAR13 = VAR12 ; else VAR13 = VAR11 + 1 ; VAR21 = ( ( VAR17 * VAR6 ) + 7 ) / 8 ; VAR22 = ( ( VAR17 * VAR6 * VAR7 ) + 7 ) / 8 ; VAR33 = VAR4 ; if ( ( VAR9 -> VAR37 != NULL ) && ( VAR9 -> VAR38 == 3 ) ) { FUN6 ( VAR9 -> VAR37 , VAR9 -> VAR39 , , VAR6 , VAR5 , VAR28 ) ; FUN6 ( VAR9 -> VAR37 , VAR9 -> VAR39 , , VAR17 , VAR7 , VAR13 ) ; } VAR19 = FUN7 ( VAR2 ) ; VAR20 = VAR19 / VAR7 ; if ( ( VAR40 ) VAR29 > 0xFFFFFFFFU - 3U ) { FUN4 ( ) ; FUN8 ( -1 ) ; } for ( VAR26 = 0 ; ( VAR26 < VAR7 ) && ( VAR26 < VAR31 ) ; VAR26 ++ ) { VAR30 [ VAR26 ] = NULL ; VAR32 = FUN9 ( VAR29 + 3 ) ; if ( ! VAR32 ) { FUN4 ( , VAR26 ) ; for ( VAR10 = 0 ; VAR10 < VAR26 ; VAR10 ++ ) FUN10 ( VAR30 [ VAR10 ] ) ; return 0 ; } VAR32 [ VAR29 ] = 0 ; VAR32 [ VAR29 + 1 ] = 0 ; VAR32 [ VAR29 + 2 ] = 0 ; VAR30 [ VAR26 ] = VAR32 ; } VAR23 = 0 ; for ( VAR15 = 0 ; ( VAR15 < VAR20 ) && ( VAR14 == 1 ) ; VAR15 ++ ) { for ( VAR26 = 0 ; ( VAR26 < VAR7 ) && ( VAR26 < VAR31 ) ; VAR26 ++ ) { VAR32 = VAR30 [ VAR26 ] ; VAR27 = ( VAR26 * VAR20 ) + VAR15 ; VAR16 = FUN11 ( VAR2 , VAR27 , VAR32 , VAR29 ) ; VAR25 = VAR16 / VAR21 ; if ( VAR16 < 0 && ! VAR41 ) { FUN4 ( FUN12 ( VAR2 ) , , , "" "" , VAR17 ) ; VAR14 = 0 ; break ; } } if ( ( VAR23 + VAR24 ) > VAR5 ) { VAR23 = VAR5 ; VAR24 = VAR5 - VAR23 ; } else VAR23 += VAR24 ; } for ( VAR26 = 0 ; ( VAR26 < VAR7 ) && ( VAR26 < VAR31 ) ; VAR26 ++ ) { VAR32 = VAR30 [ VAR26 ] ; if ( VAR32 != NULL ) FUN10 ( VAR32 ) ; } return ( VAR14 ) ; } "#0
63#63#static int FUN1 ( VAR1 * VAR2 ) { struct VAR3 * VAR3 = VAR2 -> VAR4 ; VAR5 * VAR6 = VAR2 -> VAR7 ; struct VAR8 * VAR9 = VAR3 -> VAR10 ; int VAR11 , VAR12 ; if ( ! VAR9 ) return 0 ; VAR3 -> VAR10 = VAR9 -> VAR13 ; for ( VAR11 = 0 ; VAR11 < VAR3 -> VAR14 ; VAR11 ++ ) { FUN2 ( & VAR3 -> VAR15 [ VAR11 ] . VAR16 ) ; if ( VAR11 >= VAR9 -> VAR14 || ! VAR9 -> VAR15 [ VAR11 ] . private ) { FUN3 ( VAR2 , VAR11 ) ; } } FUN4 ( VAR6 , VAR9 -> VAR17 , VAR18 ) ; VAR3 -> VAR19 = -1 ; VAR3 -> VAR20 = VAR9 -> VAR20 ; VAR3 -> VAR14 = VAR9 -> VAR14 ; if ( ( VAR12 = FUN5 ( & VAR3 -> VAR15 , VAR3 -> VAR14 , sizeof ( * VAR3 -> VAR15 ) ) ) < 0 ) { VAR3 -> VAR14 = 0 ; return VAR12 ; } else memcpy ( VAR3 -> VAR15 , VAR9 -> VAR15 , VAR9 -> VAR14 * sizeof ( * VAR3 -> VAR15 ) ) ; FUN6 ( VAR9 ) ; return 0 ; } #0
64#64#static av_always_inline void FUN1 ( VAR1 * VAR2 , uint32_t VAR3 ) { int VAR4 ; int VAR5 = 0 , VAR6 = 0 , VAR7 = 1 , VAR8 = 1 ; if ( ! VAR3 ++ ) { FUN2 ( VAR2 , 1 , 1 ) ; return ; } while ( VAR3 > VAR8 ) { VAR7 <<= 1 ; VAR8 <<= 1 ; VAR8 |= 1 ; } VAR6 = FUN3 ( VAR7 ) ; for ( VAR4 = 0 ; VAR4 < VAR6 ; VAR4 ++ ) { VAR7 >>= 1 ; VAR5 <<= 2 ; if ( VAR3 & VAR7 ) VAR5 |= 0x1 ; } FUN2 ( VAR2 , VAR6 * 2 + 1 , ( VAR5 << 1 ) | 1 ) ; } #1
65#65#static void FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 ) { int VAR6 ; register int VAR7 , VAR8 , VAR9 , VAR10 , VAR11 , VAR12 , VAR13 , VAR14 ; VAR4 * VAR15 , * VAR16 ; const VAR1 * VAR17 = VAR18 + VAR19 ; VAR15 = VAR5 ; VAR16 = VAR5 ; for ( VAR6 = 0 ; VAR6 < 8 ; VAR6 ++ ) { VAR7 = 17 * ( VAR15 [ 0 ] + VAR15 [ 2 ] ) + 4 ; VAR8 = 17 * ( VAR15 [ 0 ] - VAR15 [ 2 ] ) + 4 ; VAR9 = 22 * VAR15 [ 1 ] + 10 * VAR15 [ 3 ] ; VAR10 = 22 * VAR15 [ 3 ] - 10 * VAR15 [ 1 ] ; VAR16 [ 0 ] = ( VAR7 + VAR9 ) >> 3 ; VAR16 [ 1 ] = ( VAR8 - VAR10 ) >> 3 ; VAR16 [ 2 ] = ( VAR8 + VAR10 ) >> 3 ; VAR16 [ 3 ] = ( VAR7 - VAR9 ) >> 3 ; VAR15 += 8 ; VAR16 += 8 ; } VAR15 = VAR5 ; for ( VAR6 = 0 ; VAR6 < 4 ; VAR6 ++ ) { VAR7 = 12 * ( VAR15 [ 0 ] + VAR15 [ 32 ] ) + 64 ; VAR8 = 12 * ( VAR15 [ 0 ] - VAR15 [ 32 ] ) + 64 ; VAR9 = 16 * VAR15 [ 16 ] + 6 * VAR15 [ 48 ] ; VAR10 = 6 * VAR15 [ 16 ] - 16 * VAR15 [ 48 ] ; VAR11 = VAR7 + VAR9 ; VAR12 = VAR8 + VAR10 ; VAR13 = VAR8 - VAR10 ; VAR14 = VAR7 - VAR9 ; VAR7 = 16 * VAR15 [ 8 ] + 15 * VAR15 [ 24 ] + 9 * VAR15 [ 40 ] + 4 * VAR15 [ 56 ] ; VAR8 = 15 * VAR15 [ 8 ] - 4 * VAR15 [ 24 ] - 16 * VAR15 [ 40 ] - 9 * VAR15 [ 56 ] ; VAR9 = 9 * VAR15 [ 8 ] - 16 * VAR15 [ 24 ] + 4 * VAR15 [ 40 ] + 15 * VAR15 [ 56 ] ; VAR10 = 4 * VAR15 [ 8 ] - 9 * VAR15 [ 24 ] + 15 * VAR15 [ 40 ] - 16 * VAR15 [ 56 ] ; VAR2 [ 0 * VAR3 ] = VAR17 [ VAR2 [ 0 * VAR3 ] + ( ( VAR11 + VAR7 ) >> 7 ) ] ; VAR2 [ 1 * VAR3 ] = VAR17 [ VAR2 [ 1 * VAR3 ] + ( ( VAR12 + VAR8 ) >> 7 ) ] ; VAR2 [ 2 * VAR3 ] = VAR17 [ VAR2 [ 2 * VAR3 ] + ( ( VAR13 + VAR9 ) >> 7 ) ] ; VAR2 [ 3 * VAR3 ] = VAR17 [ VAR2 [ 3 * VAR3 ] + ( ( VAR14 + VAR10 ) >> 7 ) ] ; VAR2 [ 4 * VAR3 ] = VAR17 [ VAR2 [ 4 * VAR3 ] + ( ( VAR14 - VAR10 + 1 ) >> 7 ) ] ; VAR2 [ 5 * VAR3 ] = VAR17 [ VAR2 [ 5 * VAR3 ] + ( ( VAR13 - VAR9 + 1 ) >> 7 ) ] ; VAR2 [ 6 * VAR3 ] = VAR17 [ VAR2 [ 6 * VAR3 ] + ( ( VAR12 - VAR8 + 1 ) >> 7 ) ] ; VAR2 [ 7 * VAR3 ] = VAR17 [ VAR2 [ 7 * VAR3 ] + ( ( VAR11 - VAR7 + 1 ) >> 7 ) ] ; VAR15 ++ ; VAR2 ++ ; } } #1
66#66#static inline void FUN1 ( VAR1 * VAR2 , VAR1 * VAR3 , int VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 ) { int VAR9 ; VAR8 *= 0x10001 ; switch ( VAR4 ) { case 0 : for ( VAR9 = 0 ; VAR9 < VAR5 ; VAR9 ++ ) { VAR2 [ 0 ] = VAR7 * VAR3 [ 0 ] + VAR8 ; if ( VAR7 ) VAR3 += VAR6 ; VAR2 += VAR6 ; } break ; case 1 : for ( VAR9 = 0 ; VAR9 < VAR5 ; VAR9 ++ ) { FUN2 ( VAR2 , VAR3 , VAR7 , VAR8 ) ; if ( VAR7 ) VAR3 += VAR6 ; VAR2 += VAR6 ; } break ; case 2 : for ( VAR9 = 0 ; VAR9 < VAR5 ; VAR9 ++ ) { FUN2 ( VAR2 , VAR3 , VAR7 , VAR8 ) ; FUN2 ( VAR2 + 2 , VAR3 + 2 , VAR7 , VAR8 ) ; if ( VAR7 ) VAR3 += VAR6 ; VAR2 += VAR6 ; } break ; case 3 : for ( VAR9 = 0 ; VAR9 < VAR5 ; VAR9 ++ ) { FUN2 ( VAR2 , VAR3 , VAR7 , VAR8 ) ; FUN2 ( VAR2 + 2 , VAR3 + 2 , VAR7 , VAR8 ) ; FUN2 ( VAR2 + 4 , VAR3 + 4 , VAR7 , VAR8 ) ; FUN2 ( VAR2 + 6 , VAR3 + 6 , VAR7 , VAR8 ) ; if ( VAR7 ) VAR3 += VAR6 ; VAR2 += VAR6 ; } break ; default : assert ( 0 ) ; } } #1
67#67#int FUN1 ( VAR1 * VAR2 , const void * VAR3 , int VAR4 ) { unsigned char * VAR5 ; const char * VAR6 = VAR3 ; if ( VAR4 < 0 ) { if ( VAR6 == NULL ) return ( 0 ) ; else VAR4 = strlen ( VAR6 ) ; } if ( ( VAR2 -> VAR7 <= VAR4 ) || ( VAR2 -> VAR6 == NULL ) ) { VAR5 = VAR2 -> VAR6 ; VAR2 -> VAR6 = FUN2 ( VAR5 , VAR4 + 1 ) ; if ( VAR2 -> VAR6 == NULL ) { FUN3 ( VAR8 , VAR9 ) ; VAR2 -> VAR6 = VAR5 ; return ( 0 ) ; } } VAR2 -> VAR7 = VAR4 ; if ( VAR6 != NULL ) { memcpy ( VAR2 -> VAR6 , VAR6 , VAR4 ) ; VAR2 -> VAR6 [ VAR4 ] = ' ' ; } return ( 1 ) ; } #1
68#68#"int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; int VAR4 = ( VAR5 && VAR2 -> VAR6 -> VAR7 & VAR8 ) ? VAR2 -> VAR6 -> VAR9 : 1 ; FUN2 ( VAR2 ) ; if ( VAR2 -> VAR10 && VAR2 -> VAR6 -> VAR11 ) VAR4 = VAR2 -> VAR6 -> VAR11 ; if ( VAR2 -> VAR12 == VAR13 && ! VAR2 -> VAR14 ) VAR2 -> VAR15 = ( VAR2 -> VAR16 + 31 ) / 32 * 2 ; else VAR2 -> VAR15 = ( VAR2 -> VAR16 + 15 ) / 16 ; if ( VAR2 -> VAR6 -> VAR17 == VAR18 ) { FUN3 ( VAR2 -> VAR6 , VAR19 , "" "" , VAR4 , VAR21 ) ; VAR4 = VAR21 ; } if ( ( VAR2 -> VAR23 || VAR2 -> VAR16 ) && FUN5 ( VAR2 -> VAR23 , VAR2 -> VAR16 , 0 , VAR2 -> VAR6 ) ) return -1 ; FUN6 ( VAR2 ) ; FUN7 ( VAR2 -> VAR6 -> VAR17 , & VAR2 -> VAR24 , & VAR2 -> VAR25 ) ; FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR26 , VAR27 * sizeof ( VAR28 ) , VAR29 ) ; for ( VAR3 = 0 ; VAR3 < VAR27 ; VAR3 ++ ) { VAR2 -> VAR26 [ VAR3 ] . VAR30 = FUN9 ( ) ; if ( ! VAR2 -> VAR26 [ VAR3 ] . VAR30 ) goto VAR29 ; } VAR2 -> VAR31 . VAR30 = FUN9 ( ) ; if ( ! VAR2 -> VAR31 . VAR30 ) goto VAR29 ; VAR2 -> VAR32 . VAR30 = FUN9 ( ) ; if ( ! VAR2 -> VAR32 . VAR30 ) goto VAR29 ; VAR2 -> VAR33 . VAR30 = FUN9 ( ) ; if ( ! VAR2 -> VAR33 . VAR30 ) goto VAR29 ; VAR2 -> VAR34 . VAR30 = FUN9 ( ) ; if ( ! VAR2 -> VAR34 . VAR30 ) goto VAR29 ; if ( FUN10 ( VAR2 ) ) goto VAR29 ; VAR2 -> VAR35 . VAR36 = -1 ; VAR2 -> VAR37 = 1 ; memset ( VAR2 -> VAR38 , 0 , sizeof ( VAR2 -> VAR38 ) ) ; VAR2 -> VAR38 [ 0 ] = VAR2 ; if ( VAR4 > 1 ) { for ( VAR3 = 0 ; VAR3 < VAR4 ; VAR3 ++ ) { if ( VAR3 ) { VAR2 -> VAR38 [ VAR3 ] = FUN11 ( VAR2 , sizeof ( VAR1 ) ) ; if ( ! VAR2 -> VAR38 [ VAR3 ] ) goto VAR29 ; } if ( FUN12 ( VAR2 -> VAR38 [ VAR3 ] ) < 0 ) goto VAR29 ; VAR2 -> VAR38 [ VAR3 ] -> VAR39 = ( VAR2 -> VAR15 * ( VAR3 ) + VAR4 / 2 ) / VAR4 ; VAR2 -> VAR38 [ VAR3 ] -> VAR40 = ( VAR2 -> VAR15 * ( VAR3 + 1 ) + VAR4 / 2 ) / VAR4 ; } } else { if ( FUN12 ( VAR2 ) < 0 ) goto VAR29 ; VAR2 -> VAR39 = 0 ; VAR2 -> VAR40 = VAR2 -> VAR15 ; } VAR2 -> VAR41 = VAR4 ; return 0 ; VAR29 : FUN13 ( VAR2 ) ; return -1 ; } "#0
69#69#static VAR1 FUN1 ( const unsigned char * VAR2 , size_t VAR3 , int VAR4 , unsigned char * * VAR5 ) { unsigned int VAR6 = 0 ; size_t VAR7 , VAR8 ; unsigned char * VAR9 , VAR10 = 0 ; if ( VAR2 != NULL && VAR3 ) { VAR7 = VAR3 ; VAR8 = VAR2 [ 0 ] ; if ( ! VAR4 && ( VAR8 > 127 ) ) { VAR6 = 1 ; VAR10 = 0 ; } else if ( VAR4 ) { VAR10 = 0xFF ; if ( VAR8 > 128 ) { VAR6 = 1 ; } else if ( VAR8 == 128 ) { for ( VAR6 = 0 , VAR8 = 1 ; VAR8 < VAR3 ; VAR8 ++ ) VAR6 |= VAR2 [ VAR8 ] ; VAR10 = VAR6 != 0 ? 0xffU : 0 ; VAR6 = VAR10 & 1 ; } } VAR7 += VAR6 ; } else { VAR7 = 1 ; VAR3 = 0 ; } if ( VAR5 == NULL || ( VAR9 = * VAR5 ) == NULL ) return VAR7 ; * VAR9 = VAR10 ; VAR9 += VAR6 ; FUN2 ( VAR9 , VAR2 , VAR3 , VAR10 ) ; * VAR5 += VAR7 ; return VAR7 ; } #1
70#70#static av_cold void FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 , VAR5 ; if ( VAR3 ) { int VAR6 ; VAR3 = FUN2 ( VAR3 , 1 , VAR2 -> VAR7 >> 1 ) ; VAR6 = VAR3 * 2 * VAR8 / VAR2 -> VAR7 ; VAR5 = FUN2 ( ( VAR6 - 73 ) / 3 , 0 , 60 ) ; } else { VAR5 = 50 ; } for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR9 ; VAR4 ++ ) { VAR2 -> VAR10 [ VAR4 ] = VAR5 ; VAR2 -> VAR11 [ VAR4 ] = VAR5 * 3 + 73 ; } if ( VAR2 -> VAR12 ) VAR2 -> VAR11 [ VAR2 -> VAR13 ] = 7 ; } #1
71#71#"int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 ) { int VAR4 = 0 ; int VAR5 = 1 ; unsigned long VAR6 , VAR7 = 0 ; if ( VAR2 -> VAR8 -> VAR9 ) { memcpy ( VAR3 , VAR2 -> VAR8 -> VAR9 , VAR2 -> VAR8 -> VAR10 ) ; return ( int ) VAR2 -> VAR8 -> VAR10 ; } FUN2 ( & VAR7 , VAR2 , VAR11 ) ; if ( VAR2 -> VAR8 -> VAR12 & VAR13 ) VAR5 = 0 ; VAR6 = VAR2 -> VAR14 -> VAR15 . VAR16 -> VAR17 ; #ifndef OPENSSL_NO_GOST if ( VAR2 -> VAR18 >= VAR19 ) { if ( VAR6 & VAR20 ) { VAR3 [ VAR4 ++ ] = VAR21 ; VAR3 [ VAR4 ++ ] = VAR22 ; return ( VAR4 ) ; } } #endif #ifndef OPENSSL_NO_DH if ( VAR6 & ( VAR23 | VAR24 ) ) { #  ifndef OPENSSL_NO_RSA if ( VAR5 || ! ( VAR7 & VAR25 ) ) VAR3 [ VAR4 ++ ] = VAR26 ; #  endif #  ifndef OPENSSL_NO_DSA if ( VAR5 || ! ( VAR7 & VAR27 ) ) VAR3 [ VAR4 ++ ] = VAR28 ; #  endif } if ( ( VAR2 -> VAR18 == VAR29 ) && ( VAR6 & ( VAR24 | VAR30 | VAR23 ) ) ) { #  ifndef OPENSSL_NO_RSA VAR3 [ VAR4 ++ ] = VAR31 ; #  endif #  ifndef OPENSSL_NO_DSA VAR3 [ VAR4 ++ ] = VAR32 ; #  endif } #endif #ifndef OPENSSL_NO_RSA if ( ! ( VAR7 & VAR25 ) ) VAR3 [ VAR4 ++ ] = VAR33 ; #endif #ifndef OPENSSL_NO_DSA if ( ! ( VAR7 & VAR27 ) ) VAR3 [ VAR4 ++ ] = VAR34 ; #endif #ifndef OPENSSL_NO_ECDH if ( ( VAR6 & ( VAR35 | VAR36 ) ) && ( VAR2 -> VAR18 >= VAR19 ) ) { if ( VAR5 || ! ( VAR7 & VAR25 ) ) VAR3 [ VAR4 ++ ] = VAR37 ; if ( VAR5 || ! ( VAR7 & VAR38 ) ) VAR3 [ VAR4 ++ ] = VAR39 ; } #endif #ifndef OPENSSL_NO_ECDSA if ( VAR2 -> VAR18 >= VAR19 ) { if ( ! ( VAR7 & VAR38 ) ) VAR3 [ VAR4 ++ ] = VAR40 ; } #endif return ( VAR4 ) ; } "#0
72#72#"int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 ) { int VAR4 , VAR5 ; VAR6 * VAR7 = VAR2 -> VAR8 , * VAR9 = VAR3 -> VAR8 ; if ( VAR2 == VAR3 || ! VAR9 -> VAR10 ) return 0 ; if ( ! VAR7 -> VAR10 ) { memcpy ( VAR7 , VAR9 , sizeof ( VAR6 ) ) ; VAR7 -> VAR11 = VAR2 ; VAR7 -> VAR12 = NULL ; VAR7 -> VAR13 = VAR7 -> VAR14 = 0 ; FUN2 ( VAR7 ) ; } if ( VAR7 -> VAR15 != VAR9 -> VAR15 || VAR7 -> VAR16 != VAR9 -> VAR16 || VAR7 -> VAR17 ) { int VAR18 ; VAR7 -> VAR17 = 0 ; VAR7 -> VAR15 = VAR9 -> VAR15 ; VAR7 -> VAR16 = VAR9 -> VAR16 ; if ( ( VAR18 = FUN3 ( VAR7 ) ) < 0 ) return VAR18 ; } VAR7 -> VAR11 -> VAR19 = VAR9 -> VAR11 -> VAR19 ; VAR7 -> VAR11 -> VAR20 = VAR9 -> VAR11 -> VAR20 ; VAR7 -> VAR11 -> VAR16 = VAR9 -> VAR11 -> VAR16 ; VAR7 -> VAR11 -> VAR15 = VAR9 -> VAR11 -> VAR15 ; VAR7 -> VAR21 = VAR9 -> VAR21 ; VAR7 -> VAR22 = VAR9 -> VAR22 ; for ( VAR4 = 0 ; VAR4 < VAR23 ; VAR4 ++ ) { FUN4 ( VAR7 , & VAR7 -> VAR24 [ VAR4 ] ) ; if ( VAR9 -> VAR24 [ VAR4 ] . VAR25 -> VAR26 [ 0 ] && ( VAR5 = FUN5 ( VAR7 , & VAR7 -> VAR24 [ VAR4 ] , & VAR9 -> VAR24 [ VAR4 ] ) ) < 0 ) return VAR5 ; } #VAR27 FUN6(VAR28)\ do {\ FUN4(VAR7, &VAR7->VAR28);\ if (VAR9->VAR28.VAR25->VAR26[0])\ VAR5 = FUN5(VAR7, &VAR7->VAR28, &VAR9->VAR28);\ else\ VAR5 = FUN7(&VAR7->VAR28, &VAR9->VAR28);\ if (VAR5 < 0)\ return VAR5;\ } while (0)  FUN6(VAR29); FUN6(VAR30); FUN6(VAR31);  VAR7->VAR32    = FUN8(VAR9->VAR32,    VAR7, VAR9); VAR7->VAR33 = FUN8(VAR9->VAR33, VAR7, VAR9); VAR7->VAR34    = FUN8(VAR9->VAR34,    VAR7, VAR9);   VAR7->VAR35 = VAR9->VAR35; VAR7->VAR36      = VAR9->VAR36;   memcpy(&VAR7->VAR37, &VAR9->VAR37, (char *) &VAR9->VAR38 + sizeof(VAR9->VAR38) - (char *) &VAR9->VAR37);   VAR7->VAR39 = VAR9->VAR39; VAR7->VAR40    = VAR9->VAR40; VAR7->VAR41    = VAR9->VAR41;   VAR7->VAR42  = VAR9->VAR42;  if (VAR9->VAR12) { if (VAR9->VAR13 + VAR43 > VAR7->VAR14) FUN9(&VAR7->VAR12, &VAR7->VAR14, VAR9->VAR14); VAR7->VAR13 = VAR9->VAR13; memcpy(VAR7->VAR12, VAR9->VAR12, VAR9->VAR13); memset(VAR7->VAR12 + VAR7->VAR13, 0, VAR43); }   if (!VAR7->VAR44) if (VAR9->VAR45) { if (FUN10(VAR7, VAR9->VAR45) < 0) { FUN11(VAR7->VAR11, VAR46, ); return FUN12(VAR47); } } else { FUN11(VAR7->VAR11, VAR46, ); return VAR48; }   memcpy(&VAR7->VAR49, &VAR9->VAR49, (char *) &VAR9->VAR50 - (char *) &VAR9->VAR49);  if (!VAR9->VAR51) { VAR7->VAR52 = VAR9->VAR53; if (VAR9->VAR33) VAR7->VAR54[VAR9->VAR53] = VAR9->VAR33->VAR25->VAR55; }  return 0; } "#0
73#73#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR4 -> VAR8 ; VAR9 * VAR10 = VAR2 -> VAR11 ; FUN2 ( VAR4 ) ; VAR10 -> VAR12 = FUN3 ( VAR10 -> VAR12 , VAR4 -> VAR13 [ VAR14 ] -> VAR15 , VAR4 -> VAR16 [ 0 ] -> VAR15 ) ; FUN4 ( VAR4 , & VAR7 -> VAR17 , VAR10 ) ; FUN5 ( VAR4 ) ; } #0
74#74#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; float VAR8 ; int VAR9 , VAR10 , VAR11 , VAR12 , VAR13 = -1 , VAR14 = -1 ; char VAR15 [ VAR16 ] ; uint8_t VAR17 [ 3 ] = { 0 , 1 , 2 } ; while ( fgets ( VAR15 , sizeof ( VAR15 ) , VAR4 ) ) { if ( ! FUN2 ( VAR15 , , 3 ) ) VAR14 = FUN3 ( VAR15 + 3 , NULL , 0 ) ; else if ( ! FUN2 ( VAR15 , ) ; return VAR22 ; } if ( VAR13 < 2 || VAR14 < 2 || VAR13 > VAR23 * VAR23 * VAR23 || VAR14 > VAR23 * VAR23 * VAR23 ) { FUN6 ( VAR2 , VAR21 , , VAR28 , VAR28 + 1 , VAR28 + 2 ) != 3 ) return VAR22 ; VAR26 -> VAR29 = VAR28 [ VAR17 [ 0 ] ] * VAR8 ; VAR26 -> VAR30 = VAR28 [ VAR17 [ 1 ] ] * VAR8 ; VAR26 -> VAR31 = VAR28 [ VAR17 [ 2 ] ] * VAR8 ; } } } return 0 ; } #0
75#75#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { int VAR5 , VAR6 ; int VAR7 = VAR2 -> VAR8 ; const float * VAR9 ; float ( * VAR10 ) [ VAR11 ] [ 8 ] = VAR2 -> VAR10 [ VAR4 ] ; FUN2 ( VAR12 , VAR13 , [ 8 * VAR11 ] ) ; if ( VAR2 -> VAR14 == 0x1f ) VAR9 = VAR15 ; else VAR9 = VAR16 ; for ( VAR5 = VAR3 ; VAR5 < VAR2 -> VAR17 ; VAR5 ++ ) { float VAR18 [ VAR11 ] ; if ( FUN3 ( & VAR2 -> VAR19 ) < 0 ) return VAR20 ; for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR21 [ VAR5 ] ; VAR6 ++ ) { int VAR22 ; int VAR23 = VAR2 -> VAR24 [ VAR5 ] [ VAR6 ] ; float VAR25 = VAR9 [ VAR23 ] ; int VAR26 = VAR2 -> VAR27 [ VAR5 ] [ VAR23 ] ; if ( ! VAR23 ) { VAR18 [ VAR6 ] = 0 ; memset ( VAR13 + 8 * VAR6 , 0 , 8 * sizeof ( VAR13 [ 0 ] ) ) ; } else { int VAR28 = VAR2 -> VAR29 [ VAR5 ] [ VAR6 ] && VAR7 >= VAR2 -> VAR29 [ VAR5 ] [ VAR6 ] ; VAR18 [ VAR6 ] = VAR25 * VAR2 -> VAR30 [ VAR5 ] [ VAR6 ] [ VAR28 ] * VAR2 -> VAR31 [ VAR5 ] [ VAR26 ] ; if ( VAR23 >= 11 || ! VAR32 [ VAR23 ] . VAR33 [ VAR26 ] . VAR34 ) { if ( VAR23 <= 7 ) { int VAR35 , VAR36 , VAR37 , VAR38 , VAR39 ; VAR37 = VAR40 [ VAR23 - 1 ] ; VAR38 = VAR41 [ VAR23 - 1 ] ; VAR35 = FUN4 ( & VAR2 -> VAR19 , VAR37 ) ; VAR36 = FUN4 ( & VAR2 -> VAR19 , VAR37 ) ; VAR39 = FUN5 ( VAR35 , VAR36 , VAR38 , VAR13 + 8 * VAR6 ) ; if ( VAR39 ) { FUN6 ( VAR2 -> VAR42 , VAR43 , ) ; VAR2 -> VAR53 |= 0x01 ; } VAR2 -> VAR55 . FUN10 ( VAR10 [ VAR5 ] , VAR2 -> VAR56 [ VAR5 ] , VAR56 , VAR7 * 8 , VAR2 -> VAR30 [ VAR5 ] , VAR2 -> VAR21 [ VAR5 ] , VAR2 -> VAR52 [ VAR5 ] ) ; } } if ( VAR2 -> VAR57 || VAR7 == VAR2 -> VAR58 [ VAR2 -> VAR59 ] - 1 ) { if ( 0xFFFF == FUN4 ( & VAR2 -> VAR19 , 16 ) ) { #ifdef VAR60 FUN6 ( VAR2 -> VAR42 , VAR54 , ) ; return VAR20 ; } } for ( VAR5 = VAR3 ; VAR5 < VAR2 -> VAR17 ; VAR5 ++ ) for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR21 [ VAR5 ] ; VAR6 ++ ) FUN11 ( VAR2 -> VAR50 [ VAR5 ] [ VAR6 ] , & VAR10 [ VAR5 ] [ VAR6 ] [ 4 ] ) ; return 0 ; } "#0
76#76#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , int VAR6 ) { VAR7 * VAR8 ; int VAR9 = 0 ; int VAR10 , VAR11 ; if ( VAR5 ) { if ( ( VAR11 = FUN2 ( VAR2 , VAR5 , VAR12 ) ) < 0 ) return VAR11 ; } if ( VAR2 -> VAR13 > 0 && VAR2 -> VAR14 -> VAR15 && ! VAR6 ) { VAR3 * VAR16 = & VAR2 -> VAR14 -> VAR15 -> VAR5 ; int64_t VAR17 = VAR18 ; int64_t VAR19 = FUN3 ( VAR16 -> VAR20 , VAR2 -> VAR21 [ VAR16 -> VAR22 ] -> VAR23 , VAR24 ) ; for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR25 ; VAR10 ++ ) { int64_t VAR26 ; const VAR7 * VAR27 = VAR2 -> VAR21 [ VAR10 ] -> VAR28 ; if ( ! VAR27 ) continue ; VAR26 = FUN3 ( VAR27 -> VAR5 . VAR20 , VAR2 -> VAR21 [ VAR10 ] -> VAR23 , VAR24 ) ; VAR17 = FUN4 ( VAR17 , VAR26 - VAR19 ) ; VAR9 ++ ; } if ( VAR17 > VAR2 -> VAR13 ) { FUN5 ( VAR2 , VAR29 , VAR30 , VAR17 , VAR2 -> VAR13 ) ; VAR6 = 1 ; } } else { for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR25 ; VAR10 ++ ) VAR9 += ! ! VAR2 -> VAR21 [ VAR10 ] -> VAR28 ; } if ( VAR9 && ( VAR2 -> VAR14 -> VAR31 == VAR9 || VAR6 ) ) { VAR8 = VAR2 -> VAR14 -> VAR15 ; * VAR4 = VAR8 -> VAR5 ; VAR2 -> VAR14 -> VAR15 = VAR8 -> VAR32 ; if ( ! VAR2 -> VAR14 -> VAR15 ) VAR2 -> VAR14 -> VAR33 = NULL ; if ( VAR2 -> VAR21 [ VAR4 -> VAR22 ] -> VAR28 == VAR8 ) VAR2 -> VAR21 [ VAR4 -> VAR22 ] -> VAR28 = NULL ; FUN6 ( & VAR8 ) ; return 1 ; } else { FUN7 ( VAR4 ) ; return 0 ; } } #1
77#77#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 ; uint32_t VAR7 = 0 ; uint32_t VAR8 ; int VAR9 ; VAR6 = FUN2 ( ( VAR4 -> VAR10 + 1 ) , sizeof ( * VAR6 ) ) ; if ( ! VAR6 ) return FUN3 ( VAR11 ) ; VAR6 [ 0 ] . VAR12 = 1 ; VAR6 [ 0 ] . VAR13 = VAR4 -> VAR14 [ 0 ] . VAR15 ; for ( VAR9 = 1 ; VAR9 < VAR4 -> VAR10 ; VAR9 ++ ) { if ( VAR4 -> VAR14 [ VAR9 ] . VAR15 == VAR6 [ VAR7 ] . VAR13 ) { VAR6 [ VAR7 ] . VAR12 ++ ; } else { VAR7 ++ ; VAR6 [ VAR7 ] . VAR13 = VAR4 -> VAR14 [ VAR9 ] . VAR15 ; VAR6 [ VAR7 ] . VAR12 = 1 ; } } VAR7 ++ ; VAR8 = 16 + ( VAR7 * 8 ) ; FUN4 ( VAR2 , VAR8 ) ; FUN5 ( VAR2 , "" "" ) ; FUN4 ( VAR2 , 0 ) ; FUN4 ( VAR2 , VAR7 ) ; for ( VAR9 = 0 ; VAR9 < VAR7 ; VAR9 ++ ) { FUN4 ( VAR2 , VAR6 [ VAR9 ] . VAR12 ) ; FUN4 ( VAR2 , VAR6 [ VAR9 ] . VAR13 ) ; } FUN6 ( VAR6 ) ; return VAR8 ; } "#0
78#78#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; int * VAR9 = FUN2 ( VAR2 -> VAR10 . VAR11 + 1 , sizeof ( int ) ) ; int * VAR12 = FUN2 ( VAR2 -> VAR10 . VAR11 + 1 , sizeof ( int ) ) ; int VAR13 ; int VAR14 , VAR15 = 0 ; int VAR16 , VAR17 , VAR18 = 0 ; if ( ! VAR9 || ! VAR12 ) { FUN3 ( VAR9 ) ; FUN3 ( VAR12 ) ; return FUN4 ( VAR19 ) ; } if ( ! VAR2 -> VAR20 [ 1 ] ) { FUN5 ( VAR2 -> VAR21 , VAR2 -> VAR10 . VAR11 + 1 ) ; for ( VAR16 = 1 ; VAR16 < VAR2 -> VAR22 ; VAR16 ++ ) { VAR2 -> VAR20 [ VAR16 ] = FUN6 ( sizeof ( VAR1 ) ) ; memcpy ( VAR2 -> VAR20 [ VAR16 ] , VAR2 , sizeof ( VAR1 ) ) ; VAR2 -> VAR23 [ VAR16 ] = FUN7 ( sizeof ( VAR6 ) ) ; VAR2 -> VAR20 [ VAR16 ] -> VAR8 = VAR2 -> VAR23 [ VAR16 ] ; } } VAR13 = ( VAR7 -> VAR24 . VAR25 >> 3 ) ; for ( VAR17 = 0 , VAR15 = 0 , VAR14 = VAR13 + VAR2 -> VAR10 . VAR26 [ 0 ] ; VAR17 < VAR2 -> VAR27 ; VAR17 ++ ) { if ( VAR2 -> VAR28 [ VAR17 ] >= VAR13 && VAR2 -> VAR28 [ VAR17 ] < VAR14 ) { VAR14 -- ; VAR15 ++ ; } } for ( VAR16 = 1 ; VAR16 < VAR2 -> VAR10 . VAR11 ; VAR16 ++ ) { VAR13 += ( VAR2 -> VAR10 . VAR26 [ VAR16 - 1 ] - VAR15 ) ; for ( VAR17 = 0 , VAR15 = 0 , VAR14 = VAR13 + VAR2 -> VAR10 . VAR26 [ VAR16 ] ; VAR17 < VAR2 -> VAR27 ; VAR17 ++ ) { if ( VAR2 -> VAR28 [ VAR17 ] >= VAR13 && VAR2 -> VAR28 [ VAR17 ] < VAR14 ) { VAR14 -- ; VAR15 ++ ; } } VAR2 -> VAR10 . VAR29 [ VAR16 - 1 ] = VAR2 -> VAR10 . VAR26 [ VAR16 ] - VAR15 ; VAR2 -> VAR10 . VAR13 [ VAR16 - 1 ] = VAR13 ; } if ( VAR2 -> VAR10 . VAR11 != 0 ) { VAR13 += VAR2 -> VAR10 . VAR26 [ VAR2 -> VAR10 . VAR11 - 1 ] - VAR15 ; VAR2 -> VAR10 . VAR29 [ VAR2 -> VAR10 . VAR11 - 1 ] = VAR5 - VAR13 ; VAR2 -> VAR10 . VAR13 [ VAR2 -> VAR10 . VAR11 - 1 ] = VAR13 ; } VAR2 -> VAR30 = VAR4 ; for ( VAR16 = 1 ; VAR16 < VAR2 -> VAR22 ; VAR16 ++ ) { VAR2 -> VAR20 [ VAR16 ] -> VAR8 -> VAR31 = 1 ; VAR2 -> VAR20 [ VAR16 ] -> VAR8 -> VAR32 = VAR2 -> VAR20 [ 0 ] -> VAR8 -> VAR32 ; memcpy ( VAR2 -> VAR20 [ VAR16 ] , VAR2 , sizeof ( VAR1 ) ) ; VAR2 -> VAR20 [ VAR16 ] -> VAR8 = VAR2 -> VAR23 [ VAR16 ] ; } FUN8 ( & VAR2 -> VAR33 , 0 ) ; FUN9 ( VAR2 -> VAR21 ) ; for ( VAR16 = 0 ; VAR16 <= VAR2 -> VAR10 . VAR11 ; VAR16 ++ ) { VAR12 [ VAR16 ] = VAR16 ; VAR9 [ VAR16 ] = 0 ; } if ( VAR2 -> VAR34 -> VAR35 ) VAR2 -> VAR21 -> FUN10 ( VAR2 -> VAR21 , ( void * ) VAR36 , VAR12 , VAR9 , VAR2 -> VAR10 . VAR11 + 1 ) ; for ( VAR16 = 0 ; VAR16 <= VAR2 -> VAR10 . VAR11 ; VAR16 ++ ) VAR18 += VAR9 [ VAR16 ] ; FUN3 ( VAR9 ) ; FUN3 ( VAR12 ) ; return VAR18 ; } #0
79#79#"static int FUN1 ( const VAR1 * VAR2 ) { #define DATA_BUF_SIZE 256 const VAR3 *VAR4 = FUN2(VAR2->VAR5); VAR6 *VAR7; int VAR8;  FUN3(VAR2->VAR9 <= VAR10); if ((VAR7 = FUN4(VAR10)) == NULL) return 0;  (void)FUN5((unsigned char*)VAR7, (int)VAR2->VAR9); VAR8 = FUN6(VAR11, VAR7, 0, VAR4, NULL); FUN7(VAR7);  return VAR8; } "#0
80#80#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , int VAR9 ) { char VAR10 [ 256 ] ; uint32_t VAR11 ; int VAR12 ; VAR11 = FUN2 ( VAR4 ) ; if ( VAR11 == 3 ) { int VAR13 = FUN2 ( VAR4 ) ; int64_t VAR14 = FUN3 ( VAR4 ) ; FUN4 ( VAR4 , 14 ) ; FUN5 ( VAR2 , 0 ) ; if ( ( VAR14 + VAR13 ) >= FUN3 ( VAR4 ) + 2 ) { FUN6 ( VAR4 ) ; FUN7 ( VAR4 , VAR10 , sizeof ( VAR10 ) ) ; } if ( ( VAR14 + VAR13 ) > FUN3 ( VAR4 ) ) FUN4 ( VAR4 , VAR13 + VAR14 - FUN3 ( VAR4 ) ) ; VAR6 -> VAR15 -> VAR16 = 8000 ; VAR6 -> VAR15 -> VAR17 = 1 ; VAR6 -> VAR15 -> VAR18 = VAR19 ; VAR6 -> VAR15 -> VAR20 = VAR21 ; VAR8 -> VAR22 = VAR23 ; } else { int VAR24 , VAR25 , VAR26 , VAR27 ; int VAR28 ; FUN4 ( VAR4 , 2 ) ; FUN8 ( VAR4 ) ; FUN8 ( VAR4 ) ; FUN2 ( VAR4 ) ; FUN8 ( VAR4 ) ; VAR24 = FUN2 ( VAR4 ) ; VAR8 -> VAR26 = VAR26 = FUN8 ( VAR4 ) ; FUN8 ( VAR4 ) ; FUN8 ( VAR4 ) ; FUN8 ( VAR4 ) ; VAR8 -> VAR25 = VAR25 = FUN2 ( VAR4 ) ; VAR6 -> VAR15 -> VAR29 = FUN2 ( VAR4 ) ; VAR8 -> VAR27 = VAR27 = FUN2 ( VAR4 ) ; FUN2 ( VAR4 ) ; if ( VAR11 == 5 ) { FUN2 ( VAR4 ) ; FUN2 ( VAR4 ) ; FUN2 ( VAR4 ) ; } VAR6 -> VAR15 -> VAR16 = FUN2 ( VAR4 ) ; FUN8 ( VAR4 ) ; VAR6 -> VAR15 -> VAR17 = FUN2 ( VAR4 ) ; if ( VAR11 == 5 ) { VAR8 -> VAR22 = FUN9 ( VAR4 ) ; FUN10 ( VAR4 , VAR10 , 4 ) ; VAR10 [ 4 ] = 0 ; } else { FUN7 ( VAR4 , VAR10 , sizeof ( VAR10 ) ) ; VAR8 -> VAR22 = FUN11 ( VAR10 ) ; FUN7 ( VAR4 , VAR10 , sizeof ( VAR10 ) ) ; } VAR6 -> VAR15 -> VAR18 = VAR19 ; VAR6 -> VAR15 -> VAR30 = FUN11 ( VAR10 ) ; VAR6 -> VAR15 -> VAR20 = FUN12 ( VAR31 , VAR6 -> VAR15 -> VAR30 ) ; switch ( VAR8 -> VAR22 ) { case VAR32 : case VAR23 : case VAR33 : case VAR34 : case VAR35 : case VAR36 : break ; default : FUN13 ( NULL , 0 , ) ; return -1 ; } FUN14 ( & VAR8 -> VAR46 , VAR8 -> VAR43 * VAR25 ) ; break ; case VAR47 : case VAR48 : case VAR49 : FUN2 ( VAR4 ) ; FUN6 ( VAR4 ) ; if ( VAR11 == 5 ) FUN6 ( VAR4 ) ; VAR28 = FUN8 ( VAR4 ) ; if ( VAR28 + VAR50 <= ( unsigned ) VAR28 ) { FUN13 ( VAR2 , VAR45 , , VAR24 ) ; return -1 ; } VAR6 -> VAR15 -> VAR29 = VAR51 [ VAR24 ] ; } else { if ( VAR27 <= 0 ) { FUN13 ( VAR2 , VAR45 , ) ; return -1 ; } FUN14 ( & VAR8 -> VAR46 , VAR8 -> VAR43 * VAR25 ) ; break ; case VAR52 : FUN2 ( VAR4 ) ; FUN6 ( VAR4 ) ; if ( VAR11 == 5 ) FUN6 ( VAR4 ) ; VAR28 = FUN8 ( VAR4 ) ; if ( VAR28 + VAR50 <= ( unsigned ) VAR28 ) { FUN13 ( VAR2 , VAR45 , "" "" ) ; return -1 ; } if ( VAR28 >= 1 ) { FUN6 ( VAR4 ) ; if ( ( VAR12 = FUN15 ( VAR4 , VAR6 -> VAR15 , VAR28 - 1 ) ) < 0 ) return VAR12 ; } break ; default : FUN16 ( VAR6 -> VAR15 -> VAR53 , VAR10 , sizeof ( VAR6 -> VAR15 -> VAR53 ) ) ; } if ( VAR9 ) { FUN6 ( VAR4 ) ; FUN6 ( VAR4 ) ; FUN6 ( VAR4 ) ; FUN5 ( VAR2 , 0 ) ; } } return 0 ; } "#1
81#81#"static int FUN1 ( ) { VAR1 * VAR2 = FUN2 ( ) ; VAR1 * VAR3 = FUN2 ( ) ; VAR1 * VAR4 = FUN2 ( ) ; VAR5 * VAR6 = FUN3 ( ) ; int VAR7 = 0 ; if ( VAR2 == NULL || VAR3 == NULL || VAR4 == NULL || VAR6 == NULL ) goto VAR8 ; FUN4 ( VAR4 ) ; if ( FUN5 ( VAR2 , VAR3 , FUN6 ( ) , VAR4 , VAR9 ) ) { fprintf ( VAR10 , ) ; goto VAR8 ; } FUN7 ( ) ; if ( FUN9 ( VAR2 , FUN6 ( ) , FUN6 ( ) , VAR4 , VAR9 ) ) { fprintf ( VAR10 , ) ; goto VAR8 ; } FUN7 ( ) ; if ( FUN11 ( VAR2 , FUN6 ( ) , FUN6 ( ) , VAR4 , VAR9 , NULL ) ) { fprintf ( VAR10 , ) ; goto VAR8 ; } FUN7 ( ) ; if ( ! FUN13 ( VAR3 , 16 ) ) goto VAR8 ; if ( FUN12 ( VAR6 , VAR3 , VAR9 ) ) { fprintf ( VAR10 , ) ; goto VAR8 ; } FUN7 ( ) ; if ( FUN11 ( VAR2 , FUN6 ( ) , FUN6 ( ) , VAR3 , VAR9 , NULL ) ) { fprintf ( VAR10 , "" "" ) ; goto VAR8 ; } FUN7 ( ) ; VAR7 = 1 ; VAR8 : FUN14 ( VAR2 ) ; FUN14 ( VAR3 ) ; FUN14 ( VAR4 ) ; FUN15 ( VAR6 ) ; return VAR7 ; } "#0
82#82#int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 ) { int VAR4 , VAR5 = 0 ; VAR2 -> VAR6 = VAR3 -> VAR6 ; VAR2 -> VAR7 = VAR3 -> VAR7 ; VAR2 -> VAR8 = VAR3 -> VAR8 ; VAR2 -> VAR9 = VAR3 -> VAR9 ; VAR2 -> VAR10 = VAR3 -> VAR10 ; VAR2 -> VAR11 = VAR3 -> VAR11 ; VAR5 = FUN2 ( VAR2 , VAR3 , 0 ) ; if ( VAR5 < 0 ) return VAR5 ; if ( ! VAR3 -> VAR12 [ 0 ] ) { VAR5 = FUN3 ( VAR2 , 32 ) ; if ( VAR5 < 0 ) return VAR5 ; VAR5 = FUN4 ( VAR2 , VAR3 ) ; if ( VAR5 < 0 ) FUN5 ( VAR2 ) ; return VAR5 ; } for ( VAR4 = 0 ; VAR4 < FUN6 ( VAR3 -> VAR12 ) ; VAR4 ++ ) { if ( ! VAR3 -> VAR12 [ VAR4 ] ) continue ; VAR2 -> VAR12 [ VAR4 ] = FUN7 ( VAR3 -> VAR12 [ VAR4 ] ) ; if ( ! VAR2 -> VAR12 [ VAR4 ] ) { VAR5 = FUN8 ( VAR13 ) ; goto VAR14 ; } } if ( VAR3 -> VAR15 ) { VAR2 -> VAR15 = FUN9 ( sizeof ( * VAR2 -> VAR15 ) , VAR3 -> VAR16 ) ; if ( ! VAR2 -> VAR15 ) { VAR5 = FUN8 ( VAR13 ) ; goto VAR14 ; } VAR2 -> VAR16 = VAR3 -> VAR16 ; for ( VAR4 = 0 ; VAR4 < VAR3 -> VAR16 ; VAR4 ++ ) { VAR2 -> VAR15 [ VAR4 ] = FUN7 ( VAR3 -> VAR15 [ VAR4 ] ) ; if ( ! VAR2 -> VAR15 [ VAR4 ] ) { VAR5 = FUN8 ( VAR13 ) ; goto VAR14 ; } } } if ( VAR3 -> VAR17 != VAR3 -> VAR18 ) { int VAR19 = VAR3 -> VAR9 ; if ( ! VAR19 ) { VAR5 = FUN8 ( VAR20 ) ; goto VAR14 ; } FUN10 ( VAR3 ) ; VAR2 -> VAR17 = FUN11 ( sizeof ( * VAR2 -> VAR17 ) , VAR19 ) ; if ( ! VAR2 -> VAR17 ) { VAR5 = FUN8 ( VAR13 ) ; goto VAR14 ; } memcpy ( VAR2 -> VAR17 , VAR3 -> VAR17 , sizeof ( * VAR3 -> VAR17 ) * VAR19 ) ; } else VAR2 -> VAR17 = VAR2 -> VAR18 ; memcpy ( VAR2 -> VAR18 , VAR3 -> VAR18 , sizeof ( VAR3 -> VAR18 ) ) ; memcpy ( VAR2 -> VAR21 , VAR3 -> VAR21 , sizeof ( VAR3 -> VAR21 ) ) ; return 0 ; VAR14 : FUN5 ( VAR2 ) ; return VAR5 ; } #1
83#83#"static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { FLACFrameInfo VAR4 ; VAR5 * VAR6 ; int VAR7 = 0 ; VAR6 = FUN2 ( VAR2 , VAR3 , VAR8 , & VAR2 -> VAR9 , & VAR2 -> VAR10 ) ; if ( FUN3 ( VAR2 -> VAR11 , VAR6 , & VAR4 ) ) { VAR12 * * VAR13 = & VAR2 -> VAR14 ; int VAR15 ; VAR7 = 0 ; while ( * VAR13 ) { VAR13 = & ( * VAR13 ) -> VAR16 ; VAR7 ++ ; } * VAR13 = FUN4 ( sizeof ( * * VAR13 ) ) ; if ( ! * VAR13 ) { FUN5 ( VAR2 -> VAR11 , VAR17 , "" "" ) ; return FUN6 ( VAR18 ) ; } ( * VAR13 ) -> VAR4 = VAR4 ; ( * VAR13 ) -> VAR3 = VAR3 ; ( * VAR13 ) -> VAR19 = FUN7 ( sizeof ( int ) * VAR20 ) ; if ( ! ( * VAR13 ) -> VAR19 ) { FUN8 ( VAR13 ) ; return FUN6 ( VAR18 ) ; } for ( VAR15 = 0 ; VAR15 < VAR20 ; VAR15 ++ ) ( * VAR13 ) -> VAR19 [ VAR15 ] = VAR21 ; VAR2 -> VAR22 ++ ; VAR7 ++ ; } return VAR7 ; } "#0
84#84#"VAR1 FUN1 ( VAR2 * VAR3 , uint64 VAR4 , uint64 VAR5 , const char * VAR6 ) { uint64 VAR7 = VAR4 * VAR5 ; if ( VAR5 && VAR7 / VAR5 != VAR4 ) { FUN2 ( VAR3 -> VAR8 , VAR6 , "" "" , VAR6 ) ; VAR7 = 0 ; } return VAR7 ; } "#1
85#85#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , unsigned int VAR5 , VAR6 * * VAR7 , VAR8 * VAR9 , int VAR10 ) { PACKET VAR11 = * VAR4 ; size_t VAR12 = 0 ; size_t VAR13 ; VAR14 * VAR15 = & VAR2 -> VAR16 -> VAR17 ; VAR6 * VAR18 = NULL ; const VAR19 * VAR20 ; * VAR7 = NULL ; if ( ( VAR5 & VAR21 ) != 0 ) FUN2 ( & VAR2 -> VAR16 -> VAR17 ) ; VAR13 = FUN3 ( VAR22 ) + ( VAR15 != NULL ? VAR15 -> VAR23 : 0 ) ; VAR18 = FUN4 ( VAR13 * sizeof ( * VAR18 ) ) ; if ( VAR18 == NULL ) { FUN5 ( VAR2 , VAR24 , VAR25 , VAR26 ) ; return 0 ; } VAR12 = 0 ; while ( FUN6 ( & VAR11 ) > 0 ) { unsigned int VAR27 , VAR28 ; PACKET VAR29 ; VAR6 * VAR30 ; if ( ! FUN7 ( & VAR11 , & VAR27 ) || ! FUN8 ( & VAR11 , & VAR29 ) ) { FUN5 ( VAR2 , VAR31 , VAR25 , VAR32 ) ; goto VAR33 ; } if ( ! FUN9 ( VAR2 , VAR5 , VAR27 , VAR15 , VAR18 , & VAR30 ) || ( VAR30 != NULL && VAR30 -> VAR34 == 1 ) || ( VAR27 == VAR35 && ( VAR5 & VAR21 ) != 0 && FUN6 ( & VAR11 ) != 0 ) ) { FUN5 ( VAR2 , VAR36 , VAR25 , VAR32 ) ; goto VAR33 ; } VAR28 = VAR30 - VAR18 ; if ( VAR28 < FUN3 ( VAR22 ) && ( VAR5 & ( VAR21 | VAR37 | VAR38 ) ) == 0 && VAR27 != VAR39 && VAR27 != VAR40 && VAR27 != VAR41 && ( VAR2 -> VAR42 . VAR43 [ VAR28 ] & VAR44 ) == 0 ) { FUN5 ( VAR2 , VAR45 , VAR25 , VAR46 ) ; goto VAR33 ; } if ( VAR30 != NULL ) { VAR30 -> VAR47 = VAR29 ; VAR30 -> VAR34 = 1 ; VAR30 -> VAR27 = VAR27 ; VAR30 -> VAR48 = VAR12 ++ ; if ( VAR2 -> VAR42 . VAR49 ) VAR2 -> VAR42 . FUN10 ( VAR2 , ! VAR2 -> VAR50 , VAR30 -> VAR27 , FUN11 ( & VAR30 -> VAR47 ) , FUN6 ( & VAR30 -> VAR47 ) , VAR2 -> VAR42 . VAR51 ) ; } } if ( VAR10 ) { for ( VAR20 = VAR22 , VAR12 = 0 ; VAR12 < FUN3 ( VAR22 ) ; VAR12 ++ , VAR20 ++ ) { if ( VAR20 -> VAR10 != NULL && ( VAR20 -> VAR5 & VAR5 ) != 0 && FUN12 ( VAR2 , VAR20 -> VAR5 , VAR5 ) && ! VAR20 -> FUN13 ( VAR2 , VAR5 ) ) { goto VAR33 ; } } } * VAR7 = VAR18 ; if ( VAR9 != NULL ) * VAR9 = VAR13 ; return 1 ; VAR33 : FUN14 ( VAR18 ) ; return 0 ; } #1
86#86#void * FUN1 ( VAR1 * VAR2 , int VAR3 , const char * VAR4 , const char * VAR5 , void * ( * VAR6 ) ( int VAR7 , const VAR8 * VAR9 , VAR10 * VAR11 ) , int ( * VAR12 ) ( void * ) , void ( * VAR13 ) ( void * ) , int ( * VAR14 ) ( void * ) ) { VAR15 * VAR16 = FUN2 ( VAR2 ) ; int VAR7 = FUN3 ( VAR4 ) ; void * VAR17 = NULL ; if ( VAR16 == NULL ) return NULL ; if ( VAR7 == VAR18 || ! FUN4 ( VAR16 , VAR7 , VAR5 , & VAR17 ) ) { OSSL_METHOD_CONSTRUCT_METHOD VAR19 = { VAR20 , VAR21 , VAR22 , VAR23 , VAR24 , VAR25 } ; struct method_data_st VAR26 ; VAR26 . VAR7 = VAR7 ; VAR26 . VAR19 = & VAR19 ; VAR26 . VAR27 = VAR6 ; VAR26 . VAR25 = VAR13 ; VAR26 . VAR28 = VAR12 ; VAR26 . VAR25 = VAR13 ; VAR26 . VAR14 = VAR14 ; VAR17 = FUN5 ( VAR2 , VAR3 , VAR4 , VAR5 , 0 , & VAR19 , & VAR26 ) ; FUN6 ( VAR16 , VAR7 , VAR5 , VAR17 ) ; } else { FUN7 ( VAR17 ) ; } return VAR17 ; } #0
87#87#VAR1 FUN1 ( int64_t VAR2 , int64_t VAR3 ) { int VAR4 , VAR5 , VAR6 ; int64_t VAR7 , VAR8 ; if ( VAR2 == 0 ) return VAR3 ; if ( VAR3 == 0 ) return VAR2 ; VAR4 = FUN2 ( VAR2 ) ; VAR5 = FUN2 ( VAR3 ) ; VAR6 = FUN3 ( VAR4 , VAR5 ) ; VAR7 = FUN4 ( VAR2 >> VAR4 ) ; VAR8 = FUN4 ( VAR3 >> VAR5 ) ; while ( VAR7 != VAR8 ) { if ( VAR7 > VAR8 ) FUN5 ( VAR1 , VAR8 , VAR7 ) ; VAR8 -= VAR7 ; VAR8 >>= FUN2 ( VAR8 ) ; } return VAR7 << VAR6 ; } #0
88#88#int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , int send ) { VAR4 * VAR5 ; unsigned char * VAR6 , * VAR7 ; EVP_MD_CTX VAR8 ; const VAR9 * VAR10 ; unsigned char * VAR11 , VAR12 ; size_t VAR13 , VAR14 ; int VAR15 ; int VAR16 ; if ( send ) { VAR5 = & ( VAR2 -> VAR17 -> VAR18 ) ; VAR6 = & ( VAR2 -> VAR17 -> VAR19 [ 0 ] ) ; VAR7 = & ( VAR2 -> VAR17 -> VAR20 [ 0 ] ) ; VAR10 = VAR2 -> VAR21 ; } else { VAR5 = & ( VAR2 -> VAR17 -> VAR22 ) ; VAR6 = & ( VAR2 -> VAR17 -> VAR23 [ 0 ] ) ; VAR7 = & ( VAR2 -> VAR17 -> VAR24 [ 0 ] ) ; VAR10 = VAR2 -> VAR25 ; } VAR16 = FUN2 ( VAR10 ) ; if ( VAR16 < 0 ) return -1 ; VAR13 = VAR16 ; VAR15 = ( 48 / VAR13 ) * VAR13 ; VAR14 = VAR5 -> VAR26 + VAR13 + ( ( unsigned int ) VAR5 -> VAR27 >> 8 ) ; VAR5 -> VAR27 &= 0xff ; if ( ! send && FUN3 ( VAR2 -> VAR28 ) == VAR29 && FUN4 ( VAR10 ) ) { unsigned char VAR30 [ 75 ] ; unsigned VAR31 = 0 ; memcpy ( VAR30 + VAR31 , VAR6 , VAR13 ) ; VAR31 += VAR13 ; memcpy ( VAR30 + VAR31 , VAR32 , VAR15 ) ; VAR31 += VAR15 ; memcpy ( VAR30 + VAR31 , VAR7 , 8 ) ; VAR31 += 8 ; VAR30 [ VAR31 ++ ] = VAR5 -> VAR27 ; VAR30 [ VAR31 ++ ] = VAR5 -> VAR26 >> 8 ; VAR30 [ VAR31 ++ ] = VAR5 -> VAR26 & 0xff ; FUN5 ( VAR10 , VAR3 , & VAR13 , VAR30 , VAR5 -> VAR33 , VAR5 -> VAR26 + VAR13 , VAR14 , VAR6 , VAR13 , 1 ) ; } else { unsigned int VAR34 ; EVP_MD_CTX_init ( & VAR8 ) ; FUN6 ( & VAR8 , VAR10 ) ; EVP_DigestUpdate ( & VAR8 , VAR6 , VAR13 ) ; EVP_DigestUpdate ( & VAR8 , VAR32 , VAR15 ) ; EVP_DigestUpdate ( & VAR8 , VAR7 , 8 ) ; VAR12 = VAR5 -> VAR27 ; EVP_DigestUpdate ( & VAR8 , & VAR12 , 1 ) ; VAR11 = VAR3 ; FUN7 ( VAR5 -> VAR26 , VAR11 ) ; EVP_DigestUpdate ( & VAR8 , VAR3 , 2 ) ; EVP_DigestUpdate ( & VAR8 , VAR5 -> VAR33 , VAR5 -> VAR26 ) ; FUN8 ( & VAR8 , VAR3 , NULL ) ; FUN6 ( & VAR8 , VAR10 ) ; EVP_DigestUpdate ( & VAR8 , VAR6 , VAR13 ) ; EVP_DigestUpdate ( & VAR8 , VAR35 , VAR15 ) ; EVP_DigestUpdate ( & VAR8 , VAR3 , VAR13 ) ; FUN8 ( & VAR8 , VAR3 , & VAR34 ) ; VAR13 = VAR34 ; FUN9 ( & VAR8 ) ; } FUN10 ( VAR7 ) ; return ( VAR13 ) ; } #0
89#89#void FUN1 ( VAR1 * VAR2 , ngx_int_t VAR3 ) { VAR4 * VAR5 ; VAR1 * VAR6 ; VAR7 * VAR8 ; VAR5 = VAR2 -> VAR9 ; FUN2 ( VAR10 , VAR5 -> VAR11 , 0 , , VAR3 , & VAR2 -> VAR13 , & VAR2 -> VAR14 , VAR2 == VAR5 -> VAR15 , VAR2 -> main -> VAR16 ) ; if ( VAR3 == VAR17 ) { FUN3 ( VAR2 ) ; return ; } if ( VAR3 == VAR18 && VAR2 -> VAR19 ) { VAR5 -> VAR20 = 1 ; } if ( VAR3 == VAR21 ) { VAR2 -> VAR22 = NULL ; VAR2 -> VAR23 = VAR24 ; FUN4 ( VAR2 ) ; return ; } if ( VAR2 != VAR2 -> main && VAR2 -> VAR25 ) { VAR3 = VAR2 -> VAR25 -> FUN5 ( VAR2 , VAR2 -> VAR25 -> VAR15 , VAR3 ) ; } if ( VAR3 == VAR26 || VAR3 == VAR27 || VAR3 == VAR28 || VAR5 -> VAR20 ) { if ( FUN6 ( VAR2 ) == VAR18 ) { return ; } if ( VAR2 -> main -> VAR29 ) { VAR2 -> VAR23 = VAR30 ; } FUN7 ( VAR2 , VAR3 ) ; return ; } if ( VAR3 >= VAR31 || VAR3 == VAR32 || VAR3 == VAR33 ) { if ( VAR3 == VAR34 ) { FUN7 ( VAR2 , VAR3 ) ; return ; } if ( VAR2 == VAR2 -> main ) { if ( VAR5 -> read -> VAR35 ) { FUN8 ( VAR5 -> read ) ; } if ( VAR5 -> write -> VAR35 ) { FUN8 ( VAR5 -> write ) ; } } VAR5 -> read -> VAR36 = VAR37 ; VAR5 -> write -> VAR36 = VAR37 ; FUN1 ( VAR2 , FUN9 ( VAR2 , VAR3 ) ) ; return ; } if ( VAR2 != VAR2 -> main ) { if ( VAR2 -> VAR38 || VAR2 -> VAR39 ) { if ( FUN10 ( VAR2 ) != VAR18 ) { FUN7 ( VAR2 , 0 ) ; } return ; } VAR6 = VAR2 -> VAR40 ; if ( VAR2 == VAR5 -> VAR15 ) { VAR2 -> main -> VAR16 -- ; VAR2 -> main -> VAR41 ++ ; if ( ! VAR2 -> VAR42 ) { VAR8 = FUN11 ( VAR2 , VAR43 ) ; if ( VAR8 -> VAR44 ) { FUN12 ( VAR2 ) ; } VAR2 -> VAR42 = 1 ; } else { FUN13 ( VAR45 , VAR5 -> VAR11 , 0 , , & VAR2 -> VAR13 , & VAR2 -> VAR14 ) ; } VAR2 -> VAR46 = 1 ; if ( VAR6 -> VAR39 && VAR6 -> VAR39 -> VAR47 == VAR2 ) { VAR6 -> VAR39 = VAR6 -> VAR39 -> VAR48 ; } VAR5 -> VAR15 = VAR6 ; } else { FUN14 ( VAR10 , VAR5 -> VAR11 , 0 , , & VAR2 -> VAR13 , & VAR2 -> VAR14 ) ; VAR2 -> VAR23 = VAR30 ; if ( VAR2 -> VAR49 ) { VAR2 -> VAR46 = 1 ; } } if ( FUN15 ( VAR6 , NULL ) != VAR18 ) { VAR2 -> main -> VAR16 ++ ; FUN7 ( VAR2 , 0 ) ; return ; } FUN14 ( VAR10 , VAR5 -> VAR11 , 0 , , & VAR6 -> VAR13 , & VAR6 -> VAR14 ) ; return ; } if ( VAR2 -> VAR38 || VAR5 -> VAR38 || VAR2 -> VAR39 || VAR2 -> VAR29 ) { if ( FUN10 ( VAR2 ) != VAR18 ) { FUN7 ( VAR2 , 0 ) ; } return ; } if ( VAR2 != VAR5 -> VAR15 ) { FUN13 ( VAR45 , VAR5 -> VAR11 , 0 , , & VAR2 -> VAR13 , & VAR2 -> VAR14 ) ; return ; } VAR2 -> VAR46 = 1 ; VAR2 -> VAR23 = VAR50 ; if ( ! VAR2 -> VAR51 ) { VAR2 -> VAR52 = 1 ; } if ( FUN6 ( VAR2 ) == VAR18 ) { return ; } if ( VAR5 -> read -> VAR35 ) { FUN8 ( VAR5 -> read ) ; } if ( VAR5 -> write -> VAR35 ) { VAR5 -> write -> VAR53 = 0 ; FUN8 ( VAR5 -> write ) ; } if ( VAR5 -> read -> VAR54 ) { FUN16 ( VAR2 , 0 ) ; return ; } FUN3 ( VAR2 ) ; } #1
90#90#static void FUN1 ( VAR1 ) ( VAR2 * VAR3 , VAR4 * VAR5 , ptrdiff_t VAR6 ) { int VAR7 , VAR8 ; VAR9 * VAR10 = ( VAR9 * ) VAR3 ; VAR6 /= sizeof ( VAR9 ) ; for ( VAR8 = 0 ; VAR8 < 8 ; VAR8 ++ ) { for ( VAR7 = 0 ; VAR7 < 8 ; VAR7 ++ ) { VAR10 [ VAR7 ] += * VAR5 ; VAR5 ++ ; } VAR10 += VAR6 ; } } #1
91#91#static VAR1 * FUN1 ( VAR2 * VAR3 ) { time_t VAR4 ; uintptr_t VAR5 ; ngx_int_t VAR6 ; ngx_uint_t VAR7 , VAR8 ; VAR1 * VAR9 , * VAR10 ; VAR4 = FUN2 ( ) ; VAR10 = NULL ; VAR6 = 0 ; for ( VAR7 = 0 ; VAR7 < VAR3 -> VAR11 -> VAR12 ; VAR7 ++ ) { VAR8 = VAR7 / ( 8 * sizeof ( VAR13 ) ) ; VAR5 = ( VAR13 ) 1 << VAR7 % ( 8 * sizeof ( VAR13 ) ) ; if ( VAR3 -> VAR14 [ VAR8 ] & VAR5 ) { continue ; } VAR9 = & VAR3 -> VAR11 -> VAR9 [ VAR7 ] ; if ( VAR9 -> VAR15 ) { continue ; } if ( VAR9 -> VAR16 && VAR9 -> VAR17 >= VAR9 -> VAR16 && VAR4 - VAR9 -> VAR18 <= VAR9 -> VAR19 ) { continue ; } VAR9 -> VAR20 += VAR9 -> VAR21 ; VAR6 += VAR9 -> VAR21 ; if ( VAR9 -> VAR21 < VAR9 -> VAR22 ) { VAR9 -> VAR21 ++ ; } if ( VAR10 == NULL || VAR9 -> VAR20 > VAR10 -> VAR20 ) { VAR10 = VAR9 ; } } if ( VAR10 == NULL ) { return NULL ; } VAR7 = VAR10 - & VAR3 -> VAR11 -> VAR9 [ 0 ] ; VAR3 -> VAR23 = VAR7 ; VAR8 = VAR7 / ( 8 * sizeof ( VAR13 ) ) ; VAR5 = ( VAR13 ) 1 << VAR7 % ( 8 * sizeof ( VAR13 ) ) ; VAR3 -> VAR14 [ VAR8 ] |= VAR5 ; VAR10 -> VAR20 -= VAR6 ; VAR10 -> VAR18 = VAR4 ; return VAR10 ; } #0
92#92#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , const VAR5 * VAR6 , int VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR10 ; GetBitContext VAR11 ; enum RawDataBlockType VAR12 ; int VAR13 , VAR14 , VAR15 ; FUN2 ( & VAR11 , VAR6 , VAR7 * 8 ) ; if ( FUN3 ( & VAR11 , 12 ) == 0xfff ) { if ( ( VAR13 = FUN4 ( VAR9 , & VAR11 ) ) < 0 ) { FUN5 ( VAR2 , VAR16 , , * VAR4 , VAR15 ) ; return -1 ; } * VAR4 = VAR15 ; VAR9 -> VAR35 . FUN15 ( VAR3 , ( const float * * ) VAR9 -> VAR36 , 1024 , VAR2 -> VAR33 ) ; return VAR7 ; } #0
93#93#"static int FUN1 ( VAR1 * VAR2 , int final ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 ; char VAR8 [ 1024 ] ; int VAR9 , VAR10 ; VAR11 * VAR12 = FUN2 ( VAR2 -> VAR13 , , VAR2 -> VAR14 ) ; VAR9 = FUN3 ( & VAR7 , VAR8 , VAR15 , & VAR2 -> VAR16 , NULL ) ; if ( VAR9 < 0 ) { FUN4 ( VAR2 , VAR17 , 1.0 ) ; FUN5 ( VAR7 , VAR20 : VAR21 : VAR22 : VAR23 : VAR24 : 2011 V AR19 : VAR20 : VAR21 : VAR22 : VAR27 : VAR28 - VAR29 : 2011 % VAR2 : ) ; } else { int VAR30 = VAR4 -> VAR31 / VAR32 ; if ( VAR4 -> VAR33 && ! VAR4 -> VAR34 ) VAR30 = 500 ; FUN5 ( VAR7 , , VAR30 ) ; FUN5 ( VAR7 , , VAR4 -> VAR31 / VAR32 ) ; if ( ! VAR4 -> VAR37 [ 0 ] && VAR2 -> VAR38 > 0 && VAR4 -> VAR39 [ 0 ] . VAR40 > 0 ) { time_t VAR41 = FUN6 ( NULL ) ; struct VAR42 * VAR43 , VAR44 ; VAR43 = FUN7 ( & VAR41 , & VAR44 ) ; if ( VAR43 ) { if ( ! FUN8 ( VAR4 -> VAR37 , sizeof ( VAR4 -> VAR37 ) , % VAR2 ) ; } } FUN5 ( VAR7 , ) ; if ( VAR12 ) { char * VAR46 = FUN9 ( VAR12 -> VAR47 ) ; FUN5 ( VAR7 , ) ; if ( VAR4 -> VAR45 && VAR2 -> VAR38 > 0 && VAR4 -> VAR39 [ 0 ] . VAR40 > 0 && ! VAR4 -> VAR33 ) { VAR48 * VAR49 = & VAR4 -> VAR39 [ 0 ] ; int VAR50 = FUN11 ( VAR49 -> VAR40 - VAR4 -> VAR45 , 0 ) ; int64_t VAR51 = FUN12 ( VAR49 -> VAR52 [ VAR50 ] -> VAR53 , VAR2 -> VAR39 [ 0 ] -> VAR54 , VAR55 ) ; FUN5 ( VAR7 , V AR56 . 0 S "" "" ) ;  }   if  ( VAR4 - > VAR57 )  {  FUN5 ( VAR7 ,  "" "" VAR58 \"" "" true "" "" true \"" "" ) ; for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR38 ; VAR10 ++ ) { VAR59 * VAR60 = VAR2 -> VAR39 [ VAR10 ] ; VAR48 * VAR49 = & VAR4 -> VAR39 [ VAR10 ] ; if ( VAR2 -> VAR39 [ VAR10 ] -> VAR61 -> VAR62 != VAR63 ) continue ; FUN5 ( VAR7 , "" "" % VAR64 "" "" VAR58 / VAR65 \"" "" % VAR2 "" "" % VAR64 \"" "" % VAR64 "" "" ,  VAR10 ,  VAR49 - > VAR66 ,  VAR49 - > VAR67 ,  VAR60 - > VAR61 - > VAR68 ,  VAR60 - > VAR61 - > VAR69 ) ;  FUN13 ( & VAR4 - > VAR39 [ VAR10 ] ,  VAR7 ,  VAR4 ) ;  FUN5 ( VAR7 ,  "" "" ) ;  }  FUN5 ( VAR7 ,  "" "" ) ;  }  if  ( VAR4 - > VAR70 )  {  FUN5 ( VAR7 ,  "" "" VAR71 \"" "" true "" "" true \"" "" ) ; for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR38 ; VAR10 ++ ) { VAR59 * VAR60 = VAR2 -> VAR39 [ VAR10 ] ; VAR48 * VAR49 = & VAR4 -> VAR39 [ VAR10 ] ; if ( VAR2 -> VAR39 [ VAR10 ] -> VAR61 -> VAR62 != VAR72 ) continue ; FUN5 ( VAR7 , "" "" % VAR64 "" "" VAR71 / VAR65 \"" "" % VAR2 "" "" % VAR64 \"" "" , VAR10 , VAR49 -> VAR66 , VAR49 -> VAR67 , VAR60 -> VAR61 -> VAR73 ) ; FUN5 ( VAR7 , "" "" VAR20 : VAR21 : VAR22 : 23003 : 3 : VAR74 : 2011 "" "" % VAR64 \"" "" , VAR60 -> VAR61 -> VAR75 ) ; FUN13 ( & VAR4 -> VAR39 [ VAR10 ] , VAR7 , VAR4 ) ; FUN5 ( VAR7 , "" "" ) ; } FUN5 ( VAR7 , "" "" ) ; } FUN5 ( VAR7 , "" "" ) ; FUN5 ( VAR7 , "" "" ) ; FUN14 ( VAR7 ) ; FUN15 ( VAR7 ) ; return FUN16 ( VAR8 , VAR2 -> VAR14 , VAR2 ) ; } "#1
94#94#"int FUN1 ( const unsigned char * * VAR1 , long * VAR2 , int * VAR3 , int * VAR4 , long VAR5 ) { int VAR6 , VAR7 ; long VAR8 ; const unsigned char * VAR9 = * VAR1 ; int VAR10 , VAR11 , VAR12 ; long VAR13 = VAR5 ; if ( ! VAR13 ) goto VAR14 ; VAR7 = ( * VAR9 & VAR15 ) ; VAR11 = ( * VAR9 & VAR16 ) ; VAR6 = * VAR9 & VAR17 ; if ( VAR6 == VAR17 ) { VAR9 ++ ; if ( -- VAR13 == 0 ) goto VAR14 ; VAR8 = 0 ; while ( * VAR9 & 0x80 ) { VAR8 <<= 7L ; VAR8 |= * ( VAR9 ++ ) & 0x7f ; if ( -- VAR13 == 0 ) goto VAR14 ; if ( VAR8 > ( VAR18 >> 7L ) ) goto VAR14 ; } VAR8 <<= 7L ; VAR8 |= * ( VAR9 ++ ) & 0x7f ; VAR10 = ( int ) VAR8 ; if ( -- VAR13 == 0 ) goto VAR14 ; } else { VAR10 = VAR6 ; VAR9 ++ ; if ( -- VAR13 == 0 ) goto VAR14 ; } * VAR3 = VAR10 ; * VAR4 = VAR11 ; if ( ! FUN2 ( & VAR9 , & VAR12 , VAR2 , ( int ) VAR13 ) ) goto VAR14 ; #if 0 fprintf ( VAR19 , "" "" , ( int ) VAR9 , * VAR2 , VAR5 , ( int ) * VAR1 , ( int ) ( VAR9 + * VAR2 ) , ( int ) ( VAR5 + * VAR1 ) ) ; #endif if ( * VAR2 > ( VAR5 - ( VAR9 - * VAR1 ) ) ) { FUN3 ( VAR20 , VAR21 ) ; VAR7 |= 0x80 ; } * VAR1 = VAR9 ; return ( VAR7 | VAR12 ) ; VAR14 : FUN3 ( VAR20 , VAR22 ) ; return ( 0x80 ) ; } "#1
95#95#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 ; const char * VAR5 ; apr_size_t VAR6 ; apr_status_t VAR7 ; for ( VAR4 = FUN2 ( VAR2 ) ; VAR4 != FUN3 ( VAR2 ) ; VAR4 = FUN4 ( VAR4 ) ) { if ( FUN5 ( VAR4 ) ) { break ; } VAR7 = FUN6 ( VAR4 , & VAR5 , & VAR6 , VAR8 ) ; if ( VAR7 != VAR9 ) { break ; } } } #1
96#96#"static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * VAR5 = VAR2 -> VAR6 ; uint8_t VAR7 [ VAR8 + VAR9 ] ; int VAR10 , VAR11 = 0 ; if ( FUN2 ( VAR5 -> VAR12 ) != VAR2 -> VAR13 ) { int VAR14 ; FUN3 ( VAR2 -> VAR6 , "" "" ) ; for ( VAR14 = 0 ; VAR14 < VAR15 ; VAR14 ++ ) { if ( VAR2 -> VAR16 [ VAR14 ] ) { if ( VAR2 -> VAR16 [ VAR14 ] -> VAR17 == VAR18 ) { VAR19 * VAR20 = VAR2 -> VAR16 [ VAR14 ] -> VAR21 . VAR22 . VAR23 ; FUN4 ( & VAR20 -> VAR24 ) ; VAR20 -> VAR25 = 0 ; VAR20 -> VAR26 = VAR27 ; } VAR2 -> VAR16 [ VAR14 ] -> VAR28 = -1 ; } } } VAR2 -> VAR29 = 0 ; VAR10 = 0 ; memset ( VAR7 + VAR8 , 0 , VAR9 ) ; for ( ; ; ) { if ( VAR2 -> VAR29 > 0 ) break ; VAR10 ++ ; if ( VAR3 != 0 && VAR10 >= VAR3 ) break ; VAR11 = FUN5 ( VAR5 , VAR7 , VAR2 -> VAR30 ) ; if ( VAR11 != 0 ) break ; VAR11 = FUN6 ( VAR2 , VAR7 ) ; if ( VAR11 != 0 ) break ; } VAR2 -> VAR13 = FUN2 ( VAR5 -> VAR12 ) ; return VAR11 ; } "#0
97#97#static void FUN1 ( unsigned char * * VAR1 , int VAR2 ) { unsigned char * VAR3 = * VAR1 ; int VAR4 , VAR5 ; if ( VAR2 <= 127 ) * ( VAR3 ++ ) = ( unsigned char ) VAR2 ; else { VAR5 = VAR2 ; for ( VAR4 = 0 ; VAR5 > 0 ; VAR4 ++ ) VAR5 >>= 8 ; * ( VAR3 ++ ) = VAR4 | 0x80 ; VAR5 = VAR4 ; while ( VAR4 -- > 0 ) { VAR3 [ VAR4 ] = VAR2 & 0xff ; VAR2 >>= 8 ; } VAR3 += VAR5 ; } * VAR1 = VAR3 ; } #1
98#98#"int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 , * VAR7 , * VAR8 , * VAR9 ; int VAR10 ; int VAR11 , VAR12 ; int VAR13 = 0 ; VAR6 = FUN2 ( ) ; VAR7 = FUN2 ( ) ; VAR8 = FUN2 ( ) ; VAR9 = FUN2 ( ) ; if ( VAR6 == NULL || VAR7 == NULL || VAR8 == NULL || VAR9 == NULL ) goto VAR14 ; #if 0 if ( ! FUN3 ( VAR7 , 512 , 0 , NULL , NULL , VAR15 , NULL ) ) goto VAR14 ; #else FUN4(VAR7,65537); #endif FUN5('', VAR16);  for (VAR10 = 0; VAR10 < VAR17; VAR10++) { if (!FUN6(VAR6, 512, 0, 0)) goto VAR14; VAR6->VAR18 = FUN7();   if (!FUN8(VAR9, VAR7)) goto VAR14; if (!FUN9(VAR9, 1)) goto VAR14; if (!FUN10(VAR9, VAR9)) goto VAR14;  #if 1 if (!FUN11(VAR8, VAR6, VAR9, VAR7, VAR4)) goto VAR14; #elif 0 if (!FUN12(VAR8, VAR6, VAR9, VAR7, VAR4)) goto VAR14; #else if (!FUN13(VAR8, VAR6, VAR9, VAR7, VAR4)) goto VAR14; #endif  if (FUN14(VAR8, 1)) VAR11 = 1; else { if (!FUN15(VAR8, 1)) goto VAR14; if (0 != FUN16(VAR8, VAR7)) { fprintf(VAR16, ); FUN18(VAR16, VAR6); fprintf(VAR16, ); goto VAR14; }  FUN5('', VAR16); FUN19(VAR16); }  FUN5('', VAR16); FUN19(VAR16); VAR13 = 1; VAR14: if (VAR6 != NULL) FUN20(VAR6); if (VAR7 != NULL) FUN20(VAR7); if (VAR8 != NULL) FUN20(VAR8); if (VAR9 != NULL) FUN20(VAR9); return VAR13; } "#0
99#99#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 = 0 ; int64_t VAR7 = VAR4 -> VAR8 ; if ( VAR9 == 0 ) { ReadInterval VAR10 = ( VAR11 ) { . VAR12 = 0 , . VAR13 = 0 } ; VAR6 = FUN2 ( VAR2 , VAR4 , & VAR10 , & VAR7 ) ; } else { for ( VAR5 = 0 ; VAR5 < VAR9 ; VAR5 ++ ) { VAR6 = FUN2 ( VAR2 , VAR4 , & VAR14 [ VAR5 ] , & VAR7 ) ; if ( VAR6 < 0 ) break ; } } } #1
100#100#static int FUN1 ( ) { VAR1 * VAR2 , * VAR3 , * VAR4 , * VAR5 , * VAR6 ; VAR7 * VAR8 ; int VAR9 ; VAR8 = FUN2 ( ) ; VAR2 = FUN3 ( ) ; VAR3 = FUN3 ( ) ; VAR4 = FUN3 ( ) ; VAR5 = FUN3 ( ) ; VAR6 = FUN3 ( ) ; for ( VAR9 = 0 ; VAR9 < VAR10 + VAR11 ; VAR9 ++ ) { if ( VAR9 < VAR11 ) { FUN4 ( VAR2 , 400 , 0 , 0 ) ; FUN5 ( VAR3 , VAR2 ) ; FUN6 ( VAR2 , VAR2 , VAR9 ) ; FUN7 ( VAR2 , VAR9 ) ; } else FUN4 ( VAR3 , 50 + 3 * ( VAR9 - VAR11 ) , 0 , 0 ) ; VAR2 -> VAR12 = FUN8 ( ) ; VAR3 -> VAR12 = FUN8 ( ) ; FUN9 ( VAR8 , VAR3 , VAR13 ) ; FUN10 ( VAR5 , VAR4 , VAR2 , VAR8 , VAR13 ) ; FUN11 ( VAR6 , VAR5 , VAR3 , VAR13 ) ; FUN12 ( VAR5 , VAR6 , VAR4 ) ; FUN13 ( VAR5 , VAR5 , VAR2 ) ; if ( ! FUN14 ( VAR5 ) ) { FUN15 ( ) ; FUN16 ( VAR14 , VAR2 ) ; FUN15 ( ) ; return 0 ; } } FUN17 ( VAR2 ) ; FUN17 ( VAR3 ) ; FUN17 ( VAR4 ) ; FUN17 ( VAR5 ) ; FUN17 ( VAR6 ) ; FUN18 ( VAR8 ) ; return 1 ; } #0
101#101#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , const VAR5 * VAR6 , int VAR7 ) { int VAR8 , VAR9 , VAR10 ; VAR8 = 0 ; VAR9 = 0 ; VAR10 = 0 ; while ( VAR8 < VAR7 ) { int VAR11 , VAR12 ; if ( VAR10 >= VAR2 -> VAR13 -> VAR14 ) return ; if ( VAR6 [ VAR8 ] & 0x80 ) { VAR11 = 1 ; VAR12 = VAR6 [ VAR8 ] ; VAR8 ++ ; } else { VAR11 = ( VAR6 [ VAR8 ] & 0x7f ) + 2 ; VAR12 = VAR6 [ VAR8 + 1 ] ; VAR8 += 2 ; } if ( VAR3 ) VAR11 *= 2 ; if ( VAR12 ) { memset ( VAR2 -> VAR15 . VAR16 [ 0 ] + VAR10 * VAR2 -> VAR15 . VAR17 [ 0 ] + VAR9 , VAR12 , VAR11 ) ; if ( VAR4 ) memset ( VAR2 -> VAR15 . VAR16 [ 0 ] + ( VAR10 + 1 ) * VAR2 -> VAR15 . VAR17 [ 0 ] + VAR9 , VAR12 , VAR11 ) ; } VAR9 += VAR11 ; if ( VAR9 >= VAR2 -> VAR13 -> VAR18 ) { VAR9 = 0 ; VAR10 += 1 + VAR4 ; } } } #0
102#102#VAR1 FUN1 ( VAR2 * VAR3 , uint32 VAR4 , void * VAR5 , tmsize_t VAR6 ) { static const char VAR7 [ ] = , ( unsigned long ) VAR4 , ( unsigned long ) VAR9 -> VAR13 ) ; return ( ( VAR1 ) ( -1 ) ) ; } if ( VAR9 -> VAR15 == VAR16 && VAR6 != ( VAR1 ) ( -1 ) && VAR6 >= VAR11 && ! FUN4 ( VAR3 ) && ( ( VAR3 -> VAR17 & VAR18 ) == 0 ) ) { if ( FUN5 ( VAR3 , VAR4 , VAR5 , VAR11 , VAR7 ) != VAR11 ) return ( ( VAR1 ) ( -1 ) ) ; if ( ! FUN6 ( VAR3 , VAR9 -> VAR19 ) && ( VAR3 -> VAR17 & VAR20 ) == 0 ) FUN7 ( VAR5 , VAR11 ) ; ( * VAR3 -> VAR21 ) ( VAR3 , VAR5 , VAR11 ) ; return ( VAR11 ) ; } if ( VAR6 == ( VAR1 ) ( -1 ) ) VAR6 = VAR11 ; else if ( VAR6 > VAR11 ) VAR6 = VAR11 ; if ( FUN8 ( VAR3 , VAR4 ) && ( * VAR3 -> VAR22 ) ( VAR3 , ( VAR23 * ) VAR5 , VAR6 , ( VAR24 ) ( VAR4 / VAR9 -> VAR25 ) ) ) { ( * VAR3 -> VAR21 ) ( VAR3 , ( VAR23 * ) VAR5 , VAR6 ) ; return ( VAR6 ) ; } else return ( ( VAR1 ) ( -1 ) ) ; } #0
103#103#"int FUN1 ( VAR1 * VAR2 , uint32 VAR3 ) { static const char VAR4 [ ] = , ( unsigned __int64 ) VAR11 , ( unsigned long ) VAR3 ) ; #else FUN4(VAR2->VAR16, VAR4, , (unsigned __int64) VAR11, (unsigned long) VAR3, (unsigned __int64) VAR19); #else FUN4(VAR2->VAR16, VAR4,   ); return(0); } if (VAR34 > VAR2->VAR28) { VAR2->VAR22 = VAR23; if ((VAR2->VAR9 & VAR26) == 0) { FUN4(VAR2->VAR16, VAR4, """", (unsigned long) VAR3); return (0); } } if (VAR2->VAR9&VAR33) { VAR2->VAR22 = VAR23; VAR2->VAR27 = NULL; VAR2->VAR28 = 0; VAR2->VAR9 &= ~VAR33; }  if( FUN7(VAR2) ) { if (VAR34 > VAR2->VAR28 && !FUN10(VAR2, 0, VAR34)) { return (0); } if (FUN11(VAR2, VAR3, VAR2->VAR27, VAR34, VAR4) != VAR34) { return (0); } } else { if (FUN12(VAR2, VAR3, 1, VAR34, VAR4) != VAR34) { return (0); } }   VAR2->VAR31 = 0; VAR2->VAR32 = VAR34;  if (!FUN8(VAR2, VAR6->VAR24) && (VAR2->VAR9 & VAR25) == 0) FUN13(VAR2->VAR27, VAR34); } } return (FUN14(VAR2, VAR3)); } "#1
104#104#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , void * VAR7 , int VAR8 ) { VAR9 * VAR10 = & VAR2 -> VAR11 ; VAR12 * VAR13 ; if ( ! VAR6 -> VAR14 [ VAR2 -> VAR15 ] ) return ( FUN2 ( VAR16 ) ) ; VAR13 = ( VAR12 * ) VAR6 -> VAR14 [ VAR2 -> VAR15 ] -> VAR17 ; if ( VAR13 -> VAR18 . VAR19 ) { int VAR20 = FUN3 ( VAR4 , 4 ) ; VAR10 -> VAR21 = VAR22 ; if ( VAR20 == 2 ) { FUN4 ( VAR7 , VAR23 , ) ; VAR10 -> VAR21 = VAR25 ; } FUN3 ( VAR4 , 2 ) ; FUN3 ( VAR4 , 1 ) ; FUN5 ( VAR4 ) ; VAR8 -- ; } FUN6 ( VAR4 , 8 * VAR8 ) ; return 0 ; } #0
105#105#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; GetBitContext VAR14 ; static int VAR15 = 0 ; int VAR16 ; FUN2 ( & VAR14 , VAR8 , VAR9 * 8 ) ; if ( VAR12 -> VAR17 && FUN3 ( & VAR14 ) ) { FUN4 ( VAR2 , VAR18 , , VAR12 -> VAR19 ? , VAR15 , VAR12 -> VAR21 [ 0 ] ) ; VAR15 ++ ; if ( VAR12 -> VAR21 [ 0 ] != VAR12 -> VAR20 [ 0 ] ) FUN7 ( VAR12 ) ; for ( VAR16 = 0 ; VAR16 < VAR12 -> VAR22 ; VAR16 ++ ) if ( VAR12 -> VAR21 [ VAR16 ] != VAR12 -> VAR20 [ VAR16 ] || VAR12 -> VAR21 [ 0 ] != VAR12 -> VAR20 [ 0 ] ) FUN8 ( VAR12 , VAR16 ) ; if ( VAR2 -> VAR26 >= VAR27 && ! VAR12 -> VAR19 ) return VAR9 ; if ( VAR12 -> VAR19 ) { if ( ! VAR12 -> VAR17 ) { FUN5 ( & VAR14 , 4 ) ; FUN5 ( & VAR14 , 4 ) ; if ( VAR12 -> VAR28 ) { VAR12 -> VAR28 = FUN6 ( & VAR14 , 5 ) ; if ( VAR15 == 1 ) FUN4 ( VAR12 -> VAR2 , VAR29 , ) ; FUN5 ( & VAR14 , 2 ) ; } if ( VAR12 -> VAR30 . VAR3 [ 0 ] == VAR12 -> VAR31 . VAR3 [ 0 ] ) { if ( VAR12 -> VAR31 . VAR3 [ 0 ] ) VAR2 -> FUN9 ( VAR2 , & VAR12 -> VAR31 ) ; VAR12 -> VAR30 = VAR12 -> VAR31 ; } else { if ( VAR12 -> VAR31 . VAR3 [ 0 ] ) VAR2 -> FUN9 ( VAR2 , & VAR12 -> VAR31 ) ; if ( VAR12 -> VAR30 . VAR3 [ 0 ] ) VAR2 -> FUN9 ( VAR2 , & VAR12 -> VAR30 ) ; } VAR12 -> VAR31 . VAR32 = 3 ; if ( VAR2 -> FUN10 ( VAR2 , & VAR12 -> VAR31 ) < 0 ) { FUN4 ( VAR12 -> VAR2 , VAR18 , ) ; return -1 ; } if ( VAR2 -> FUN10 ( VAR2 , & VAR12 -> VAR33 ) < 0 ) { FUN4 ( VAR12 -> VAR2 , VAR18 , ) ; return -1 ; } if ( FUN14 ( VAR12 , & VAR14 ) ) { FUN4 ( VAR12 -> VAR2 , VAR18 , ) ; return -1 ; } if ( FUN16 ( VAR12 , & VAR14 ) ) { FUN4 ( VAR12 -> VAR2 , VAR18 , ) ; return -1 ; } for ( VAR16 = 0 ; VAR16 < VAR12 -> VAR37 ; VAR16 ++ ) FUN18 ( VAR12 , VAR16 ) ; for ( VAR16 = 0 ; VAR16 < 3 ; VAR16 ++ ) { int VAR38 = ( VAR12 -> VAR39 >> ( 3 + ! ! VAR16 ) ) - 1 ; FUN19 ( VAR12 , VAR16 , VAR38 , VAR38 + 1 ) ; } * VAR4 = sizeof ( VAR40 ) ; * ( VAR40 * ) VAR3 = VAR12 -> VAR33 ; if ( ( VAR12 -> VAR30 . VAR3 [ 0 ] ) && ( VAR12 -> VAR30 . VAR3 [ 0 ] != VAR12 -> VAR31 . VAR3 [ 0 ] ) ) VAR2 -> FUN9 ( VAR2 , & VAR12 -> VAR30 ) ; VAR12 -> VAR30 = VAR12 -> VAR33 ; VAR12 -> VAR33 . VAR3 [ 0 ] = NULL ; return VAR9 ; } #0
106#106#static int FUN1 ( VAR1 * VAR2 , const unsigned char * VAR3 , size_t VAR4 , int VAR5 ) { uint64_t VAR6 ; if ( FUN2 ( & VAR6 , VAR3 , VAR4 ) == 0 ) return 0 ; if ( VAR5 ) { if ( VAR6 <= VAR7 ) { * VAR2 = - ( VAR1 ) VAR6 ; } else if ( VAR6 == VAR8 ) { * VAR2 = ( VAR1 ) ( 0 - VAR6 ) ; } else { FUN3 ( VAR9 , VAR10 ) ; return 0 ; } } else { if ( VAR6 <= VAR7 ) { * VAR2 = ( VAR1 ) VAR6 ; } else { FUN3 ( VAR9 , VAR11 ) ; return 0 ; } } return 1 ; } #0
107#107#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 , VAR9 ; while ( VAR6 -> VAR10 ) { if ( VAR2 -> VAR11 -> VAR12 ) return VAR13 ; VAR8 = FUN2 ( VAR2 -> VAR11 ) ; if ( VAR8 == VAR14 ) continue ; if ( VAR8 == VAR15 ) return VAR13 ; VAR6 -> VAR16 = FUN3 ( VAR2 -> VAR11 ) ; if ( ! VAR6 -> VAR16 ) return VAR17 ; if ( ( VAR9 = FUN4 ( & VAR6 -> VAR18 , VAR6 -> VAR16 + 1 ) ) < 0 ) return VAR9 ; VAR6 -> VAR18 [ 0 ] = VAR8 ; if ( FUN5 ( VAR2 -> VAR11 , VAR6 -> VAR18 + 1 , VAR6 -> VAR16 ) != VAR6 -> VAR16 ) return FUN6 ( VAR19 ) ; if ( VAR8 & VAR20 ) { int VAR21 = VAR6 -> VAR18 [ 1 ] * 65 + 1 ; if ( VAR21 >= VAR6 -> VAR16 ) { FUN7 ( VAR2 , VAR22 , "" "" , VAR21 , VAR6 -> VAR16 ) ; return VAR17 ; } if ( FUN8 ( VAR4 , VAR21 ) < 0 ) return FUN6 ( VAR23 ) ; memcpy ( VAR4 -> VAR24 , VAR6 -> VAR18 + 1 , VAR4 -> VAR16 ) ; VAR4 -> VAR25 = 1 ; VAR4 -> VAR26 = VAR6 -> VAR27 ; VAR4 -> VAR28 = VAR6 -> VAR18 [ 1 ] * 32 ; VAR6 -> VAR27 += VAR4 -> VAR28 ; VAR6 -> VAR10 = 0 ; return VAR4 -> VAR16 ; } else break ; } if ( FUN8 ( VAR4 , VAR6 -> VAR16 + 1 ) < 0 ) return FUN6 ( VAR23 ) ; VAR4 -> VAR25 = 0 ; VAR6 -> VAR10 = 1 ; memcpy ( VAR4 -> VAR24 , VAR6 -> VAR18 , VAR4 -> VAR16 ) ; return VAR4 -> VAR16 ; } "#1
108#108#int FUN1 ( int VAR1 [ 4 ] , enum PixelFormat VAR2 , int VAR3 ) { int VAR4 , VAR5 ; const VAR6 * VAR7 = & VAR8 [ VAR2 ] ; int VAR9 [ 4 ] ; int VAR10 [ 4 ] ; memset ( VAR1 , 0 , 4 * sizeof ( VAR1 [ 0 ] ) ) ; if ( ( unsigned ) VAR2 >= VAR11 || VAR7 -> VAR12 & VAR13 ) return FUN2 ( VAR14 ) ; FUN3 ( VAR9 , VAR10 , VAR7 ) ; for ( VAR4 = 0 ; VAR4 < 4 ; VAR4 ++ ) { if ( ( VAR5 = FUN4 ( VAR3 , VAR4 , VAR9 [ VAR4 ] , VAR10 [ VAR4 ] , VAR7 ) ) < 0 ) return VAR5 ; VAR1 [ VAR4 ] = VAR5 ; } return 0 ; } #0
109#109#int FUN1 ( const VAR1 * VAR2 , const VAR1 * VAR3 ) { int VAR4 ; FUN2 ( ( VAR1 * ) VAR2 , -1 , 0 ) ; FUN2 ( ( VAR1 * ) VAR3 , -1 , 0 ) ; VAR4 = memcmp ( VAR2 -> VAR5 , VAR3 -> VAR5 , VAR6 ) ; if ( VAR4 ) return VAR4 ; if ( ! VAR2 -> VAR7 . VAR8 . VAR9 && ! VAR3 -> VAR7 . VAR8 . VAR9 ) { VAR4 = ( int ) ( VAR2 -> VAR7 . VAR8 . VAR10 - VAR3 -> VAR7 . VAR8 . VAR10 ) ; if ( VAR4 ) return VAR4 ; return memcmp ( VAR2 -> VAR7 . VAR8 . VAR8 , VAR3 -> VAR7 . VAR8 . VAR8 , VAR2 -> VAR7 . VAR8 . VAR10 ) ; } return VAR4 ; } #1
110#110#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR2 -> VAR7 ; int64_t VAR8 , VAR9 ; int VAR10 ; if ( VAR4 -> VAR11 . VAR12 > 0 ) { VAR10 = FUN2 ( VAR2 , & VAR4 -> VAR11 , 0 ) ; FUN3 ( & VAR4 -> VAR11 ) ; if ( VAR10 < 0 ) { FUN4 ( VAR2 , VAR13 , , VAR4 -> VAR22 , VAR23 - VAR9 ) ; return FUN11 ( VAR29 ) ; } if ( VAR23 < VAR9 + VAR4 -> VAR22 ) FUN12 ( VAR7 , VAR4 -> VAR22 - ( VAR23 - VAR9 ) ) ; FUN9 ( VAR7 , VAR8 , VAR25 ) ; } else { VAR9 = FUN10 ( VAR2 , VAR4 -> VAR20 , VAR4 -> VAR26 , VAR2 -> VAR27 ) ; } VAR10 = FUN13 ( VAR4 -> VAR30 , VAR31 , VAR9 ) ; if ( VAR10 < 0 ) return VAR10 ; } FUN14 ( VAR7 , VAR4 ) ; FUN4 ( VAR2 , VAR32 , , VAR4 -> VAR34 ) ; VAR8 = FUN8 ( VAR7 ) ; FUN9 ( VAR7 , VAR4 -> VAR35 , VAR25 ) ; FUN15 ( VAR7 , VAR36 , VAR4 -> VAR34 ) ; if ( VAR4 -> VAR37 ) { int VAR38 ; for ( VAR38 = 0 ; VAR38 < VAR2 -> VAR27 ; ++ VAR38 ) { VAR39 * VAR40 = VAR2 -> VAR41 [ VAR38 ] ; double VAR42 = VAR4 -> VAR37 [ VAR38 ] * FUN16 ( VAR40 -> VAR43 ) ; char VAR44 [ 20 ] = VAR33 , ( int ) VAR42 / 3600 , ( ( int ) VAR42 / 60 ) % 60 , FUN17 ( VAR42 , 60 ) ) ; FUN18 ( VAR7 , VAR47 , VAR44 , 20 ) ; } } } FUN9 ( VAR7 , VAR8 , VAR25 ) ; } if ( ! VAR4 -> VAR45 ) { FUN5 ( VAR7 , VAR4 -> VAR48 ) ; } FUN19 ( VAR4 ) ; return 0 ; } #0
111#111#"static FUN1 ( VAR1 ) * FUN2 ( char * VAR2 ) { FUN1 ( VAR3 ) * VAR4 = NULL ; FUN1 ( VAR1 ) * VAR5 = NULL , * VAR6 = NULL ; VAR7 * VAR8 = NULL ; VAR3 * VAR9 ; if ( ! ( VAR5 = FUN3 ( ) ) ) { FUN4 ( VAR10 , ) ) ) { FUN4 ( VAR10 , , VAR2 ) ; goto VAR11 ; } while ( FUN7 ( VAR4 ) ) { VAR9 = FUN8 ( VAR4 ) ; if ( VAR9 -> VAR12 != NULL ) { FUN9 ( VAR5 , VAR9 -> VAR12 ) ; VAR9 -> VAR12 = NULL ; } FUN10 ( VAR9 ) ; } if ( ! FUN11 ( VAR5 ) ) { FUN4 ( VAR10 , "" "" , VAR2 ) ; FUN12 ( VAR5 ) ; goto VAR11 ; } VAR6 = VAR5 ; VAR11 : FUN13 ( VAR8 ) ; FUN14 ( VAR4 ) ; return ( VAR6 ) ; } "#1
112#112#"void FUN1 ( VAR1 * VAR2 , int64_t VAR3 ) { int VAR4 , VAR5 ; int64_t VAR6 = 0 ; const char * VAR7 = FUN2 ( VAR2 -> VAR8 ) ; if ( ! ( strcmp ( VAR7 , ) && strcmp ( VAR7 , VAR30 "" "" , VAR6 ) ; FUN6 ( VAR2 -> VAR27 , VAR6 ) ; VAR2 -> VAR27 -> VAR31 = FUN4 ( VAR2 -> VAR27 -> VAR31 , VAR6 / 2 ) ; } } "#1
113#113#static int FUN1 ( const void * VAR1 , int VAR2 , double VAR3 ) { int VAR4 , VAR5 , VAR6 , VAR7 ; long VAR8 [ 2 ] ; unsigned char VAR9 [ VAR10 ] ; VAR11 * VAR12 ; int VAR13 ; int VAR14 = 0 ; VAR15 * VAR16 = & VAR17 ; if ( ! VAR2 ) return 1 ; VAR12 = FUN2 ( ) ; if ( VAR12 == NULL ) goto VAR18 ; if ( ! FUN3 ( & VAR19 , VAR20 ) ) goto VAR18 ; if ( VAR21 ) { CRYPTO_THREAD_ID VAR22 = FUN4 ( ) ; FUN5 ( VAR23 ) ; VAR13 = FUN6 ( VAR24 , VAR22 ) ; FUN7 ( VAR23 ) ; } else VAR13 = 0 ; if ( ! VAR13 ) FUN8 ( VAR25 ) ; VAR7 = VAR16 -> VAR26 ; VAR8 [ 0 ] = VAR16 -> VAR27 [ 0 ] ; VAR8 [ 1 ] = VAR16 -> VAR27 [ 1 ] ; memcpy ( VAR9 , VAR16 -> VAR28 , sizeof ( VAR16 -> VAR28 ) ) ; VAR16 -> VAR26 += VAR2 ; if ( VAR16 -> VAR26 >= VAR29 ) { VAR16 -> VAR26 %= VAR29 ; VAR16 -> VAR2 = VAR29 ; } else if ( VAR16 -> VAR2 < VAR29 ) { if ( VAR16 -> VAR26 > VAR16 -> VAR2 ) VAR16 -> VAR2 = VAR16 -> VAR26 ; } VAR16 -> VAR27 [ 1 ] += ( VAR2 / VAR10 ) + ( VAR2 % VAR10 > 0 ) ; if ( ! VAR13 ) FUN7 ( VAR25 ) ; for ( VAR4 = 0 ; VAR4 < VAR2 ; VAR4 += VAR10 ) { VAR5 = ( VAR2 - VAR4 ) ; VAR5 = ( VAR5 > VAR10 ) ? VAR10 : VAR5 ; if ( ! EVP_DigestInit_ex ( VAR12 , FUN9 ( ) , NULL ) ) goto VAR18 ; if ( ! EVP_DigestUpdate ( VAR12 , VAR9 , VAR10 ) ) goto VAR18 ; VAR6 = ( VAR7 + VAR5 ) - VAR29 ; if ( VAR6 > 0 ) { if ( ! EVP_DigestUpdate ( VAR12 , & VAR16 -> VAR30 [ VAR7 ] , VAR5 - VAR6 ) ) goto VAR18 ; if ( ! EVP_DigestUpdate ( VAR12 , & VAR16 -> VAR30 [ 0 ] , VAR6 ) ) goto VAR18 ; } else if ( ! EVP_DigestUpdate ( VAR12 , & VAR16 -> VAR30 [ VAR7 ] , VAR5 ) ) goto VAR18 ; if ( ! EVP_DigestUpdate ( VAR12 , VAR1 , VAR5 ) ) goto VAR18 ; if ( ! EVP_DigestUpdate ( VAR12 , ( unsigned char * ) VAR8 , sizeof ( VAR8 ) ) ) goto VAR18 ; if ( ! FUN10 ( VAR12 , VAR9 , NULL ) ) goto VAR18 ; VAR8 [ 1 ] ++ ; VAR1 = ( const char * ) VAR1 + VAR5 ; for ( VAR6 = 0 ; VAR6 < VAR5 ; VAR6 ++ ) { VAR16 -> VAR30 [ VAR7 ++ ] ^= VAR9 [ VAR6 ] ; if ( VAR7 >= VAR29 ) VAR7 = 0 ; } } if ( ! VAR13 ) FUN8 ( VAR25 ) ; for ( VAR6 = 0 ; VAR6 < ( int ) sizeof ( VAR16 -> VAR28 ) ; VAR6 ++ ) { VAR16 -> VAR28 [ VAR6 ] ^= VAR9 [ VAR6 ] ; } if ( VAR31 < VAR32 ) VAR31 += VAR3 ; if ( ! VAR13 ) FUN7 ( VAR25 ) ; VAR14 = 1 ; VAR18 : FUN11 ( VAR12 ) ; return VAR14 ; } #1
114#114#static inline int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 = FUN2 ( & VAR2 -> VAR5 , VAR6 . VAR7 , VAR8 , 1 ) ; if ( VAR4 == 15 ) return VAR9 [ FUN3 ( & VAR2 -> VAR5 , 8 - VAR2 -> VAR10 ) ] ; else return VAR3 + ( ( VAR4 - 7U ) << VAR2 -> VAR10 ) ; } #0
115#115#static VAR1 FUN1 ( VAR2 * VAR3 , int VAR4 , int VAR5 , VAR6 * VAR7 , int VAR8 , int VAR9 ) { int VAR10 ; uint64_t VAR11 [ VAR12 + 1 ] ; int VAR13 ; RiceContext VAR14 ; uint64_t VAR15 [ VAR12 + 1 ] [ VAR16 ] = { { 0 } } ; assert ( VAR4 >= 0 && VAR4 <= VAR12 ) ; assert ( VAR5 >= 0 && VAR5 <= VAR12 ) ; assert ( VAR4 <= VAR5 ) ; VAR14 . VAR17 = VAR3 -> VAR17 ; for ( VAR10 = 0 ; VAR10 < VAR8 ; VAR10 ++ ) VAR3 -> VAR18 [ VAR10 ] = ( 2 * VAR7 [ VAR10 ] ) ^ ( VAR7 [ VAR10 ] >> 31 ) ; FUN2 ( VAR4 , VAR5 , VAR3 -> VAR18 , VAR8 , VAR9 , VAR15 ) ; VAR13 = VAR4 ; VAR11 [ VAR4 ] = VAR19 ; for ( VAR10 = VAR4 ; VAR10 <= VAR5 ; VAR10 ++ ) { VAR11 [ VAR10 ] = FUN3 ( & VAR14 , VAR10 , VAR15 [ VAR10 ] , VAR8 , VAR9 ) ; if ( VAR11 [ VAR10 ] <= VAR11 [ VAR13 ] ) { VAR13 = VAR10 ; * VAR3 = VAR14 ; } } return VAR11 [ VAR13 ] ; } #0
116#116#"VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { unsigned int VAR6 ; unsigned long VAR7 , VAR8 = 0 ; unsigned int VAR9 ; VAR10 * VAR11 = NULL ; PACKET VAR12 ; FUN2 ( & VAR12 ) ; if ( ! FUN3 ( VAR5 , & VAR7 ) || ( FUN4 ( VAR3 ) && ( ! FUN3 ( VAR5 , & VAR8 ) || ! FUN5 ( VAR5 , & VAR12 ) ) ) || ! FUN6 ( VAR5 , & VAR6 ) || ( FUN4 ( VAR3 ) ? ( VAR6 == 0 || FUN7 ( VAR5 ) < VAR6 ) : FUN7 ( VAR5 ) != VAR6 ) ) { FUN8 ( VAR3 , VAR13 , VAR14 , VAR15 ) ; goto VAR16 ; } if ( VAR6 == 0 ) return VAR17 ; if ( FUN4 ( VAR3 ) || VAR3 -> VAR18 -> VAR19 > 0 ) { VAR20 * VAR21 ; if ( ( VAR21 = FUN9 ( VAR3 -> VAR18 , 0 ) ) == 0 ) { FUN8 ( VAR3 , VAR22 , VAR14 , VAR23 ) ; goto VAR16 ; } if ( ( VAR3 -> VAR24 -> VAR25 & VAR26 ) != 0 && ! FUN4 ( VAR3 ) ) { FUN10 ( VAR3 -> VAR24 , VAR3 -> VAR18 ) ; } FUN11 ( VAR3 -> VAR18 ) ; VAR3 -> VAR18 = VAR21 ; } VAR3 -> VAR18 -> VAR27 = ( long ) FUN12 ( NULL ) ; FUN13 ( VAR3 -> VAR18 -> VAR28 . VAR29 ) ; VAR3 -> VAR18 -> VAR28 . VAR29 = NULL ; VAR3 -> VAR18 -> VAR28 . VAR6 = 0 ; VAR3 -> VAR18 -> VAR28 . VAR29 = FUN14 ( VAR6 ) ; if ( VAR3 -> VAR18 -> VAR28 . VAR29 == NULL ) { FUN8 ( VAR3 , VAR22 , VAR14 , VAR23 ) ; goto VAR16 ; } if ( ! FUN15 ( VAR5 , VAR3 -> VAR18 -> VAR28 . VAR29 , VAR6 ) ) { FUN8 ( VAR3 , VAR13 , VAR14 , VAR15 ) ; goto VAR16 ; } VAR3 -> VAR18 -> VAR28 . VAR30 = VAR7 ; VAR3 -> VAR18 -> VAR28 . VAR31 = VAR8 ; VAR3 -> VAR18 -> VAR28 . VAR6 = VAR6 ; if ( FUN4 ( VAR3 ) ) { PACKET VAR32 ; if ( ! FUN16 ( VAR5 , & VAR32 ) || FUN7 ( VAR5 ) != 0 ) { FUN8 ( VAR3 , VAR13 , VAR14 , VAR15 ) ; goto VAR16 ; } if ( ! FUN17 ( VAR3 , & VAR32 , VAR33 , & VAR11 , NULL , 1 ) || ! FUN18 ( VAR3 , VAR33 , VAR11 , NULL , 0 , 1 ) ) { goto VAR16 ; } } if ( ! FUN19 ( VAR3 -> VAR18 -> VAR28 . VAR29 , VAR6 , VAR3 -> VAR18 -> VAR34 , & VAR9 , FUN20 ( ) , NULL ) ) { FUN8 ( VAR3 , VAR22 , VAR14 , VAR35 ) ; goto VAR16 ; } VAR3 -> VAR18 -> VAR19 = VAR9 ; VAR3 -> VAR18 -> VAR36 = 0 ; if ( FUN4 ( VAR3 ) ) { const VAR37 * VAR38 = FUN21 ( VAR3 ) ; int VAR39 = FUN22 ( VAR38 ) ; size_t VAR40 ; static const unsigned char VAR41 [ ] = "" "" ; if ( ! FUN23 ( VAR39 >= 0 ) ) { FUN8 ( VAR3 , VAR22 , VAR14 , VAR42 ) ; goto VAR16 ; } VAR40 = ( VAR43 ) VAR39 ; if ( ! FUN24 ( VAR3 , VAR38 , VAR3 -> VAR44 , VAR41 , sizeof ( VAR41 ) - 1 , FUN25 ( & VAR12 ) , FUN7 ( & VAR12 ) , VAR3 -> VAR18 -> VAR45 , VAR40 , 1 ) ) { goto VAR16 ; } VAR3 -> VAR18 -> VAR46 = VAR40 ; FUN13 ( VAR11 ) ; FUN26 ( VAR3 , VAR26 ) ; return VAR47 ; } return VAR17 ; VAR16 : FUN13 ( VAR11 ) ; return VAR48 ; } "#0
117#117#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = NULL ; int VAR7 = 0 ; int VAR8 = 0 ; int VAR9 ; if ( FUN2 ( VAR2 ) ) { int VAR10 ; if ( ! FUN3 ( VAR2 , VAR11 , VAR12 , VAR4 -> VAR13 , NULL , 0 , & VAR10 ) ) return -1 ; VAR6 = VAR2 -> VAR14 ; } else { VAR9 = FUN4 ( VAR2 , VAR4 , & VAR6 ) ; switch ( VAR9 ) { case -1 : VAR7 = 1 ; goto VAR15 ; case 0 : case 1 : VAR8 = 1 ; break ; case 2 : case 3 : break ; default : FUN5 ( ) ; } } if ( VAR8 && VAR6 == NULL && ! ( VAR2 -> VAR16 -> VAR17 & VAR18 ) ) { SSL_SESSION VAR19 ; VAR19 . VAR20 = VAR2 -> VAR21 ; memset ( VAR19 . VAR22 , 0 , sizeof ( VAR19 . VAR22 ) ) ; memcpy ( VAR19 . VAR22 , VAR4 -> VAR22 , VAR4 -> VAR23 ) ; VAR19 . VAR24 = VAR4 -> VAR23 ; FUN6 ( VAR2 -> VAR16 -> VAR25 ) ; VAR6 = FUN7 ( VAR2 -> VAR16 -> VAR26 , & VAR19 ) ; if ( VAR6 != NULL ) { FUN8 ( VAR6 ) ; } FUN9 ( VAR2 -> VAR16 -> VAR25 ) ; if ( VAR6 == NULL ) VAR2 -> VAR16 -> VAR27 . VAR28 ++ ; } if ( VAR8 && VAR6 == NULL && VAR2 -> VAR16 -> VAR29 != NULL ) { int copy = 1 ; VAR6 = VAR2 -> VAR16 -> FUN10 ( VAR2 , VAR4 -> VAR22 , VAR4 -> VAR23 , & copy ) ; if ( VAR6 != NULL ) { VAR2 -> VAR16 -> VAR27 . VAR30 ++ ; if ( copy ) FUN8 ( VAR6 ) ; if ( ! ( VAR2 -> VAR16 -> VAR17 & VAR31 ) ) { if ( FUN11 ( VAR2 -> VAR16 , VAR6 ) ) goto VAR15 ; } } } if ( VAR6 == NULL ) goto VAR15 ; if ( VAR6 -> VAR20 != VAR2 -> VAR21 ) goto VAR15 ; if ( VAR6 -> VAR32 != VAR2 -> VAR32 || memcmp ( VAR6 -> VAR33 , VAR2 -> VAR33 , VAR6 -> VAR32 ) ) { goto VAR15 ; } if ( ( VAR2 -> VAR34 & VAR35 ) && VAR2 -> VAR32 == 0 ) { FUN12 ( VAR36 , VAR37 ) ; VAR7 = 1 ; goto VAR15 ; } if ( VAR6 -> VAR38 == NULL ) { unsigned char VAR39 [ 5 ] , * VAR40 ; unsigned long VAR41 ; VAR40 = VAR39 ; VAR41 = VAR6 -> VAR42 ; FUN13 ( VAR41 , VAR40 ) ; if ( ( VAR6 -> VAR20 >> 8 ) >= VAR43 ) VAR6 -> VAR38 = FUN14 ( VAR2 , & ( VAR39 [ 2 ] ) ) ; else VAR6 -> VAR38 = FUN14 ( VAR2 , & ( VAR39 [ 1 ] ) ) ; if ( VAR6 -> VAR38 == NULL ) goto VAR15 ; } if ( VAR6 -> VAR44 < ( long ) ( FUN15 ( NULL ) - VAR6 -> VAR45 ) ) { VAR2 -> VAR16 -> VAR27 . VAR46 ++ ; if ( VAR8 ) { FUN16 ( VAR2 -> VAR16 , VAR6 ) ; } goto VAR15 ; } if ( VAR6 -> VAR47 & VAR48 ) { if ( ! ( VAR2 -> VAR49 -> VAR47 & VAR50 ) ) { FUN12 ( VAR36 , VAR51 ) ; FUN17 ( VAR2 , VAR52 , VAR53 ) ; VAR7 = 1 ; goto VAR15 ; } } else if ( VAR2 -> VAR49 -> VAR47 & VAR50 ) { goto VAR15 ; } if ( ! FUN2 ( VAR2 ) ) { FUN18 ( VAR2 -> VAR14 ) ; VAR2 -> VAR14 = VAR6 ; } VAR2 -> VAR16 -> VAR27 . VAR54 ++ ; VAR2 -> VAR55 = VAR2 -> VAR14 -> VAR55 ; return 1 ; VAR15 : if ( VAR6 != NULL ) { FUN18 ( VAR6 ) ; if ( FUN2 ( VAR2 ) ) VAR2 -> VAR14 = NULL ; if ( ! VAR8 ) { VAR2 -> VAR56 . VAR57 = 1 ; } } if ( VAR7 ) return -1 ; else return 0 ; } #1
118#118#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 -> VAR10 [ VAR6 -> VAR11 ] -> VAR12 ; VAR6 -> VAR13 = VAR8 -> VAR14 ; if ( VAR4 -> VAR15 <= 0 || FUN2 ( VAR4 -> VAR16 ) <= 0 ) return FUN3 ( VAR17 ) ; VAR8 -> VAR14 += VAR6 -> VAR18 / ( VAR4 -> VAR15 * ( VAR19 ) FUN2 ( VAR4 -> VAR16 ) / 8 ) ; return 0 ; } #0
119#119#static int FUN1 ( VAR1 * VAR2 ) { const char * VAR3 = VAR2 -> VAR4 ; const char * VAR5 = VAR2 -> VAR4 + VAR2 -> VAR6 ; if ( FUN2 ( VAR3 ) == 0xEFBBBF ) VAR3 += 3 ; while ( VAR3 < VAR5 ) { while ( FUN3 ( * VAR3 ) ) VAR3 ++ ; if ( * VAR3 != ' ' && * VAR3 != ' ' ) { if ( FUN4 ( VAR3 ) ) return VAR7 + 1 ; return 0 ; } VAR3 += FUN5 ( VAR3 ) ; } return 0 ; } #0
120#120#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR3 * VAR5 , const VAR3 * VAR6 , int VAR7 , int VAR8 ) { int VAR9 = 0 ; int VAR10 ; uint8_t VAR11 = 0 ; const VAR3 * VAR12 = VAR5 ; uint8_t VAR13 = - ( VAR8 < 2 ) ; uint8_t VAR14 = - ( VAR8 < 3 ) ; VAR3 * VAR15 = VAR4 + ( VAR7 - 2 ) ; FUN2 ( VAR2 -> VAR16 , ) ; return VAR20 ; } memset ( VAR4 , 0 , VAR10 ) ; VAR2 -> VAR18 -= VAR10 ; VAR4 += VAR10 ; } while ( VAR4 < VAR15 ) { VAR9 = 0 ; while ( ! VAR11 && VAR4 + VAR9 < VAR15 ) { VAR9 ++ ; if ( VAR9 + 2 >= VAR6 - VAR5 ) return VAR20 ; VAR11 = ! ( VAR5 [ VAR9 ] | ( VAR5 [ VAR9 + 1 ] & VAR13 ) | ( VAR5 [ VAR9 + 2 ] & VAR14 ) ) ; } if ( VAR11 ) { VAR11 = 0 ; VAR9 += VAR8 ; memcpy ( VAR4 , VAR5 , VAR9 ) ; VAR4 += VAR9 ; VAR2 -> VAR18 = FUN5 ( VAR5 [ VAR9 ] ) ; VAR5 += VAR9 + 1 ; goto VAR17 ; } else { memcpy ( VAR4 , VAR5 , VAR9 ) ; VAR5 += VAR9 ; VAR4 += VAR9 ; } } return VAR5 - VAR12 ; } #0
121#121#VAR1 * FUN1 ( void ) { VAR1 * VAR2 ; VAR2 = FUN2 ( sizeof ( VAR1 ) ) ; memset ( VAR2 , 0 , sizeof ( VAR1 ) ) ; FUN3 ( VAR2 ) ; return VAR2 ; } #1
122#122#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 , VAR7 , VAR8 ; int VAR9 , VAR10 ; int VAR11 ; VAR6 = VAR2 -> VAR12 ; VAR2 -> VAR12 >>= VAR13 ; VAR7 = VAR2 -> VAR14 / VAR2 -> VAR12 ; VAR11 = VAR7 >> VAR15 ; VAR8 = VAR4 -> VAR16 [ VAR11 ] ; VAR10 = VAR9 = VAR4 -> VAR16 [ VAR11 + 1 ] + 1 ; while ( VAR10 > VAR8 + 1 ) { VAR11 = ( VAR10 + VAR8 ) >> 1 ; if ( VAR4 -> VAR17 [ VAR11 ] <= VAR7 ) { VAR10 = VAR9 ; VAR8 = VAR11 ; } else { VAR10 = ( VAR10 + VAR8 ) >> 1 ; VAR9 = VAR11 ; } } VAR5 = VAR4 -> VAR17 [ VAR8 ] * VAR2 -> VAR12 ; if ( VAR8 != 255 ) VAR6 = VAR4 -> VAR17 [ VAR8 + 1 ] * VAR2 -> VAR12 ; VAR2 -> VAR14 -= VAR5 ; VAR2 -> VAR12 = VAR6 - VAR5 ; if ( VAR2 -> VAR12 < VAR18 ) FUN2 ( VAR2 ) ; FUN3 ( VAR4 , VAR8 ) ; return VAR8 ; } #1
123#123#"int FUN1 ( VAR1 * VAR2 , void * VAR3 , uint32 VAR4 , uint16 VAR5 ) { static const char VAR6 [ ] = VAR19 , ( unsigned long ) VAR5 , ( unsigned long ) VAR8 -> VAR20 ) ; return ( -1 ) ; } VAR11 = VAR5 * VAR8 -> VAR21 + VAR4 / VAR8 -> VAR22 ; } else VAR11 = VAR4 / VAR8 -> VAR22 ; if ( VAR11 >= VAR8 -> VAR23 && ! FUN5 ( VAR2 , 1 , VAR6 ) ) return ( -1 ) ; if ( VAR11 != VAR2 -> VAR24 ) { if ( ! FUN6 ( VAR2 ) ) return ( -1 ) ; VAR2 -> VAR24 = VAR11 ; if ( VAR11 >= VAR8 -> VAR21 && VAR10 ) VAR8 -> VAR21 = FUN7 ( VAR8 -> VAR15 , VAR8 -> VAR22 ) ; if ( VAR8 -> VAR21 == 0 ) { FUN4 ( VAR2 -> VAR18 , VAR6 , "" "" ) ; return ( -1 ) ; } VAR2 -> VAR25 = ( VAR11 % VAR8 -> VAR21 ) * VAR8 -> VAR22 ; if ( ( VAR2 -> VAR12 & VAR26 ) == 0 ) { if ( ! ( * VAR2 -> VAR27 ) ( VAR2 ) ) return ( -1 ) ; VAR2 -> VAR12 |= VAR26 ; } VAR2 -> VAR28 = 0 ; VAR2 -> VAR29 = VAR2 -> VAR30 ; if ( VAR8 -> VAR31 [ VAR11 ] > 0 ) { VAR8 -> VAR31 [ VAR11 ] = 0 ; VAR2 -> VAR32 = 0 ; } if ( ! ( * VAR2 -> VAR33 ) ( VAR2 , VAR5 ) ) return ( -1 ) ; VAR2 -> VAR12 |= VAR34 ; } if ( VAR4 != VAR2 -> VAR25 ) { if ( VAR4 < VAR2 -> VAR25 ) { VAR2 -> VAR25 = ( VAR11 % VAR8 -> VAR21 ) * VAR8 -> VAR22 ; VAR2 -> VAR29 = VAR2 -> VAR30 ; } if ( ! ( * VAR2 -> VAR35 ) ( VAR2 , VAR4 - VAR2 -> VAR25 ) ) return ( -1 ) ; VAR2 -> VAR25 = VAR4 ; } VAR2 -> FUN8 ( VAR2 , ( VAR36 * ) VAR3 , VAR2 -> VAR37 ) ; VAR9 = ( * VAR2 -> VAR38 ) ( VAR2 , ( VAR36 * ) VAR3 , VAR2 -> VAR37 , VAR5 ) ; VAR2 -> VAR25 = VAR4 + 1 ; return ( VAR9 ) ; } "#0
124#124#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { struct VAR5 * VAR6 = FUN2 ( VAR2 ) ; VAR7 * VAR8 = NULL ; if ( VAR6 -> VAR9 == VAR10 ) { FUN3 ( VAR11 , VAR12 ) ; return 0 ; } VAR8 = FUN4 ( ) ; if ( ! FUN5 ( VAR8 , VAR6 -> VAR9 ) ) { FUN6 ( VAR8 ) ; return 0 ; } FUN7 ( VAR8 ) ; FUN8 ( VAR4 , VAR13 , VAR8 ) ; return 1 ; } #0
125#125#"int FUN1 ( VAR1 * VAR2 , uint32 VAR3 ) { static const char VAR4 [ ] = , ( unsigned __int64 ) VAR10 , ( unsigned long ) VAR3 ) ; #else FUN4(VAR2->VAR16, VAR4, , (unsigned __int64) VAR10, (unsigned long) VAR3, (unsigned __int64) VAR18); #else FUN4(VAR2->VAR16, VAR4,   ); return(0); } if (VAR32 > VAR2->VAR26) { VAR2->VAR20 = VAR21; if ((VAR2->VAR8 & VAR24) == 0) { FUN4(VAR2->VAR16, VAR4, """", (unsigned long) VAR3); return (0); } } if (VAR2->VAR8&VAR31) { VAR2->VAR20 = VAR21; VAR2->VAR25 = NULL; VAR2->VAR26 = 0; VAR2->VAR8 &= ~VAR31; }  if( FUN7(VAR2) ) { if (VAR32 > VAR2->VAR26 && !FUN11(VAR2, 0, VAR32)) { return (0); } if (FUN12(VAR2, VAR3, VAR2->VAR25, VAR32, VAR4) != VAR32) { return (0); } } else { if (FUN13(VAR2, VAR3, 1, VAR32, VAR4) != VAR32) { return (0); } }   VAR2->VAR29 = 0; VAR2->VAR30 = VAR32;  if (!FUN9(VAR2, VAR6->VAR22) && (VAR2->VAR8 & VAR23) == 0) FUN14(VAR2->VAR25, VAR32); } } return (FUN15(VAR2, VAR3)); } "#0
126#126#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 ) { int VAR7 ; int VAR8 ; for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 += 4 ) { VAR8 = FUN2 ( VAR2 + 2 * VAR3 , VAR4 , VAR6 ) ; if ( VAR8 ) { FUN2 ( VAR2 + 0 * VAR3 , VAR4 , VAR6 ) ; FUN2 ( VAR2 + 1 * VAR3 , VAR4 , VAR6 ) ; FUN2 ( VAR2 + 3 * VAR3 , VAR4 , VAR6 ) ; } VAR2 += VAR3 * 4 ; } } #1
127#127#int FUN1 ( VAR1 * VAR2 , int VAR3 , enum RDFTransformType VAR4 ) { int VAR5 = 1 << VAR3 ; int VAR6 ; VAR2 -> VAR3 = VAR3 ; VAR2 -> VAR7 = VAR4 == VAR8 || VAR4 == VAR9 ; VAR2 -> VAR10 = VAR4 == VAR11 || VAR4 == VAR9 ? 1 : -1 ; VAR2 -> VAR12 = VAR4 == VAR9 || VAR4 == VAR13 ; if ( VAR3 < 4 || VAR3 > 16 ) return FUN2 ( VAR14 ) ; if ( ( VAR6 = FUN3 ( & VAR2 -> VAR15 , VAR3 - 1 , VAR4 == VAR8 || VAR4 == VAR11 ) ) < 0 ) return VAR6 ; FUN4 ( VAR3 ) ; VAR2 -> VAR16 = VAR17 [ VAR3 ] ; VAR2 -> VAR18 = VAR17 [ VAR3 ] + ( VAR5 >> 2 ) ; VAR2 -> VAR19 = VAR20 ; if ( VAR21 ) FUN5 ( VAR2 ) ; return 0 ; } #0
128#128#static unsigned FUN1 ( VAR1 * VAR2 , int VAR3 ) { unsigned VAR4 = VAR3 ? FUN2 ( VAR2 ) : FUN3 ( VAR2 ) ; return VAR4 ; } #0
129#129#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , VAR3 * VAR6 , int VAR7 , int VAR8 , enum TiffCompr VAR9 , int VAR10 ) { int VAR11 ; GetBitContext VAR12 ; int * VAR13 , * VAR14 = NULL , * VAR15 ; int VAR16 ; int VAR17 = VAR2 -> VAR18 + 2 ; int VAR19 = 0 ; VAR13 = FUN2 ( VAR17 * sizeof ( VAR13 [ 0 ] ) ) ; VAR14 = FUN2 ( VAR17 * sizeof ( VAR14 [ 0 ] ) ) ; if ( ! VAR13 || ! VAR14 ) { VAR19 = FUN3 ( VAR20 ) ; goto VAR21 ; } VAR14 [ 0 ] = VAR2 -> VAR18 ; VAR14 [ 1 ] = 0 ; VAR14 [ 2 ] = 0 ; FUN4 ( & VAR12 , VAR4 , VAR5 * 8 ) ; for ( VAR11 = 0 ; VAR11 < VAR7 ; VAR11 ++ ) { VAR15 = VAR13 + VAR17 ; if ( VAR9 == VAR22 ) { VAR16 = FUN5 ( VAR2 , & VAR12 , VAR2 -> VAR18 , VAR13 , VAR15 , VAR14 ) ; if ( VAR16 < 0 ) { VAR19 = -1 ; goto VAR21 ; } } else { int VAR23 = ( VAR9 == VAR24 ) && ! ( VAR10 & 1 ) ; if ( VAR9 != VAR25 && FUN6 ( & VAR12 , VAR5 * 8 ) < 0 ) break ; if ( VAR9 == VAR25 || VAR23 || FUN7 ( & VAR12 ) ) VAR16 = FUN8 ( VAR2 , & VAR12 , VAR2 -> VAR18 , VAR13 , VAR15 ) ; else VAR16 = FUN5 ( VAR2 , & VAR12 , VAR2 -> VAR18 , VAR13 , VAR15 , VAR14 ) ; if ( VAR9 == VAR25 ) FUN9 ( & VAR12 ) ; } if ( VAR16 < 0 ) { FUN10 ( VAR6 , VAR8 , VAR2 -> VAR18 , VAR14 ) ; } else { FUN10 ( VAR6 , VAR8 , VAR2 -> VAR18 , VAR13 ) ; FUN11 ( int * , VAR13 , VAR14 ) ; } VAR6 += VAR8 ; } VAR21 : FUN12 ( VAR13 ) ; FUN12 ( VAR14 ) ; return VAR19 ; } #0
130#130#static int FUN1 ( VAR1 * VAR2 , const char * VAR3 , int VAR4 ) { int VAR5 = -1 ; int VAR6 ; VAR7 * VAR8 = ( VAR7 * ) VAR2 -> VAR9 ; if ( VAR3 == NULL ) { FUN2 ( VAR10 , VAR11 ) ; goto VAR12 ; } if ( VAR2 -> VAR13 & VAR14 ) { FUN2 ( VAR10 , VAR15 ) ; goto VAR12 ; } FUN3 ( VAR2 ) ; VAR6 = VAR8 -> VAR16 -> VAR17 ; FUN4 ( VAR2 ) ; if ( FUN5 ( VAR8 -> VAR18 , VAR6 + VAR4 ) == 0 ) goto VAR12 ; memcpy ( VAR8 -> VAR18 -> VAR19 + VAR6 , VAR3 , VAR4 ) ; * VAR8 -> VAR16 = * VAR8 -> VAR18 ; VAR5 = VAR4 ; VAR12 : return ( VAR5 ) ; } #0
131#131#"static const char * FUN1 ( VAR1 * VAR2 , char * VAR3 ) { const char * VAR4 ; if ( ( VAR4 = FUN2 ( VAR2 -> VAR5 , , & VAR7 ) ) ) { char * VAR11 = FUN4 ( VAR6 , ) ; while ( VAR13 >= VAR11 && FUN5 ( * VAR13 ) ) { * VAR13 = ' ' ; -- VAR13 ; } if ( ! FUN6 ( VAR11 , VAR3 ) ) { VAR13 = VAR7 - ( * VAR7 ? 2 : 1 ) ; VAR12 += strspn ( VAR12 , "" "" ) ; while ( VAR13 >= VAR12 && FUN5 ( * VAR13 ) ) { * VAR13 = ' ' ; -- VAR13 ; } return FUN7 ( VAR2 -> VAR10 , VAR12 ) ; } } VAR9 = NULL ; } } return NULL ; } "#0
132#132#int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 ; FUN2 ( ( unsigned ) VAR2 -> VAR5 <= VAR6 - VAR7 ) ; if ( ( unsigned ) VAR3 > VAR6 - ( VAR2 -> VAR5 + VAR7 ) ) return -1 ; VAR4 = VAR2 -> VAR5 + VAR3 + VAR7 ; if ( VAR2 -> VAR8 ) { size_t VAR9 ; VAR10 * VAR11 = VAR2 -> VAR12 ; if ( VAR2 -> VAR12 == NULL ) { VAR9 = 0 ; VAR2 -> VAR12 = VAR2 -> VAR8 -> VAR12 ; } else { VAR9 = VAR2 -> VAR12 - VAR2 -> VAR8 -> VAR12 ; if ( VAR9 > VAR6 - VAR4 ) return -1 ; } if ( VAR4 + VAR9 > VAR2 -> VAR8 -> VAR5 ) { int VAR13 = FUN3 ( & VAR2 -> VAR8 , VAR4 + VAR9 ) ; if ( VAR13 < 0 ) { VAR2 -> VAR12 = VAR11 ; return VAR13 ; } VAR2 -> VAR12 = VAR2 -> VAR8 -> VAR12 + VAR9 ; } } else { VAR2 -> VAR8 = FUN4 ( VAR4 ) ; if ( ! VAR2 -> VAR8 ) return FUN5 ( VAR14 ) ; if ( VAR2 -> VAR5 > 0 ) memcpy ( VAR2 -> VAR8 -> VAR12 , VAR2 -> VAR12 , VAR2 -> VAR5 ) ; VAR2 -> VAR12 = VAR2 -> VAR8 -> VAR12 ; } VAR2 -> VAR5 += VAR3 ; memset ( VAR2 -> VAR12 + VAR2 -> VAR5 , 0 , VAR7 ) ; return 0 ; } #0
133#133#"int FUN1 ( VAR1 * VAR2 , int VAR3 , const unsigned char * VAR4 , unsigned int VAR5 , int VAR6 ) { unsigned char * VAR7 , * VAR8 ; int VAR9 , VAR10 , VAR11 = 0 ; int VAR12 = 0 ; VAR13 * VAR14 ; VAR15 * VAR16 ; VAR17 * VAR18 ; int VAR19 ; if ( VAR2 -> VAR20 -> VAR21 . VAR22 != 0 ) { FUN2 ( 0 ) ; return ( FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 ) ) ; } if ( VAR2 -> VAR20 -> VAR23 ) { VAR9 = VAR2 -> VAR24 -> FUN4 ( VAR2 ) ; if ( VAR9 <= 0 ) return ( VAR9 ) ; } if ( VAR5 == 0 && ! VAR6 ) return 0 ; VAR14 = & ( VAR2 -> VAR20 -> VAR25 ) ; VAR16 = & ( VAR2 -> VAR20 -> VAR21 ) ; VAR18 = VAR2 -> VAR26 ; if ( ( VAR18 == NULL ) || ( VAR2 -> VAR27 == NULL ) || ( FUN5 ( VAR2 -> VAR28 ) == NULL ) ) VAR11 = 1 ; if ( VAR11 ) VAR10 = 0 ; else VAR10 = FUN6 ( VAR2 -> VAR28 ) ; #if 0 if ( ! VAR11 && ! VAR6 && ! VAR2 - > VAR20 - > VAR29 && FUN7 ( VAR2 ) != VAR30 ) { if ( VAR2 - > VAR20 - > VAR31 && VAR3 == VAR32 ) { VAR12 = VAR2 - > VAR24 - > FUN8 ( VAR2 , VAR3 , VAR4 , 0 , 1 ) ; if ( VAR12 <= 0 ) goto VAR33 ; if ( VAR2 - > VAR20 - > VAR21 . VAR5 < ( VAR34 ) VAR12 + VAR35 ) { FUN9 ( VAR36 , VAR37 ) ; goto VAR33 ; } } VAR2 - > VAR20 - > VAR29 = 1 ; } #endif VAR7 = VAR16->VAR4 + VAR12;    *(VAR7++)=VAR3&0xff; VAR14->VAR3=VAR3;  *(VAR7++)=(VAR2->VAR38>>8); *(VAR7++)=VAR2->VAR38&0xff;   VAR8=VAR7; VAR7+=10;     if ( VAR2->VAR27 && (FUN10( VAR2->VAR27->VAR39 ) & VAR40)) VAR19 = FUN11(VAR2->VAR27->VAR39); else VAR19 = 0;  VAR14->VAR41=VAR7 + VAR19;   VAR14->VAR42=(int)VAR5; VAR14->VAR43=(unsigned char *)VAR4;     if (VAR2->VAR44 != NULL) { if (!FUN12(VAR2)) { FUN9(VAR36,VAR45); goto VAR33; } } else { memcpy(VAR14->VAR41,VAR14->VAR43,VAR14->VAR42); VAR14->VAR43=VAR14->VAR41; }    if (VAR10 != 0) { VAR2->VAR24->VAR46->FUN13(VAR2,&(VAR7[VAR14->VAR42 + VAR19]),1); VAR14->VAR42+=VAR10; }   VAR14->VAR43=VAR7; VAR14->VAR41=VAR7;    VAR14->VAR42 += VAR19;   VAR2->VAR24->VAR46->FUN14(VAR2,1);       FUN15(VAR2->VAR47->VAR48, VAR8);     memcpy(VAR8, &(VAR2->VAR20->VAR49[2]), 6); VAR8+=6; FUN15(VAR14->VAR42,VAR8);   VAR14->VAR3=VAR3;  VAR14->VAR42+=VAR50;  #if 0    if ( VAR3 == VAR51 || VAR3 == VAR52) FUN16(VAR2, VAR14->VAR41, VAR14->VAR42, *((VAR53 *)&(VAR2->VAR20->VAR49[0]))); #endif  FUN17(&(VAR2->VAR20->VAR49[0]));  if (VAR6) {  return VAR14->VAR42; }   VAR16->VAR22 = VAR12 + VAR14->VAR42; VAR16->VAR54 = 0;   VAR2->VAR20->VAR55=VAR5; VAR2->VAR20->VAR56=VAR4; VAR2->VAR20->VAR57=VAR3; VAR2->VAR20->VAR58=VAR5;   return FUN3(VAR2,VAR3,VAR4,VAR5); VAR33: return -1; } "#1
134#134#static void FUN1 ( VAR1 * VAR2 ) { int VAR3 = 0 ; if ( VAR2 -> VAR4 ) return ; if ( VAR2 -> VAR5 ) { if ( VAR2 -> VAR6 > VAR2 -> VAR7 ) VAR2 -> VAR8 = VAR2 -> FUN2 ( VAR2 -> VAR8 , VAR2 -> VAR7 , VAR2 -> VAR6 - VAR2 -> VAR7 ) ; VAR2 -> VAR7 = VAR2 -> VAR9 ; } if ( VAR2 -> VAR10 ) VAR3 = VAR2 -> FUN3 ( VAR2 -> VAR11 , VAR2 -> VAR9 , VAR2 -> VAR12 ) ; if ( VAR3 <= 0 ) { VAR2 -> VAR4 = 1 ; if ( VAR3 < 0 ) VAR2 -> VAR13 = VAR3 ; } else { VAR2 -> VAR14 += VAR3 ; VAR2 -> VAR15 = VAR2 -> VAR9 ; VAR2 -> VAR6 = VAR2 -> VAR9 + VAR3 ; } } #1
135#135#static void FUN1 ( VAR1 ) ( VAR2 * VAR3 , VAR4 * VAR5 , ptrdiff_t VAR6 ) { int VAR7 , VAR8 ; VAR9 * VAR10 = ( VAR9 * ) VAR3 ; VAR6 /= sizeof ( VAR9 ) ; for ( VAR8 = 0 ; VAR8 < 4 ; VAR8 ++ ) { for ( VAR7 = 0 ; VAR7 < 4 ; VAR7 ++ ) { VAR10 [ VAR7 ] = FUN2 ( VAR10 [ VAR7 ] + * VAR5 ) ; VAR5 ++ ; } VAR10 += VAR6 ; } } #0
136#136#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 [ 3 ] , int VAR5 , int VAR6 , int VAR7 [ 3 ] ) { int VAR8 , VAR9 , VAR10 , VAR11 ; const int VAR12 = VAR2 -> VAR13 -> VAR14 ? 3 : 2 ; VAR15 * VAR16 [ 4 ] [ 3 ] ; int VAR17 = VAR2 -> VAR18 <= 8 ; int VAR19 = VAR2 -> VAR18 > 0 ? VAR2 -> VAR18 : 8 ; int VAR20 = 1 << VAR19 ; VAR2 -> VAR21 = 0 ; memset ( VAR2 -> VAR22 , 0 , VAR12 * VAR23 * ( VAR5 + 6 ) * sizeof ( * VAR2 -> VAR22 ) ) ; for ( VAR9 = 0 ; VAR9 < VAR6 ; VAR9 ++ ) { for ( VAR11 = 0 ; VAR11 < VAR12 ; VAR11 ++ ) for ( VAR10 = 0 ; VAR10 < VAR23 ; VAR10 ++ ) VAR16 [ VAR10 ] [ VAR11 ] = VAR2 -> VAR22 + VAR10 * VAR12 * ( VAR5 + 6 ) + ( ( VAR6 + VAR11 - VAR9 ) % VAR12 ) * ( VAR5 + 6 ) + 3 ; for ( VAR8 = 0 ; VAR8 < VAR5 ; VAR8 ++ ) { int VAR24 , VAR25 , VAR26 , FUN2 ( VAR27 ) ; if ( VAR17 ) { unsigned VAR28 = * ( ( VAR29 * ) ( VAR4 [ 0 ] + VAR8 * 4 + VAR7 [ 0 ] * VAR9 ) ) ; VAR24 = VAR28 & 0xFF ; VAR25 = ( VAR28 >> 8 ) & 0xFF ; VAR26 = ( VAR28 >> 16 ) & 0xFF ; VAR27 = VAR28 >> 24 ; } else { VAR24 = * ( ( VAR30 * ) ( VAR4 [ 0 ] + VAR8 * 2 + VAR7 [ 0 ] * VAR9 ) ) ; VAR25 = * ( ( VAR30 * ) ( VAR4 [ 1 ] + VAR8 * 2 + VAR7 [ 1 ] * VAR9 ) ) ; VAR26 = * ( ( VAR30 * ) ( VAR4 [ 2 ] + VAR8 * 2 + VAR7 [ 2 ] * VAR9 ) ) ; } if ( VAR2 -> VAR31 != 1 ) { VAR24 -= VAR25 ; VAR26 -= VAR25 ; VAR25 += ( VAR24 + VAR26 ) >> 2 ; VAR24 += VAR20 ; VAR26 += VAR20 ; } VAR16 [ 0 ] [ 0 ] [ VAR8 ] = VAR25 ; VAR16 [ 1 ] [ 0 ] [ VAR8 ] = VAR24 ; VAR16 [ 2 ] [ 0 ] [ VAR8 ] = VAR26 ; VAR16 [ 3 ] [ 0 ] [ VAR8 ] = VAR27 ; } for ( VAR10 = 0 ; VAR10 < 3 + VAR2 -> VAR32 ; VAR10 ++ ) { int VAR33 ; VAR16 [ VAR10 ] [ 0 ] [ -1 ] = VAR16 [ VAR10 ] [ 1 ] [ 0 ] ; VAR16 [ VAR10 ] [ 1 ] [ VAR5 ] = VAR16 [ VAR10 ] [ 1 ] [ VAR5 - 1 ] ; if ( VAR17 && VAR2 -> VAR31 == 0 ) VAR33 = FUN3 ( VAR2 , VAR5 , VAR16 [ VAR10 ] , ( VAR10 + 1 ) / 2 , 9 ) ; else VAR33 = FUN3 ( VAR2 , VAR5 , VAR16 [ VAR10 ] , ( VAR10 + 1 ) / 2 , VAR19 + ( VAR2 -> VAR31 != 1 ) ) ; if ( VAR33 < 0 ) return VAR33 ; } } return 0 ; } #0
137#137#static void FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 , VAR5 ; if ( ! VAR2 -> VAR6 ) VAR2 -> VAR7 . FUN2 ( VAR2 -> VAR8 [ 0 ] , 1 , VAR2 -> VAR9 , 16 , VAR3 ) ; VAR2 -> VAR7 . FUN2 ( VAR2 -> VAR8 [ 0 ] + 8 * VAR2 -> VAR9 , 1 , VAR2 -> VAR9 , 16 , VAR3 ) ; for ( VAR4 = ! VAR2 -> VAR10 * 8 ; VAR4 < 16 ; VAR4 += 8 ) VAR2 -> VAR7 . FUN2 ( VAR2 -> VAR8 [ 0 ] + VAR4 , VAR2 -> VAR9 , 1 , 16 , VAR3 ) ; for ( VAR5 = 0 ; VAR5 < 2 ; VAR5 ++ ) { if ( ! VAR2 -> VAR6 ) VAR2 -> VAR7 . FUN2 ( VAR2 -> VAR8 [ VAR5 + 1 ] , 1 , VAR2 -> VAR11 , 8 , VAR3 ) ; if ( VAR2 -> VAR10 ) VAR2 -> VAR7 . FUN2 ( VAR2 -> VAR8 [ VAR5 + 1 ] , VAR2 -> VAR11 , 1 , 8 , VAR3 ) ; } } #0
138#138#static av_noinline void FUN1 ( VAR1 ) ( const VAR2 * VAR3 , VAR4 * VAR5 ) { const int VAR6 = VAR5 -> VAR6 ; const int VAR7 = VAR5 -> VAR7 ; const int VAR8 = VAR5 -> VAR8 ; const int VAR9 = VAR3 -> VAR10 . VAR9 [ VAR8 ] ; VAR11 * VAR12 [ 3 ] ; int VAR13 ; int VAR14 , VAR15 , VAR16 ; const int * VAR17 = & VAR3 -> VAR17 [ 0 ] ; const int VAR18 = ! VAR19 && ( VAR5 -> VAR20 == 0 && VAR3 -> VAR21 . VAR22 -> VAR18 ) ; const int VAR23 = ( VAR19 || ! VAR24 || ! ( VAR3 -> VAR25 & VAR26 ) ) ? 3 : 1 ; for ( VAR16 = 0 ; VAR16 < VAR23 ; VAR16 ++ ) { VAR12 [ VAR16 ] = VAR3 -> VAR10 . VAR27 -> VAR28 [ VAR16 ] + ( ( VAR6 << VAR29 ) + VAR7 * VAR5 -> VAR13 ) * 16 ; VAR3 -> VAR30 . FUN2 ( VAR12 [ VAR16 ] + ( VAR5 -> VAR6 & 3 ) * 4 * VAR5 -> VAR13 + ( 64 << VAR29 ) , VAR5 -> VAR13 , 4 ) ; } VAR3 -> VAR31 [ VAR8 ] = VAR5 -> VAR32 ; if ( ! VAR19 && FUN3 ( VAR5 ) ) { VAR13 = VAR5 -> VAR33 = VAR5 -> VAR34 = VAR5 -> VAR13 * 2 ; VAR17 = & VAR3 -> VAR17 [ 48 ] ; if ( VAR7 & 1 ) for ( VAR16 = 0 ; VAR16 < 3 ; VAR16 ++ ) VAR12 [ VAR16 ] -= VAR5 -> VAR13 * 15 ; if ( FUN4 ( VAR3 ) ) { int VAR35 ; for ( VAR35 = 0 ; VAR35 < VAR5 -> VAR32 ; VAR35 ++ ) { if ( ! FUN5 ( VAR9 , VAR35 ) ) continue ; if ( FUN6 ( VAR9 ) ) { VAR36 * VAR37 = & VAR5 -> VAR38 [ VAR35 ] [ VAR39 [ 0 ] ] ; FUN7 ( VAR37 , 4 , 4 , 8 , ( 16 + * VAR37 ) ^ ( VAR5 -> VAR7 & 1 ) , 1 ) ; } else { for ( VAR14 = 0 ; VAR14 < 16 ; VAR14 += 4 ) { int VAR37 = VAR5 -> VAR38 [ VAR35 ] [ VAR39 [ VAR14 ] ] ; if ( VAR37 >= 0 ) FUN7 ( & VAR5 -> VAR38 [ VAR35 ] [ VAR39 [ VAR14 ] ] , 2 , 2 , 8 , ( 16 + VAR37 ) ^ ( VAR5 -> VAR7 & 1 ) , 1 ) ; } } } } } else { VAR13 = VAR5 -> VAR33 = VAR5 -> VAR34 = VAR5 -> VAR13 ; } if ( ! VAR19 && FUN8 ( VAR9 ) ) { if ( VAR29 ) { const int VAR40 = VAR3 -> VAR21 . VAR22 -> VAR41 ; GetBitContext VAR42 ; FUN9 ( & VAR42 , VAR5 -> VAR43 , 768 * VAR40 ) ; for ( VAR16 = 0 ; VAR16 < VAR23 ; VAR16 ++ ) for ( VAR14 = 0 ; VAR14 < 16 ; VAR14 ++ ) { VAR44 * VAR45 = ( VAR44 * ) ( VAR12 [ VAR16 ] + VAR14 * VAR13 ) ; for ( VAR15 = 0 ; VAR15 < 16 ; VAR15 ++ ) VAR45 [ VAR15 ] = FUN10 ( & VAR42 , VAR40 ) ; } } else { for ( VAR16 = 0 ; VAR16 < VAR23 ; VAR16 ++ ) for ( VAR14 = 0 ; VAR14 < 16 ; VAR14 ++ ) memcpy ( VAR12 [ VAR16 ] + VAR14 * VAR13 , VAR5 -> VAR43 + VAR16 * 256 + VAR14 * 16 , 16 ) ; } } else { if ( FUN11 ( VAR9 ) ) { if ( VAR5 -> VAR46 ) FUN12 ( VAR3 , VAR5 , VAR12 [ 0 ] , VAR12 [ 1 ] , VAR12 [ 2 ] , VAR13 , VAR13 , 1 , 1 , VAR19 , VAR29 ) ; for ( VAR16 = 0 ; VAR16 < VAR23 ; VAR16 ++ ) FUN13 ( VAR3 , VAR5 , VAR9 , VAR19 , VAR18 , VAR29 , VAR17 , VAR13 , VAR12 [ VAR16 ] , VAR16 ) ; if ( VAR5 -> VAR46 ) FUN12 ( VAR3 , VAR5 , VAR12 [ 0 ] , VAR12 [ 1 ] , VAR12 [ 2 ] , VAR13 , VAR13 , 0 , 1 , VAR19 , VAR29 ) ; } else { FUN1 ( VAR47 ) ( VAR3 , VAR5 , VAR12 [ 0 ] , VAR12 [ 1 ] , VAR12 [ 2 ] , VAR3 -> VAR48 , VAR3 -> VAR49 . VAR50 , VAR3 -> VAR51 , VAR3 -> VAR49 . VAR52 , VAR3 -> VAR53 . VAR54 , VAR3 -> VAR53 . VAR55 ) ; } for ( VAR16 = 0 ; VAR16 < VAR23 ; VAR16 ++ ) FUN14 ( VAR3 , VAR5 , VAR9 , VAR19 , VAR18 , VAR29 , VAR17 , VAR13 , VAR12 [ VAR16 ] , VAR16 ) ; } } #0
139#139#"static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { ngx_int_t VAR6 ; VAR7 * VAR8 ; VAR9 * VAR10 ; VAR8 = VAR3 -> VAR10 ; if ( VAR8 == NULL ) { if ( ! ( VAR3 -> VAR11 & VAR5 -> VAR12 -> VAR13 ) ) { return VAR14 ; } VAR6 = FUN2 ( VAR3 , VAR5 , & VAR10 ) ; if ( VAR6 != VAR15 ) { return VAR6 ; } if ( VAR3 -> VAR11 & VAR16 ) { VAR5 -> VAR11 = VAR17 ; } if ( FUN3 ( VAR3 ) != VAR15 ) { return VAR18 ; } if ( VAR5 -> FUN4 ( VAR3 ) != VAR15 ) { return VAR18 ; } FUN5 ( VAR3 ) ; if ( VAR3 -> VAR10 -> VAR19 + 256 >= VAR5 -> VAR12 -> VAR20 ) { FUN6 ( VAR21 , VAR3 -> VAR22 -> VAR23 , 0 , , & VAR5 -> VAR12 -> VAR24 , VAR5 -> VAR12 -> VAR20 , FUN7 ( VAR3 -> VAR10 -> VAR19 + 256 , 1024 ) ) ; VAR3 -> VAR10 = NULL ; return VAR14 ; } VAR5 -> VAR25 = 1 ; VAR8 = VAR3 -> VAR10 ; VAR8 -> VAR26 = VAR5 -> VAR12 -> VAR20 ; VAR8 -> VAR27 = VAR5 -> VAR12 -> VAR28 ; VAR8 -> VAR29 = VAR10 ; switch ( FUN8 ( VAR3 , VAR5 -> VAR12 -> VAR30 ) ) { case VAR18 : return VAR18 ; case VAR14 : VAR5 -> VAR31 = VAR32 ; return VAR14 ; default : break ; } VAR8 -> VAR33 = VAR5 -> VAR12 -> VAR34 ; VAR8 -> VAR35 = VAR5 -> VAR12 -> VAR36 ; VAR8 -> VAR37 = VAR5 -> VAR12 -> VAR38 ; VAR5 -> VAR31 = VAR39 ; } VAR6 = FUN9 ( VAR3 ) ; FUN10 ( VAR40 , VAR3 -> VAR22 -> VAR23 , 0 , "" "" , VAR6 ) ; switch ( VAR6 ) { case VAR41 : if ( VAR5 -> VAR12 -> VAR42 & VAR43 ) { VAR5 -> VAR31 = VAR6 ; VAR6 = VAR15 ; } else { VAR6 = VAR44 ; } break ; case VAR15 : VAR5 -> VAR31 = VAR45 ; } switch ( VAR6 ) { case VAR15 : return VAR15 ; case VAR44 : VAR8 -> VAR46 = 0 ; VAR5 -> VAR47 . VAR48 = NULL ; VAR5 -> VAR31 = VAR49 ; break ; case VAR14 : if ( ( VAR50 ) ( VAR5 -> VAR47 . VAR51 - VAR5 -> VAR47 . VAR48 ) < VAR5 -> VAR12 -> VAR20 ) { VAR5 -> VAR47 . VAR48 = NULL ; } else { VAR5 -> VAR47 . VAR52 = VAR5 -> VAR47 . VAR48 + VAR8 -> VAR19 ; VAR5 -> VAR47 . VAR53 = VAR5 -> VAR47 . VAR52 ; } break ; case VAR54 : VAR5 -> VAR25 = 0 ; break ; case VAR55 : return VAR56 ; case VAR18 : return VAR18 ; default : VAR5 -> VAR31 = VAR45 ; return VAR6 ; } VAR3 -> VAR57 = 0 ; return VAR14 ; } "#0
140#140#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , unsigned int VAR5 , VAR6 * * VAR7 , int * VAR8 ) { PACKET VAR9 = * VAR4 ; size_t VAR10 = 0 , VAR11 ; int VAR12 = 0 ; VAR13 * VAR14 = NULL ; VAR6 * VAR15 = NULL ; if ( ( VAR5 & VAR16 ) != 0 ) { VAR14 = & VAR2 -> VAR17 -> VAR18 ; FUN2 ( & VAR2 -> VAR17 -> VAR18 ) ; } else if ( ( VAR5 & VAR19 ) != 0 ) { VAR14 = & VAR2 -> VAR17 -> VAR20 ; } VAR15 = FUN3 ( ( FUN4 ( VAR21 ) + ( VAR14 != NULL ? VAR14 -> VAR22 : 0 ) ) * sizeof ( VAR6 ) ) ; if ( VAR15 == NULL ) { * VAR8 = VAR23 ; FUN5 ( VAR24 , VAR25 ) ; return 0 ; } while ( FUN6 ( & VAR9 ) > 0 ) { unsigned int VAR26 ; PACKET VAR27 ; if ( ! FUN7 ( & VAR9 , & VAR26 ) || ! FUN8 ( & VAR9 , & VAR27 ) ) { FUN5 ( VAR24 , VAR28 ) ; * VAR8 = VAR29 ; goto VAR30 ; } if ( ! FUN9 ( VAR2 , VAR5 , VAR26 , VAR14 , & VAR12 , & VAR11 ) || ( VAR12 == 1 && VAR15 [ VAR11 ] . VAR31 == 1 ) ) { FUN5 ( VAR24 , VAR28 ) ; * VAR8 = VAR32 ; goto VAR30 ; } if ( VAR12 ) { VAR15 [ VAR11 ] . VAR33 = VAR27 ; VAR15 [ VAR11 ] . VAR31 = 1 ; VAR15 [ VAR11 ] . VAR26 = VAR26 ; } } for ( VAR10 = 0 ; VAR10 < FUN4 ( VAR21 ) ; VAR10 ++ ) { if ( VAR21 [ VAR10 ] . VAR34 != NULL && ( VAR21 [ VAR10 ] . VAR5 & VAR5 ) != 0 && FUN10 ( VAR2 , VAR21 [ VAR10 ] . VAR5 , VAR5 ) && ! VAR21 [ VAR10 ] . FUN11 ( VAR2 , VAR5 ) ) { * VAR8 = VAR23 ; goto VAR30 ; } } * VAR7 = VAR15 ; return 1 ; VAR30 : FUN12 ( VAR15 ) ; return 0 ; } #0
141#141#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , ngx_int_t VAR5 ) { ngx_uint_t VAR6 ; FUN2 ( VAR7 , VAR2 -> VAR8 -> VAR9 , 0 , , VAR4 -> VAR22 . VAR8 -> VAR28 ) ; if ( VAR4 -> VAR22 . VAR8 -> VAR29 ) { FUN7 ( VAR4 -> VAR22 . VAR8 -> VAR29 ) ; } FUN8 ( VAR4 -> VAR22 . VAR8 ) ; } VAR4 -> VAR22 . VAR8 = NULL ; if ( VAR4 -> VAR17 && VAR4 -> VAR17 -> VAR30 ) { FUN2 ( VAR7 , VAR2 -> VAR8 -> VAR9 , 0 , % VAR39 ; if ( ! VAR4 -> VAR61 || VAR5 == VAR62 || VAR5 == VAR63 ) { FUN3 ( VAR2 , VAR5 ) ; return ; } VAR6 = 0 ; if ( VAR5 > = VAR53 ) { VAR5 = VAR64 ; VAR6 = 1 ; } if ( VAR2 -> VAR65 || ( VAR4 -> VAR17 && VAR4 -> VAR17 -> VAR66 ) ) { FUN3 ( VAR2 , VAR5 ) ; return ; } if ( VAR5 == 0 ) { VAR5 = FUN14 ( VAR2 , VAR67 ) ; } else if ( VAR6 ) { VAR2 -> VAR68 = 0 ; VAR5 = FUN14 ( VAR2 , VAR69 ) ; } FUN3 ( VAR2 , VAR5 ) ; } #0
142#142#FUN1 ( VAR1 ) FUN2 ( char * * VAR2 , apr_size_t VAR3 , VAR4 * read , VAR5 * VAR6 , int VAR7 , VAR8 * VAR9 ) { apr_status_t VAR10 ; VAR11 * VAR12 ; apr_size_t VAR13 = 0 , VAR14 = 0 ; char * VAR15 , * VAR16 = * VAR2 ; int VAR17 = ( * VAR2 == NULL ) , VAR18 = 0 ; int VAR19 = VAR7 & VAR20 ; int VAR21 = VAR7 & VAR22 ; if ( VAR16 ) * VAR16 = ' ' ; for ( ; ; ) { FUN3 ( VAR9 ) ; VAR10 = FUN4 ( VAR6 -> VAR23 , VAR9 , VAR24 , VAR25 , 0 ) ; if ( VAR10 != VAR26 ) { return VAR10 ; } if ( FUN5 ( VAR9 ) ) { return VAR27 ; } for ( VAR12 = FUN6 ( VAR9 ) ; VAR12 != FUN7 ( VAR9 ) ; VAR12 = FUN8 ( VAR12 ) ) { const char * VAR28 ; apr_size_t VAR29 ; if ( FUN9 ( VAR12 ) ) { VAR18 = 1 ; break ; } VAR10 = FUN10 ( VAR12 , & VAR28 , & VAR29 , VAR25 ) ; if ( VAR10 != VAR26 ) { return VAR10 ; } if ( VAR29 == 0 ) { continue ; } if ( VAR3 < VAR13 + VAR29 ) { * read = VAR13 ; if ( * VAR2 ) { if ( VAR13 > 0 ) { ( * VAR2 ) [ VAR13 - 1 ] = ' ' ; } else { ( * VAR2 ) [ 0 ] = ' ' ; } } return VAR30 ; } if ( VAR17 ) { if ( ! * VAR2 ) { VAR14 = VAR29 ; * VAR2 = FUN11 ( VAR6 -> VAR31 , VAR14 ) ; } else if ( VAR13 + VAR29 > VAR14 ) { apr_size_t VAR32 = VAR14 * 2 ; char * VAR33 ; if ( VAR13 + VAR29 > VAR32 ) { VAR32 = ( VAR13 + VAR29 ) * 2 ; } VAR33 = FUN11 ( VAR6 -> VAR31 , VAR32 ) ; memcpy ( VAR33 , * VAR2 , VAR13 ) ; VAR14 = VAR32 ; * VAR2 = VAR33 ; } } VAR15 = * VAR2 + VAR13 ; memcpy ( VAR15 , VAR28 , VAR29 ) ; VAR16 = VAR15 + VAR29 - 1 ; VAR13 += VAR29 ; } if ( VAR16 && ( * VAR16 == VAR34 ) ) { break ; } } if ( VAR16 <= * VAR2 || VAR16 [ -1 ] != VAR35 ) { * VAR16 = ' ' ; VAR13 = VAR16 - * VAR2 ; * read = VAR13 ; return VAR36 ; } if ( VAR16 > * VAR2 && VAR16 [ -1 ] == VAR35 ) { VAR16 -- ; } * VAR16 = ' ' ; VAR13 = VAR16 - * VAR2 ; if ( VAR19 && VAR13 && ! VAR18 ) { for ( ; ; ) { const char * VAR28 ; apr_size_t VAR29 ; char VAR37 ; FUN3 ( VAR9 ) ; VAR10 = FUN4 ( VAR6 -> VAR23 , VAR9 , VAR38 , VAR25 , 1 ) ; if ( VAR10 != VAR26 ) { return VAR10 ; } if ( FUN5 ( VAR9 ) ) { break ; } VAR12 = FUN6 ( VAR9 ) ; if ( FUN9 ( VAR12 ) ) { break ; } VAR10 = FUN10 ( VAR12 , & VAR28 , & VAR29 , VAR25 ) ; if ( VAR10 != VAR26 ) { FUN3 ( VAR9 ) ; return VAR10 ; } VAR37 = * VAR28 ; if ( VAR37 == VAR39 || VAR37 == VAR40 ) { if ( VAR13 >= VAR3 ) { * read = VAR3 ; ( * VAR2 ) [ VAR3 - 1 ] = ' ' ; return VAR30 ; } else { apr_size_t VAR41 , VAR42 ; char * VAR43 ; if ( VAR17 ) { VAR43 = NULL ; } else { VAR43 = VAR16 ; } VAR41 = VAR3 - VAR13 ; VAR10 = FUN2 ( & VAR43 , VAR41 , & VAR42 , VAR6 , 0 , VAR9 ) ; if ( VAR10 != VAR26 ) { return VAR10 ; } if ( VAR17 && VAR42 > 0 ) { char * VAR33 ; apr_size_t VAR32 = VAR13 + VAR42 + 1 ; VAR33 = FUN11 ( VAR6 -> VAR31 , VAR32 ) ; memcpy ( VAR33 , * VAR2 , VAR13 ) ; memcpy ( VAR33 + VAR13 , VAR43 , VAR42 + 1 ) ; * VAR2 = VAR33 ; } VAR16 += VAR42 ; VAR13 += VAR42 ; } } else { break ; } } } * read = VAR13 ; if ( strlen ( * VAR2 ) < VAR13 ) { return VAR36 ; } return VAR26 ; } #0
143#143#const FUN1 ( VAR1 ) * FUN2 ( VAR2 * VAR3 ) { const FUN1 ( VAR1 ) * VAR4 = NULL ; ; if ( VAR3 -> VAR5 ) { VAR4 = FUN3 ( VAR3 ) ; if ( VAR4 != NULL && FUN4 ( VAR4 ) == 0 ) VAR4 = NULL ; } if ( VAR4 == NULL ) VAR4 = FUN5 ( VAR3 ) ; return VAR4 ; } #0
144#144#"static VAR1 * FUN1 ( VAR2 * VAR3 , VAR2 * VAR4 , VAR2 * VAR5 , const VAR6 * VAR7 , VAR8 * VAR9 , VAR8 * * VAR10 ) { VAR11 * VAR12 , * VAR13 ; VAR14 * VAR15 , * VAR16 ; HANDSHAKE_EX_DATA VAR17 , VAR18 ; CTX_DATA VAR19 , VAR20 , VAR21 ; VAR1 * VAR22 = FUN2 ( ) ; int VAR23 = 1 , VAR24 = 0 ; peer_status_t VAR25 = VAR26 , VAR27 = VAR26 ; handshake_status_t VAR28 = VAR29 ; unsigned char * VAR30 = NULL ; size_t VAR31 = 0 ; VAR8 * VAR32 = NULL ; const unsigned char * VAR33 = NULL ; unsigned int VAR34 = 0 ; memset ( & VAR20 , 0 , sizeof ( VAR20 ) ) ; memset ( & VAR21 , 0 , sizeof ( VAR21 ) ) ; memset ( & VAR19 , 0 , sizeof ( VAR19 ) ) ; FUN3 ( VAR3 , VAR4 , VAR5 , VAR7 , & VAR20 , & VAR21 , & VAR19 ) ; VAR12 = FUN4 ( VAR3 ) ; VAR13 = FUN4 ( VAR5 ) ; FUN5 ( VAR12 != NULL && VAR13 != NULL ) ; FUN6 ( VAR12 , VAR13 , VAR7 ) ; if ( VAR9 != NULL ) { FUN5 ( FUN7 ( VAR3 , VAR9 ) ) ; FUN5 ( FUN8 ( VAR13 , VAR9 ) ) ; } memset ( & VAR17 , 0 , sizeof ( VAR17 ) ) ; memset ( & VAR18 , 0 , sizeof ( VAR18 ) ) ; VAR22 -> VAR35 = VAR36 ; VAR15 = FUN9 ( FUN10 ( ) ) ; VAR16 = FUN9 ( FUN10 ( ) ) ; FUN5 ( VAR15 != NULL && VAR16 != NULL ) ; FUN11 ( VAR15 , 1 ) ; FUN11 ( VAR16 , 1 ) ; FUN12 ( VAR13 ) ; FUN13 ( VAR12 ) ; FUN14 ( VAR13 , VAR16 , VAR15 ) ; FUN5 ( FUN15 ( VAR16 ) > 0 ) ; FUN5 ( FUN15 ( VAR15 ) > 0 ) ; FUN14 ( VAR12 , VAR15 , VAR16 ) ; VAR37 = FUN16 ( 0 , "" "" , NULL , NULL , NULL ) ; FUN5 ( VAR37 >= 0 ) ; FUN5 ( FUN17 ( VAR12 , VAR37 , & VAR17 ) == 1 ) ; FUN5 ( FUN17 ( VAR13 , VAR37 , & VAR18 ) == 1 ) ; FUN18 ( VAR12 , & VAR38 ) ; FUN18 ( VAR13 , & VAR38 ) ; for ( ; ; ) { if ( VAR23 ) { VAR25 = FUN19 ( VAR13 , VAR24 ) ; VAR28 = FUN20 ( VAR25 , VAR27 , 1 ) ; } else { VAR27 = FUN19 ( VAR12 , VAR24 ) ; VAR28 = FUN20 ( VAR27 , VAR25 , 0 ) ; } switch ( VAR28 ) { case VAR39 : if ( VAR24 ) { VAR22 -> VAR35 = VAR40 ; goto VAR41 ; } else { VAR25 = VAR27 = VAR26 ; VAR24 = 1 ; VAR23 = 1 ; break ; } case VAR42 : VAR22 -> VAR35 = VAR43 ; goto VAR41 ; case VAR44 : VAR22 -> VAR35 = VAR45 ; goto VAR41 ; case VAR46 : VAR22 -> VAR35 = VAR36 ; goto VAR41 ; case VAR29 : VAR23 ^= 1 ; break ; } } VAR41 : VAR22 -> VAR47 = VAR17 . VAR48 ; VAR22 -> VAR49 = VAR18 . VAR50 ; VAR22 -> VAR51 = VAR18 . VAR48 ; VAR22 -> VAR52 = VAR17 . VAR50 ; VAR22 -> VAR53 = FUN21 ( VAR12 ) ; VAR22 -> VAR54 = FUN21 ( VAR13 ) ; VAR22 -> VAR55 = VAR17 . VAR55 ; if ( ( VAR32 = FUN22 ( VAR13 ) ) != NULL ) FUN23 ( VAR32 , & VAR30 , & VAR31 ) ; if ( VAR30 == NULL || VAR31 == 0 ) VAR22 -> VAR56 = VAR57 ; else VAR22 -> VAR56 = VAR58 ; VAR22 -> VAR59 = VAR17 . VAR59 ; FUN24 ( VAR13 , & VAR33 , & VAR34 ) ; VAR22 -> VAR60 = FUN25 ( VAR33 , VAR34 ) ; FUN24 ( VAR12 , & VAR33 , & VAR34 ) ; VAR22 -> VAR61 = FUN25 ( VAR33 , VAR34 ) ; FUN26 ( VAR13 , & VAR33 , & VAR34 ) ; VAR22 -> VAR62 = FUN25 ( VAR33 , VAR34 ) ; FUN26 ( VAR12 , & VAR33 , & VAR34 ) ; VAR22 -> VAR63 = FUN25 ( VAR33 , VAR34 ) ; VAR22 -> VAR64 = FUN27 ( VAR13 ) ; VAR22 -> VAR65 = FUN27 ( VAR12 ) ; if ( VAR10 != NULL ) * VAR10 = FUN28 ( VAR13 ) ; FUN29 ( & VAR20 ) ; FUN29 ( & VAR21 ) ; FUN29 ( & VAR19 ) ; FUN30 ( VAR12 ) ; FUN30 ( VAR13 ) ; return VAR22 ; } "#0
145#145#static int FUN1 ( VAR1 * VAR2 , void * VAR3 ) { VAR4 * VAR5 = VAR3 ; VAR6 * VAR7 = VAR5 -> VAR8 ; const int VAR9 = VAR5 -> VAR10 ; const int VAR11 = VAR5 -> VAR12 ; const int VAR13 = VAR5 -> VAR14 ; const int VAR15 = VAR5 -> VAR16 ; int VAR17 [ 2 ] = { -1 , -1 } ; int VAR18 = VAR5 -> VAR19 , VAR20 = 1 ; int VAR21 , VAR22 = FUN2 ( VAR7 , VAR5 -> VAR23 , VAR9 , VAR11 , VAR18 ) ; while ( ( VAR22 > VAR13 ) || ( VAR22 < VAR15 ) ) { const int VAR24 = VAR22 > VAR13 ? + VAR20 : - VAR20 ; VAR18 = FUN3 ( VAR18 + VAR24 , 0 , VAR7 -> VAR25 - 1 ) ; VAR22 = FUN2 ( VAR7 , VAR5 -> VAR23 , VAR9 , VAR11 , VAR18 ) ; if ( VAR17 [ 1 ] == VAR18 ) { VAR18 = FUN4 ( VAR17 [ 0 ] , VAR18 ) ; VAR22 = VAR18 == VAR17 [ 0 ] ? VAR21 : VAR22 ; break ; } VAR20 = FUN3 ( VAR20 / 2 , 1 , ( VAR7 -> VAR25 - 1 ) / 2 ) ; VAR17 [ 1 ] = VAR17 [ 0 ] ; VAR17 [ 0 ] = VAR18 ; VAR21 = VAR22 ; } VAR5 -> VAR19 = FUN3 ( VAR18 , 0 , VAR7 -> VAR25 - 1 ) ; VAR5 -> VAR26 = FUN5 ( ( VAR22 >> 3 ) , VAR7 -> VAR27 ) + 4 + VAR7 -> VAR28 ; VAR5 -> VAR29 = VAR7 -> VAR30 - VAR5 -> VAR26 ; return 0 ; } #0
146#146#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , int VAR7 , int VAR8 ) { GetByteContext VAR9 ; GetBitContext VAR10 ; int VAR11 , VAR12 , VAR13 ; uint32_t VAR14 , VAR15 ; VAR5 * VAR16 ; int VAR17 ; FUN2 ( & VAR9 , VAR6 , VAR7 ) ; VAR11 = FUN3 ( & VAR9 ) ; VAR14 = FUN4 ( VAR11 * 4 + 2 , 16 ) ; if ( VAR7 < VAR14 ) { FUN5 ( VAR2 , VAR18 , , VAR11 , VAR2 -> VAR21 , VAR2 -> VAR20 ) ; return VAR22 ; } VAR13 = VAR2 -> VAR20 / VAR11 ; VAR2 -> VAR23 = VAR24 ; if ( ( VAR17 = FUN7 ( VAR2 , VAR4 , 0 ) ) < 0 ) return VAR17 ; VAR16 = VAR4 -> VAR25 [ 0 ] ; for ( VAR12 = 0 ; VAR12 < VAR11 ; VAR12 ++ ) { VAR15 = FUN8 ( & VAR9 ) ; if ( VAR15 > VAR7 - VAR14 ) { FUN5 ( VAR2 , VAR18 , VAR26VAR26VAR26 , FUN9 ( VAR6 + VAR14 ) , VAR15 - 16 ) ; } FUN10 ( & VAR10 , VAR6 + VAR14 + 16 , ( VAR15 - 16 ) * 8 ) ; FUN11 ( & VAR10 , VAR2 -> VAR21 , VAR13 , VAR16 , VAR4 -> VAR27 [ 0 ] , VAR8 ) ; VAR16 += VAR4 -> VAR27 [ 0 ] * VAR13 ; VAR14 += VAR15 ; } return 0 ; } #1
147#147#static inline int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; int VAR4 = FUN2 ( VAR2 -> VAR5 ) ; if ( ! VAR4 ) return FUN3 ( VAR6 ) ; VAR3 = VAR2 -> VAR7 [ 0 ] / VAR4 ; if ( FUN4 ( VAR2 -> VAR5 ) ) { return VAR3 ; } else { int VAR8 = FUN5 ( VAR2 -> VAR9 ) ; return VAR3 / VAR8 ; } } #0
148#148#static VAR1 FUN1 ( VAR2 * VAR3 , unsigned VAR4 , unsigned VAR5 ) { unsigned VAR6 , VAR7 ; CodeBook VAR8 = { 0 } ; if ( VAR5 >= VAR9 / 34 || FUN2 ( VAR3 ) < VAR5 * 34 ) return VAR8 ; if ( VAR5 >= VAR9 / sizeof ( VAR10 ) ) return VAR8 ; VAR8 . VAR11 = FUN3 ( VAR5 ? VAR5 * sizeof ( VAR10 ) : 1 ) ; if ( ! VAR8 . VAR11 ) return VAR8 ; VAR8 . VAR4 = VAR4 ; VAR8 . VAR5 = VAR5 ; for ( VAR6 = 0 ; VAR6 < VAR5 ; VAR6 ++ ) { unsigned VAR12 = FUN4 ( VAR3 , 4 ) ; unsigned VAR13 = FUN4 ( VAR3 , 15 ) ; unsigned VAR14 = FUN4 ( VAR3 , 15 ) ; for ( VAR7 = 0 ; VAR7 < 4 ; VAR7 ++ ) { if ( VAR12 & ( 1 << VAR7 ) ) VAR8 . VAR11 [ VAR6 ] . VAR15 [ VAR7 ] = VAR14 ; else VAR8 . VAR11 [ VAR6 ] . VAR15 [ VAR7 ] = VAR13 ; } } return VAR8 ; } #0
149#149#static int FUN1 ( int VAR1 ) { VAR2 * VAR3 ; VAR4 * VAR5 = NULL ; VAR6 * VAR7 ; VAR6 * VAR8 ; long VAR9 ; unsigned char * VAR10 ; PACKET VAR11 = { 0 } , VAR12 = { 0 } , VAR13 = { 0 } ; char * VAR14 = ) ) ) goto VAR22 ; case VAR27 : case VAR28 : FUN9 ( VAR3 , VAR29 ) ; FUN10 ( VAR3 , VAR30 ) ; if ( VAR1 == VAR27 ) { if ( ! FUN11 ( FUN12 ( VAR3 , ( unsigned char * ) VAR31 , sizeof ( VAR31 ) - 1 ) ) ) goto VAR22 ; } else if ( ! FUN6 ( FUN8 ( VAR3 , ) ; if ( ! FUN4 ( VAR18 ) ) { FUN15 ( ) ; goto VAR22 ; } if ( ! FUN6 ( FUN17 ( VAR20 , ( long ) FUN18 ( NULL ) ) ) || ! FUN6 ( FUN19 ( VAR5 , VAR20 ) ) ) goto VAR22 ; } VAR7 = FUN20 ( FUN21 ( ) ) ; VAR8 = FUN20 ( FUN21 ( ) ) ; if ( ! FUN4 ( VAR7 ) || ! FUN4 ( VAR8 ) ) { FUN22 ( VAR7 ) ; FUN22 ( VAR8 ) ; goto VAR22 ; } FUN23 ( VAR5 , VAR7 , VAR8 ) ; FUN24 ( VAR5 ) ; if ( VAR1 == VAR23 ) { if ( ! FUN6 ( FUN25 ( VAR5 , VAR14 , strlen ( VAR14 ) ) ) ) goto VAR22 ; } if ( ! FUN26 ( FUN27 ( VAR5 ) , 0 ) ) { goto VAR22 ; } VAR9 = FUN28 ( VAR8 , ( char * * ) & VAR10 ) ; if ( ! FUN6 ( FUN29 ( & VAR11 , VAR10 , VAR9 ) ) || ! FUN30 ( & VAR11 , VAR33 ) ) goto VAR22 ; VAR17 = FUN31 ( & VAR11 ) ; if ( ! FUN6 ( FUN30 ( & VAR11 , VAR34 ) ) || ! FUN6 ( FUN30 ( & VAR11 , VAR35 + VAR36 ) ) || ! FUN6 ( FUN32 ( & VAR11 , & VAR12 ) ) || ! FUN6 ( FUN33 ( & VAR11 , & VAR12 ) ) || ! FUN6 ( FUN32 ( & VAR11 , & VAR12 ) ) || ! FUN6 ( FUN34 ( & VAR11 , & VAR12 ) ) ) goto VAR22 ; while ( FUN31 ( & VAR12 ) ) { if ( ! FUN6 ( FUN35 ( & VAR12 , & VAR15 ) ) || ! FUN6 ( FUN33 ( & VAR12 , & VAR13 ) ) ) goto VAR22 ; if ( VAR15 == VAR37 ) { if ( VAR1 == VAR23 ) { if ( FUN6 ( FUN36 ( & VAR13 , VAR14 , strlen ( VAR14 ) ) ) ) { VAR16 = 1 ; } goto VAR22 ; } } if ( VAR15 == VAR38 ) { if ( ! FUN11 ( VAR1 == VAR28 ) ) goto VAR22 ; else if ( FUN6 ( VAR1 == VAR27 || VAR1 == VAR21 ) ) VAR16 = FUN6 ( VAR17 == VAR39 ) ; } } if ( VAR1 == VAR28 ) VAR16 = 1 ; VAR22 : FUN37 ( VAR5 ) ; FUN38 ( VAR3 ) ; FUN39 ( VAR20 ) ; FUN22 ( VAR18 ) ; return VAR16 ; } #0
150#150#"static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 , VAR7 , VAR8 ; VAR9 * VAR10 ; VAR4 -> VAR2 = VAR2 ; if ( VAR2 -> VAR11 > VAR12 ) { FUN2 ( VAR2 , VAR13 , , VAR2 -> VAR15 ) ; return FUN3 ( VAR14 ) ; } if ( VAR2 -> VAR16 < 24 * 1000 ) { FUN2 ( VAR2 , VAR13 , "" "" , VAR2 -> VAR16 ) ; return FUN3 ( VAR14 ) ; } VAR7 = 0 ; VAR8 = 1 ; if ( VAR2 -> VAR17 -> VAR18 == VAR19 ) { VAR10 = FUN4 ( 4 ) ; VAR2 -> VAR20 = 4 ; FUN5 ( VAR10 , VAR7 ) ; FUN5 ( VAR10 + 2 , VAR8 ) ; } else if ( VAR2 -> VAR17 -> VAR18 == VAR21 ) { VAR10 = FUN6 ( 10 ) ; VAR2 -> VAR20 = 10 ; FUN7 ( VAR10 , VAR7 ) ; FUN5 ( VAR10 + 4 , VAR8 ) ; } else FUN8 ( 0 ) ; VAR2 -> VAR10 = VAR10 ; VAR4 -> VAR22 = VAR8 & 0x0001 ; VAR4 -> VAR23 = VAR8 & 0x0002 ; VAR4 -> VAR24 = VAR8 & 0x0004 ; if ( VAR2 -> VAR11 == 2 ) VAR4 -> VAR25 = 1 ; FUN9 ( VAR2 , VAR8 ) ; for ( VAR6 = 0 ; VAR6 < VAR4 -> VAR26 ; VAR6 ++ ) FUN10 ( & VAR4 -> VAR27 [ VAR6 ] , VAR4 -> VAR28 - VAR6 + 1 , 0 , 1.0 ) ; VAR4 -> VAR29 = VAR2 -> VAR16 * ( VAR30 ) VAR4 -> VAR31 / ( VAR2 -> VAR15 * 8 ) ; VAR4 -> VAR29 = FUN11 ( VAR4 -> VAR29 , VAR32 ) ; VAR2 -> VAR29 = VAR4 -> VAR29 ; VAR2 -> VAR16 = VAR2 -> VAR29 * 8LL * VAR2 -> VAR15 / VAR4 -> VAR31 ; VAR2 -> VAR33 = VAR2 -> VAR34 = VAR4 -> VAR31 ; #if FF_API_OLD_ENCODE_AUDIO VAR2 -> VAR35 = & VAR4 - > VAR36 ; FUN12 ( VAR2 - > VAR35 ) ; #endif return 0; } "#1
151#151#VAR1 * FUN1 ( const VAR1 * VAR2 ) { VAR1 * VAR3 ; if ( ( VAR3 = FUN2 ( sizeof ( * VAR3 ) ) ) == NULL ) return NULL ; * VAR3 = * VAR2 ; if ( VAR2 -> VAR4 == 0 ) { VAR3 -> VAR5 = NULL ; VAR3 -> VAR6 = 0 ; return VAR3 ; } if ( ( VAR3 -> VAR5 = FUN2 ( sizeof ( * VAR3 -> VAR5 ) * VAR2 -> VAR6 ) ) == NULL ) goto VAR7 ; memcpy ( VAR3 -> VAR5 , VAR2 -> VAR5 , sizeof ( void * ) * VAR2 -> VAR4 ) ; return VAR3 ; VAR7 : FUN3 ( VAR3 ) ; return NULL ; } #1
152#152#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , char * VAR6 ) { VAR7 * VAR8 = NULL ; char * VAR9 [ VAR10 ] , * * VAR11 , * * VAR12 ; char * VAR13 = NULL ; VAR14 * VAR15 = NULL ; int VAR16 = -1 , VAR17 ; for ( VAR17 = 0 ; VAR17 < VAR10 ; VAR17 ++ ) VAR9 [ VAR17 ] = NULL ; VAR9 [ VAR18 ] = FUN2 ( FUN3 ( VAR2 ) , NULL , 0 ) ; VAR15 = FUN4 ( FUN5 ( VAR2 ) , NULL ) ; if ( ! VAR15 ) goto VAR19 ; if ( FUN6 ( VAR15 ) ) VAR9 [ VAR20 ] = FUN7 ( ) ; goto VAR19 ; } VAR11 = FUN11 ( VAR4 -> VAR4 , VAR20 , VAR9 ) ; if ( VAR11 == NULL ) { FUN10 ( VAR21 , ) ; VAR8 = FUN12 ( VAR2 ) ; VAR9 [ VAR23 ] = FUN13 ( VAR8 -> VAR24 + 1 , ) ; VAR12 = FUN13 ( sizeof ( * VAR12 ) * ( VAR10 + 1 ) , ) ; FUN10 ( VAR21 , , VAR9 [ VAR18 ] ) ; goto VAR19 ; } else if ( VAR5 == -1 ) { FUN10 ( VAR21 , , VAR9 [ VAR20 ] ) ; goto VAR19 ; } else { FUN10 ( VAR21 , ) ; goto VAR19 ; } VAR11 [ VAR22 ] [ 0 ] = ' ' ; VAR11 [ VAR22 ] [ 1 ] = ' ' ; VAR11 [ VAR26 ] = VAR13 ; } VAR16 = 1 ; VAR19 : for ( VAR17 = 0 ; VAR17 < VAR10 ; VAR17 ++ ) { FUN17 ( VAR9 [ VAR17 ] ) ; } return ( VAR16 ) ; } #0
153#153#static void FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * VAR5 ; VAR6 * VAR7 ; VAR8 * VAR9 ; enum CodecID VAR10 ; VAR11 * VAR12 = NULL ; VAR5 = FUN2 ( VAR2 , VAR2 -> VAR13 < VAR14 ? VAR15 [ VAR2 -> VAR13 ] : 0 ) ; if ( ! VAR5 ) { fprintf ( VAR16 , , & VAR70 , & VAR71 , & VAR72 ) ; if ( VAR73 != 3 ) { fprintf ( VAR16 , , VAR91 , 0 ) ; FUN19 ( & VAR91 ) ; } VAR93 = 0 ; FUN19 ( & VAR20 ) ; FUN19 ( & VAR90 ) ; VAR19 = 0 ; VAR58 = VAR94 ; } #1
154#154#"static inline int FUN1 ( VAR1 * VAR2 , unsigned VAR3 , VAR4 * VAR5 ) { int VAR6 = FUN2 ( VAR3 , & VAR2 -> VAR7 , FUN3 ( VAR8 , VAR9 ) , & VAR2 -> VAR10 , & VAR2 -> VAR11 , VAR5 ) ; #if FF_API_FOO_COUNT FF_DISABLE_DEPRECATION_WARNINGS VAR2 - > VAR12 = VAR2 - > VAR7 ; VAR13 #endif return VAR6 ; } "#0
155#155#int FUN1 ( VAR1 * VAR2 , BN_ULONG VAR3 ) { BN_ULONG VAR4 ; int VAR5 ; FUN2 ( VAR2 ) ; VAR3 &= VAR6 ; if ( ! VAR3 ) return 1 ; if ( FUN3 ( VAR2 ) ) return FUN4 ( VAR2 , VAR3 ) ; if ( VAR2 -> VAR7 ) { VAR2 -> VAR7 = 0 ; VAR5 = FUN5 ( VAR2 , VAR3 ) ; if ( ! FUN3 ( VAR2 ) ) VAR2 -> VAR7 = ! ( VAR2 -> VAR7 ) ; return ( VAR5 ) ; } for ( VAR5 = 0 ; VAR3 != 0 && VAR5 < VAR2 -> VAR8 ; VAR5 ++ ) { VAR2 -> VAR9 [ VAR5 ] = VAR4 = ( VAR2 -> VAR9 [ VAR5 ] + VAR3 ) & VAR6 ; VAR3 = ( VAR3 > VAR4 ) ? 1 : 0 ; } if ( VAR3 && VAR5 == VAR2 -> VAR8 ) { if ( FUN6 ( VAR2 , VAR2 -> VAR8 + 1 ) == NULL ) return 0 ; VAR2 -> VAR8 ++ ; VAR2 -> VAR9 [ VAR5 ] = VAR3 ; } FUN2 ( VAR2 ) ; return ( 1 ) ; } #0
156#156#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; FUN2 ( VAR2 -> VAR4 , VAR2 -> VAR5 , VAR2 -> VAR6 ) ; if ( ! VAR2 -> VAR7 ) { VAR2 -> VAR8 = VAR2 -> VAR9 = NULL ; } else { int VAR10 = FUN3 ( VAR2 -> VAR7 , VAR2 -> VAR11 , VAR2 -> VAR6 ) ; VAR2 -> VAR9 = FUN4 ( sizeof ( float ) * VAR2 -> VAR6 * VAR2 -> VAR11 ) ; VAR2 -> VAR8 = FUN5 ( sizeof ( float ) * VAR2 -> VAR6 ) ; if ( ! VAR2 -> VAR9 || ! VAR2 -> VAR8 ) return FUN6 ( VAR12 ) ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR6 ; VAR3 ++ ) { float VAR13 = 0 ; int VAR14 ; int VAR15 = 1 ; for ( VAR14 = 0 ; VAR14 < VAR2 -> VAR11 ; VAR14 ++ ) { int VAR16 ; if ( VAR2 -> VAR7 == 1 ) VAR16 = ( VAR3 / VAR15 ) % VAR10 ; else VAR16 = VAR3 * VAR2 -> VAR11 + VAR14 ; VAR2 -> VAR9 [ VAR3 * VAR2 -> VAR11 + VAR14 ] = VAR13 + VAR2 -> VAR17 + VAR2 -> VAR18 [ VAR16 ] * VAR2 -> VAR19 ; if ( VAR2 -> VAR20 ) VAR13 = VAR2 -> VAR9 [ VAR3 * VAR2 -> VAR11 + VAR14 ] ; VAR2 -> VAR8 [ VAR3 ] += VAR2 -> VAR9 [ VAR3 * VAR2 -> VAR11 + VAR14 ] * VAR2 -> VAR9 [ VAR3 * VAR2 -> VAR11 + VAR14 ] ; VAR15 *= VAR10 ; } VAR2 -> VAR8 [ VAR3 ] /= 2. ; } } return 0 ; } #0
157#157#static void final ( const short * VAR1 , const short * VAR2 , void * VAR3 , int * VAR4 , int VAR5 ) { int VAR6 , VAR7 ; unsigned short int VAR8 [ 50 ] ; short * VAR9 = VAR8 ; memcpy ( VAR8 , VAR4 , 20 ) ; memcpy ( VAR8 + 10 , VAR2 , VAR5 * 2 ) ; for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 ++ ) { int VAR10 = 0 ; int VAR11 ; for ( VAR6 = 0 ; VAR6 < 10 ; VAR6 ++ ) VAR10 += VAR1 [ 9 - VAR6 ] * VAR9 [ VAR6 ] ; VAR10 >>= 12 ; VAR11 = VAR9 [ 10 ] - VAR10 ; if ( VAR11 < -32768 || VAR11 > 32767 ) { memset ( VAR3 , 0 , VAR5 * 2 ) ; memset ( VAR4 , 0 , 20 ) ; return ; } VAR9 [ 10 ] = VAR11 ; VAR9 ++ ; } memcpy ( VAR3 , VAR8 + 10 , VAR5 * 2 ) ; memcpy ( VAR4 , VAR8 + 40 , 20 ) ; } #0
158#158#"int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; VAR2 -> VAR4 = VAR2 -> VAR5 * VAR2 -> VAR6 ; if ( VAR2 -> VAR4 <= 0 ) { FUN2 ( VAR2 -> VAR7 , VAR8 , "" "" ) ; return FUN3 ( VAR9 ) ; } for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR4 ; VAR3 ++ ) { VAR1 * VAR10 = FUN4 ( sizeof ( * VAR10 ) ) ; int VAR11 = VAR3 % VAR2 -> VAR5 ; int VAR12 = VAR3 / VAR2 -> VAR5 ; int VAR13 = VAR2 -> VAR7 -> VAR14 * VAR11 / VAR2 -> VAR5 ; int VAR15 = VAR2 -> VAR7 -> VAR14 * ( VAR11 + 1 ) / VAR2 -> VAR5 ; int VAR16 = VAR2 -> VAR7 -> VAR17 * VAR12 / VAR2 -> VAR6 ; int VAR18 = VAR2 -> VAR7 -> VAR17 * ( VAR12 + 1 ) / VAR2 -> VAR6 ; VAR2 -> VAR19 [ VAR3 ] = VAR10 ; memcpy ( VAR10 , VAR2 , sizeof ( * VAR10 ) ) ; memset ( VAR10 -> VAR20 , 0 , sizeof ( VAR10 -> VAR20 ) ) ; VAR10 -> VAR21 = VAR15 - VAR13 ; VAR10 -> VAR22 = VAR18 - VAR16 ; VAR10 -> VAR23 = VAR13 ; VAR10 -> VAR24 = VAR16 ; VAR10 -> VAR25 = FUN5 ( 3 * VAR26 * ( VAR10 -> VAR14 + 6 ) * sizeof ( * VAR10 -> VAR25 ) ) ; if ( ! VAR10 -> VAR25 ) return FUN3 ( VAR27 ) ; } return 0 ; } "#1
159#159#static int FUN1 ( void ) { VAR1 * VAR2 ; VAR3 * VAR4 = NULL ; int VAR5 , VAR6 ; for ( VAR5 = 0 ; VAR5 < VAR7 ; VAR5 ++ ) { VAR8 * VAR9 = VAR10 [ VAR5 ] ; VAR11 * VAR12 = VAR13 [ VAR9 -> VAR14 ] ; int VAR15 = 0 ; if ( ! VAR9 -> VAR16 || VAR9 -> VAR17 ) continue ; if ( ! VAR9 -> VAR4 && ! ( VAR9 -> VAR4 = FUN2 ( ) ) ) { return FUN3 ( VAR18 ) ; } else FUN4 ( VAR9 -> VAR4 ) ; VAR4 = VAR9 -> VAR4 ; while ( VAR15 >= 0 ) { if ( VAR9 -> VAR19 -> VAR20 == VAR21 && ! ( VAR9 -> VAR19 -> VAR22 & VAR23 ) ) VAR15 = FUN5 ( VAR9 -> VAR16 -> VAR16 , & VAR2 , VAR9 -> VAR24 -> VAR25 -> VAR6 ) ; else VAR15 = FUN6 ( VAR9 -> VAR16 -> VAR16 , & VAR2 ) ; if ( VAR15 < 0 ) break ; FUN7 ( VAR4 , VAR2 ) ; if ( VAR9 -> VAR19 -> VAR20 == VAR26 ) VAR4 -> VAR27 = FUN8 ( VAR2 -> VAR27 , VAR9 -> VAR16 -> VAR16 -> VAR28 [ 0 ] -> VAR29 , VAR30 ) ; else if ( VAR2 -> VAR27 != VAR31 ) VAR4 -> VAR27 = FUN8 ( VAR2 -> VAR27 , VAR9 -> VAR16 -> VAR16 -> VAR28 [ 0 ] -> VAR29 , VAR9 -> VAR24 -> VAR25 -> VAR29 ) - FUN8 ( VAR12 -> VAR32 , VAR30 , VAR9 -> VAR24 -> VAR25 -> VAR29 ) ; if ( VAR12 -> VAR32 && VAR4 -> VAR27 < VAR12 -> VAR32 ) return 0 ; switch ( VAR9 -> VAR16 -> VAR16 -> VAR28 [ 0 ] -> VAR20 ) { case VAR26 : if ( ! VAR9 -> VAR33 ) VAR9 -> VAR24 -> VAR25 -> VAR34 = VAR2 -> VAR35 -> VAR36 ; FUN9 ( VAR12 -> VAR37 , VAR9 , VAR4 , & VAR6 , VAR38 ? VAR9 -> VAR39 : VAR9 -> VAR24 -> VAR25 -> VAR40 ) ; if ( VAR41 && VAR6 ) FUN10 ( VAR12 -> VAR37 , VAR9 , VAR6 ) ; break ; case VAR21 : FUN11 ( VAR12 -> VAR37 , VAR9 , VAR4 ) ; break ; default : FUN12 ( 0 ) ; } FUN13 ( VAR2 ) ; } } return 0 ; } #0
160#160#static inline int FUN1 ( void * VAR1 , unsigned int * VAR2 , size_t VAR3 , int VAR4 ) { void * VAR5 ; memcpy ( & VAR5 , VAR1 , sizeof ( VAR5 ) ) ; if ( VAR3 <= * VAR2 ) { FUN2 ( VAR5 || ! VAR3 ) ; return 0 ; } VAR3 = FUN3 ( VAR3 + VAR3 / 16 + 32 , VAR3 ) ; FUN4 ( VAR1 ) ; VAR5 = VAR4 ? FUN5 ( VAR3 ) : FUN6 ( VAR3 ) ; memcpy ( VAR1 , & VAR5 , sizeof ( VAR5 ) ) ; if ( ! VAR5 ) VAR3 = 0 ; * VAR2 = VAR3 ; return 1 ; } #1
161#161#void FUN1 ( VAR1 * VAR2 , tmsize_t VAR3 ) { for ( ; VAR3 > 8 ; VAR3 -= 8 ) { VAR2 [ 0 ] = VAR4 [ VAR2 [ 0 ] ] ; VAR2 [ 1 ] = VAR4 [ VAR2 [ 1 ] ] ; VAR2 [ 2 ] = VAR4 [ VAR2 [ 2 ] ] ; VAR2 [ 3 ] = VAR4 [ VAR2 [ 3 ] ] ; VAR2 [ 4 ] = VAR4 [ VAR2 [ 4 ] ] ; VAR2 [ 5 ] = VAR4 [ VAR2 [ 5 ] ] ; VAR2 [ 6 ] = VAR4 [ VAR2 [ 6 ] ] ; VAR2 [ 7 ] = VAR4 [ VAR2 [ 7 ] ] ; VAR2 += 8 ; } while ( VAR3 -- > 0 ) { * VAR2 = VAR4 [ * VAR2 ] ; VAR2 ++ ; } } #1
162#162#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , VAR6 * VAR7 , int VAR8 ) { const int VAR9 = VAR2 -> VAR10 ; const int VAR11 = ( 1 << VAR9 ) - 1 ; const int VAR12 = VAR5 * 256 ; int VAR13 = FUN2 ( VAR4 ) ; int VAR14 = VAR11 , VAR15 ; int VAR16 = 0 ; int VAR17 = 0 ; VAR15 = VAR7 [ VAR16 ++ ] ; FUN3 ( VAR4 , VAR15 , VAR14 , VAR9 ) ; VAR14 = VAR15 ; do { VAR15 = VAR7 [ VAR16 ++ ] ; if ( VAR15 != VAR14 ) { FUN4 ( VAR4 , VAR17 ) ; FUN3 ( VAR4 , VAR15 , VAR14 , VAR9 ) ; VAR14 = VAR15 ; VAR17 = 0 ; } else { VAR17 ++ ; } } while ( VAR16 < VAR12 ) ; if ( VAR17 ) FUN4 ( VAR4 , VAR17 ) ; FUN5 ( VAR4 ) ; return ( FUN2 ( VAR4 ) - VAR13 ) >> 3 ; } #1
163#163#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = & VAR2 -> VAR5 -> VAR4 ; int VAR6 ; int VAR7 = 0 ; int VAR8 = -1 ; int VAR9 = -1 ; FUN2 ( VAR4 ) ; VAR6 = FUN3 ( VAR4 ) ; if ( VAR6 == 0 ) { VAR9 = FUN4 ( VAR4 , 7 ) ; VAR7 = FUN3 ( VAR4 ) ; VAR8 = FUN4 ( VAR4 , 6 ) ; FUN5 ( VAR4 , 6 ) ; if ( VAR7 == 0 && VAR9 != 5 ) FUN5 ( VAR4 , 16 ) ; FUN5 ( VAR4 , 8 ) ; FUN6 ( VAR4 ) ; } FUN6 ( VAR4 ) ; VAR2 -> VAR10 = ( VAR6 == 0 ) ; VAR2 -> VAR11 = VAR9 ; VAR2 -> VAR12 = VAR8 ; VAR2 -> VAR13 = VAR7 ; } #0
164#164#"static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 , VAR6 * VAR7 , VAR8 * VAR9 ) { apr_status_t VAR10 = VAR11 ; VAR12 * VAR13 = FUN2 ( VAR9 -> VAR14 -> VAR15 ) ; apr_size_t VAR16 = 0 , VAR17 = 0 ; VAR18 * VAR19 , * VAR20 ; const char * VAR21 ; apr_size_t VAR22 ; for ( VAR19 = FUN3 ( VAR5 ) ; VAR19 != FUN4 ( VAR5 ) ; VAR19 = VAR20 ) { VAR20 = FUN5 ( VAR19 ) ; #if APR_HAS_SENDFILE if ( FUN6 ( VAR19 ) ) { if ( VAR16 > 0 ) { ( void ) FUN7 ( VAR3 , VAR23 , 1 ) ; VAR10 = FUN8 ( VAR3 , VAR5 , VAR7 , VAR17 , VAR16 , VAR9 ) ; if ( VAR10 != VAR11 ) { goto VAR24 ; } VAR17 = 0 ; VAR16 = 0 ; } VAR10 = FUN9 ( VAR3 , VAR19 , VAR7 , VAR9 ) ; if ( VAR10 != VAR11 ) { goto VAR24 ; } continue ; } #endif if (VAR19->VAR22) {  VAR10 = FUN10(VAR19, &VAR21, &VAR22, VAR25); if (FUN11(VAR10)) {  if (VAR16) { VAR10 = FUN8(VAR3, VAR5, VAR7, VAR17, VAR16, VAR9); if (VAR10 != VAR11) { goto VAR24; } VAR17 = 0; VAR16 = 0; } (void)FUN7(VAR3, VAR23, 0);  VAR10 = FUN10(VAR19, &VAR21, &VAR22, VAR26); } if (VAR10 != VAR11) { goto VAR24; }   VAR20 = FUN5(VAR19); }  if (!VAR19->VAR22) {  if (!VAR16) { FUN12(VAR19); } continue; }   if (VAR16 == VAR7->VAR16) { if (VAR16 == VAR27) { (void)FUN7(VAR3, VAR23, 1); VAR10 = FUN8(VAR3, VAR5, VAR7, VAR17, VAR16, VAR9); if (VAR10 != VAR11) { goto VAR24; } VAR17 = 0; VAR16 = 0; } else { struct VAR28 *VAR29; apr_size_t VAR30 = VAR16 * 2; if (VAR30 < VAR31) { VAR30 = VAR31; } else if (VAR30 > VAR27) { VAR30 = VAR27; } VAR29 = FUN13(VAR9->VAR32, VAR30 * sizeof(struct VAR28)); if (VAR16) { memcpy(VAR29, VAR7->VAR33, VAR16 * sizeof(struct VAR28)); } VAR7->VAR33 = VAR29; VAR7->VAR16 = VAR30; } } VAR17 += VAR22; VAR7->VAR33[VAR16].VAR34 = (void *)VAR21; VAR7->VAR33[VAR16].VAR35 = VAR22; VAR16++;   if (VAR17 >= VAR13->VAR36 && VAR20 != FUN4(VAR5) && !FUN14(VAR20)) { (void)FUN7(VAR3, VAR23, 1); VAR10 = FUN8(VAR3, VAR5, VAR7, VAR17, VAR16, VAR9); if (VAR10 != VAR11) { goto VAR24; } VAR17 = 0; VAR16 = 0; } } if (VAR16 > 0) { VAR10 = FUN8(VAR3, VAR5, VAR7, VAR17, VAR16, VAR9); }  VAR24: (void)FUN7(VAR3, VAR23, 0); return VAR10; } "#0
165#165#"static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , int64_t VAR9 ) { static VAR10 * VAR11 = NULL ; int VAR12 = 65536 ; int VAR13 , VAR14 , VAR15 ; VAR16 * VAR17 ; AVPacket VAR18 ; if ( VAR9 == VAR19 ) { fprintf ( VAR20 , "" "" ) ; if ( VAR21 ) FUN2 ( 1 ) ; return ; } VAR17 = VAR4 -> VAR22 -> VAR23 ; if ( ! VAR11 ) { VAR11 = FUN3 ( VAR12 ) ; } if ( VAR17 -> VAR24 == VAR25 ) VAR14 = 2 ; else VAR14 = 1 ; for ( VAR15 = 0 ; VAR15 < VAR14 ; VAR15 ++ ) { VAR13 = FUN4 ( VAR17 , VAR11 , VAR12 , VAR8 ) ; FUN5 ( & VAR18 ) ; VAR18 . VAR26 = VAR4 -> VAR27 ; VAR18 . VAR28 = VAR11 ; VAR18 . VAR29 = VAR13 ; VAR18 . VAR9 = FUN6 ( VAR9 , VAR6 -> VAR22 -> VAR30 , VAR4 -> VAR22 -> VAR30 ) ; if ( VAR17 -> VAR24 == VAR25 ) { if ( VAR15 == 0 ) VAR18 . VAR9 += 90 * VAR8 -> VAR31 ; else VAR18 . VAR9 += 90 * VAR8 -> VAR32 ; } FUN7 ( VAR2 , & VAR18 , VAR4 -> VAR22 -> VAR23 , VAR33 [ VAR4 -> VAR34 ] [ VAR18 . VAR26 ] ) ; } } "#1
166#166#VAR1 FUN1 ( void ) { OSSL_PARAM VAR2 = VAR3 ; return VAR2 ; } #1
167#167#static int FUN1 ( VAR1 * VAR2 ) { const VAR3 * VAR4 , * VAR5 ; uint32_t VAR6 = -1 ; int VAR7 [ 4 * 16 ] = { 0 } ; int VAR8 = 0 , VAR9 = 0 ; int VAR10 , VAR11 , VAR12 , VAR13 , VAR14 ; int64_t VAR15 = 0 ; uint8_t VAR16 [ VAR17 + VAR18 ] = { 0 } ; for ( VAR12 = FUN2 ( 4096 , VAR2 -> VAR19 ) ; VAR12 < VAR2 -> VAR19 - 2 ; VAR12 += 2 ) { int VAR20 , VAR21 , VAR22 , VAR23 ; DCACoreFrameHeader VAR24 ; GetBitContext VAR25 ; VAR5 = VAR4 = VAR2 -> VAR4 + VAR12 ; VAR6 = ( VAR6 << 16 ) | FUN3 ( & VAR5 ) ; if ( VAR12 >= 4 ) VAR15 += FUN4 ( ( ( VAR26 ) FUN5 ( VAR4 ) ) - ( VAR26 ) FUN5 ( VAR4 - 4 ) ) ; if ( VAR6 == VAR27 ) { if ( VAR12 < VAR9 ) continue ; FUN6 ( & VAR25 , VAR4 - 2 , 96 ) ; FUN7 ( & VAR25 , 42 ) ; VAR21 = FUN8 ( & VAR25 ) ; VAR22 = FUN9 ( & VAR25 , 8 + 4 * VAR21 ) + 1 ; VAR23 = FUN9 ( & VAR25 , 16 + 4 * VAR21 ) + 1 ; if ( VAR22 & 3 || VAR23 & 3 ) continue ; if ( VAR22 < 16 || VAR23 < VAR22 ) continue ; if ( VAR12 - 2 + VAR22 > VAR2 -> VAR19 ) continue ; if ( FUN10 ( FUN11 ( VAR28 ) , 0xffff , VAR4 + 3 , VAR22 - 5 ) ) continue ; if ( VAR12 == VAR9 ) VAR8 ++ ; else VAR8 = FUN12 ( 1 , VAR8 - 1 ) ; VAR9 = VAR12 + VAR23 ; continue ; } if ( VAR6 == VAR29 && ( FUN3 ( & VAR5 ) & 0xFC00 ) == 0xFC00 ) VAR20 = 0 ; else if ( VAR6 == VAR30 && ( FUN3 ( & VAR5 ) & 0x00FC ) == 0x00FC ) VAR20 = 1 ; else if ( VAR6 == VAR31 && ( FUN3 ( & VAR5 ) & 0xFFF0 ) == 0x07F0 ) VAR20 = 2 ; else if ( VAR6 == VAR32 && ( FUN3 ( & VAR5 ) & 0xF0FF ) == 0xF007 ) VAR20 = 3 ; else continue ; if ( ( VAR13 = FUN13 ( VAR4 - 2 , VAR17 , VAR16 , VAR17 ) ) < 0 ) continue ; if ( FUN14 ( & VAR25 , VAR16 , VAR13 ) < 0 ) continue ; if ( FUN15 ( & VAR25 , & VAR24 ) < 0 ) continue ; VAR20 += 4 * VAR24 . VAR33 ; VAR7 [ VAR20 ] ++ ; } if ( VAR8 > 3 ) return VAR34 + 1 ; VAR10 = VAR11 = 0 ; for ( VAR14 = 0 ; VAR14 < FUN16 ( VAR7 ) ; VAR14 ++ ) { VAR10 += VAR7 [ VAR14 ] ; if ( VAR7 [ VAR11 ] < VAR7 [ VAR14 ] ) VAR11 = VAR14 ; } if ( VAR7 [ VAR11 ] > 3 && VAR2 -> VAR19 / VAR7 [ VAR11 ] < 32 * 1024 && VAR7 [ VAR11 ] * 4 > VAR10 * 3 && VAR15 / VAR2 -> VAR19 > 200 ) return VAR34 + 1 ; return 0 ; } #0
168#168#static inline void FUN1 ( VAR1 * VAR2 ) { int VAR3 = VAR2 -> VAR4 [ VAR2 -> VAR5 ] -> VAR6 ; int VAR7 = VAR2 -> VAR5 ? VAR2 -> VAR4 [ VAR2 -> VAR5 - 1 ] -> VAR6 : VAR8 ; if ( VAR7 != VAR8 ) VAR2 -> VAR9 [ VAR2 -> VAR5 - 1 ] ++ ; if ( VAR7 == VAR10 ) { if ( VAR3 == VAR11 ) VAR2 -> VAR12 ++ ; else VAR2 -> VAR13 ++ ; } if ( VAR2 -> VAR14 -> VAR15 ) VAR2 -> VAR14 -> FUN2 ( VAR2 ) ; VAR2 -> VAR5 -- ; } #1
169#169#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 , VAR9 , VAR10 , VAR11 , VAR12 , VAR13 , VAR14 , VAR15 = 0 ; const VAR16 * VAR17 = FUN2 ( VAR4 -> VAR18 ) ; VAR8 = FUN3 ( ( VAR6 -> VAR19 + 6 ) / 7 , 1 << VAR17 -> VAR20 ) ; VAR9 = FUN3 ( VAR6 -> VAR21 * 2 / 3 , 1 << VAR17 -> VAR22 ) ; VAR10 = FUN3 ( VAR6 -> VAR21 * 3 / 4 - VAR9 , 1 << VAR17 -> VAR22 ) ; VAR11 = FUN3 ( VAR8 * 5 / 4 , 1 << VAR17 -> VAR20 ) ; VAR12 = VAR6 -> VAR21 - VAR10 - VAR9 ; for ( VAR13 = 0 ; VAR13 < 7 ; VAR13 ++ ) { FUN4 ( VAR6 , VAR23 [ VAR13 ] , VAR15 , 0 , VAR8 , VAR9 , VAR4 ) ; FUN4 ( VAR6 , VAR24 [ VAR13 ] , VAR15 , VAR9 , VAR8 , VAR10 , VAR4 ) ; VAR15 += VAR8 ; } VAR15 = 0 ; FUN4 ( VAR6 , VAR25 , VAR15 , VAR9 + VAR10 , VAR11 , VAR12 , VAR4 ) ; VAR15 += VAR11 ; FUN4 ( VAR6 , VAR26 , VAR15 , VAR9 + VAR10 , VAR11 , VAR12 , VAR4 ) ; VAR15 += VAR11 ; FUN4 ( VAR6 , VAR27 , VAR15 , VAR9 + VAR10 , VAR11 , VAR12 , VAR4 ) ; VAR15 += VAR11 ; VAR14 = FUN3 ( 5 * VAR8 - VAR15 , 1 << VAR17 -> VAR20 ) ; FUN4 ( VAR6 , VAR28 , VAR15 , VAR9 + VAR10 , VAR14 , VAR12 , VAR4 ) ; VAR15 += VAR14 ; VAR14 = FUN3 ( VAR8 / 3 , 1 << VAR17 -> VAR20 ) ; FUN4 ( VAR6 , VAR29 , VAR15 , VAR9 + VAR10 , VAR14 , VAR12 , VAR4 ) ; VAR15 += VAR14 ; FUN4 ( VAR6 , VAR28 , VAR15 , VAR9 + VAR10 , VAR14 , VAR12 , VAR4 ) ; VAR15 += VAR14 ; FUN4 ( VAR6 , VAR30 , VAR15 , VAR9 + VAR10 , VAR14 , VAR12 , VAR4 ) ; VAR15 += VAR14 ; FUN4 ( VAR6 , VAR28 , VAR15 , VAR9 + VAR10 , VAR6 -> VAR19 - VAR15 , VAR12 , VAR4 ) ; } #0
170#170#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { GetBitContext VAR6 ; int VAR7 ; FUN2 ( & VAR6 , VAR4 , VAR5 * 8 ) ; VAR2 -> VAR8 = FUN3 ( & VAR6 ) ; VAR2 -> VAR9 = FUN4 ( & VAR6 , & VAR2 -> VAR10 ) ; VAR2 -> VAR11 = FUN5 ( & VAR6 , 4 ) ; if ( VAR2 -> VAR11 < FUN6 ( VAR12 ) ) VAR2 -> VAR13 = VAR12 [ VAR2 -> VAR11 ] ; VAR2 -> VAR14 = -1 ; if ( VAR2 -> VAR8 == VAR15 || ( VAR2 -> VAR8 == VAR16 && ! ( FUN7 ( & VAR6 , 3 ) & 0x03 && ! ( FUN7 ( & VAR6 , 9 ) & 0x3F ) ) ) ) { VAR2 -> VAR17 = VAR15 ; VAR2 -> VAR14 = 1 ; VAR2 -> VAR18 = FUN4 ( & VAR6 , & VAR2 -> VAR19 ) ; VAR2 -> VAR8 = FUN3 ( & VAR6 ) ; if ( VAR2 -> VAR8 == VAR20 ) VAR2 -> VAR21 = FUN5 ( & VAR6 , 4 ) ; } else { VAR2 -> VAR17 = VAR22 ; VAR2 -> VAR18 = 0 ; } VAR7 = FUN8 ( & VAR6 ) ; if ( VAR2 -> VAR8 == VAR23 ) { FUN9 ( & VAR6 , 5 ) ; if ( FUN10 ( & VAR6 , 24 ) != FUN11 ( ' ' , ' ' , ' ' , ' ' ) ) FUN12 ( & VAR6 , 24 ) ; VAR7 = FUN8 ( & VAR6 ) ; if ( FUN13 ( & VAR6 , VAR2 ) ) return -1 ; } if ( VAR2 -> VAR17 != VAR15 ) { while ( FUN14 ( & VAR6 ) > 15 ) { if ( FUN7 ( & VAR6 , 11 ) == 0x2b7 ) { FUN5 ( & VAR6 , 11 ) ; VAR2 -> VAR17 = FUN3 ( & VAR6 ) ; if ( VAR2 -> VAR17 == VAR15 && ( VAR2 -> VAR14 = FUN15 ( & VAR6 ) ) == 1 ) VAR2 -> VAR18 = FUN4 ( & VAR6 , & VAR2 -> VAR19 ) ; break ; } else FUN15 ( & VAR6 ) ; } } return VAR7 ; } #0
171#171#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 [ VAR3 ] -> VAR10 ; int64_t VAR14 ; int VAR15 , VAR16 , VAR17 ; FUN2 ( VAR7 ) ; VAR14 = FUN3 ( VAR7 ) ; FUN4 ( VAR7 , VAR12 -> VAR18 . VAR19 - 8 , VAR20 ) ; FUN5 ( VAR7 , ) ; VAR12 -> VAR29 = 1 ; } FUN7 ( VAR7 , VAR26 / VAR16 ) ; } else FUN7 ( VAR7 , VAR12 -> VAR18 . VAR30 ) ; FUN4 ( VAR7 , VAR14 , VAR20 ) ; } #0
172#172#static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , VAR3 * * VAR5 , VAR6 * VAR7 ) { int VAR8 = VAR2 -> VAR9 , VAR10 ; while ( VAR8 -- ) { VAR3 * VAR11 = * VAR4 ; if ( ! VAR11 ) { FUN2 ( VAR7 , VAR12 , , VAR2 -> VAR14 -> VAR15 ) ; return FUN3 ( VAR16 ) ; } * VAR4 = ( * VAR4 ) -> VAR17 ; if ( VAR11 -> VAR14 ) { if ( ( VAR10 = FUN4 ( VAR11 -> VAR14 , VAR11 -> VAR18 , VAR2 , VAR8 , VAR7 ) ) < 0 ) return VAR10 ; FUN5 ( VAR11 -> VAR15 ) ; FUN5 ( VAR11 ) ; } else { VAR11 -> VAR14 = VAR2 ; VAR11 -> VAR18 = VAR8 ; FUN6 ( VAR5 , VAR11 ) ; } } if ( * VAR4 ) { FUN2 ( VAR7 , VAR12 , , VAR2 -> VAR14 -> VAR15 ) ; return FUN3 ( VAR16 ) ; } VAR8 = VAR2 -> VAR19 ; while ( VAR8 -- ) { VAR3 * VAR20 = FUN7 ( sizeof ( VAR3 ) ) ; if ( ! VAR20 ) return FUN3 ( VAR21 ) ; VAR20 -> VAR14 = VAR2 ; VAR20 -> VAR18 = VAR8 ; FUN6 ( VAR4 , VAR20 ) ; } return 0 ; } #0
173#173#static APR_INLINE void * FUN1 ( VAR1 * VAR2 , apr_uint32_t VAR3 ) { apr_size_t VAR4 = VAR3 * VAR2 -> VAR5 ; return ( void * ) & VAR2 -> VAR6 [ VAR4 ] ; } #1
174#174#"static av_always_inline void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 , int VAR9 , const void * VAR10 , const void * VAR11 , const void * VAR12 , int VAR13 , enum PixelFormat VAR14 , int VAR15 ) { if ( VAR14 == VAR16 || VAR14 == VAR17 || VAR14 == VAR18 || VAR14 == VAR19 ) { VAR20 * VAR21 = ( VAR20 * ) VAR2 ; const VAR20 * VAR22 = ( const VAR20 * ) VAR10 ; const VAR20 * VAR23 = ( const VAR20 * ) VAR11 ; const VAR20 * VAR24 = ( const VAR20 * ) VAR12 ; #if CONFIG_SMALL int VAR25 = VAR15 ? ( ( VAR14 == VAR26 || VAR14 == VAR27 ) ? 0 : 24 ) : 0 ; VAR21 [ VAR3 * 2 + 0 ] = VAR22 [ VAR4 ] + VAR23 [ VAR4 ] + VAR24 [ VAR4 ] + ( VAR15 ? VAR8 << VAR25 : 0 ) ; VAR21 [ VAR3 * 2 + 1 ] = VAR22 [ VAR5 ] + VAR23 [ VAR5 ] + VAR24 [ VAR5 ] + ( VAR15 ? VAR9 << VAR25 : 0 ) ; #else if (VAR15) { int VAR25 = (VAR14 == VAR26 || VAR14 == VAR27) ? 0 : 24;  VAR21[VAR3 * 2 + 0] = VAR22[VAR4] + VAR23[VAR4] + VAR24[VAR4] + (VAR8 << VAR25); VAR21[VAR3 * 2 + 1] = VAR22[VAR5] + VAR23[VAR5] + VAR24[VAR5] + (VAR9 << VAR25); } else { VAR21[VAR3 * 2 + 0] = VAR22[VAR4] + VAR23[VAR4] + VAR24[VAR4]; VAR21[VAR3 * 2 + 1] = VAR22[VAR5] + VAR23[VAR5] + VAR24[VAR5]; } #endif } else if (VAR14 == VAR28 || VAR14 == VAR29) { VAR1 *VAR21 = (VAR1 *) VAR2; const VAR1 *VAR22 = (const VAR1 *) VAR10; const VAR1 *VAR23 = (const VAR1 *) VAR11; const VAR1 *VAR24 = (const VAR1 *) VAR12;  #define FUN2 ((VAR14 == VAR28) ? VAR22 : VAR24) #define FUN3 ((VAR14 == VAR28) ? VAR24 : VAR22) VAR21[VAR3 * 6 + 0] = VAR30[VAR4]; VAR21[VAR3 * 6 + 1] =   VAR23[VAR4]; VAR21[VAR3 * 6 + 2] = VAR31[VAR4]; VAR21[VAR3 * 6 + 3] = VAR30[VAR5]; VAR21[VAR3 * 6 + 4] =   VAR23[VAR5]; VAR21[VAR3 * 6 + 5] = VAR31[VAR5]; #undef VAR30 #undef VAR31 } else if (VAR14 == VAR32 || VAR14 == VAR33 || VAR14 == VAR34 || VAR14 == VAR35 || VAR14 == VAR36 || VAR14 == VAR37) { VAR38 *VAR21 = (VAR38 *) VAR2; const VAR38 *VAR22 = (const VAR38 *) VAR10; const VAR38 *VAR23 = (const VAR38 *) VAR11; const VAR38 *VAR24 = (const VAR38 *) VAR12; int VAR39, VAR40, VAR41, VAR42, VAR43, VAR44;  if (VAR14 == VAR32 || VAR14 == VAR33) { VAR39 = VAR45[ VAR13 & 1     ][0]; VAR40 = VAR46[ VAR13 & 1     ][0]; VAR41 = VAR45[(VAR13 & 1) ^ 1][0]; VAR42 = VAR45[ VAR13 & 1     ][1]; VAR43 = VAR46[ VAR13 & 1     ][1]; VAR44 = VAR45[(VAR13 & 1) ^ 1][1]; } else if (VAR14 == VAR34 || VAR14 == VAR35) { VAR39 = VAR45[ VAR13 & 1     ][0]; VAR40 = VAR45[ VAR13 & 1     ][1]; VAR41 = VAR45[(VAR13 & 1) ^ 1][0]; VAR42 = VAR45[ VAR13 & 1     ][1]; VAR43 = VAR45[ VAR13 & 1     ][0]; VAR44 = VAR45[(VAR13 & 1) ^ 1][1]; } else { VAR39 = VAR47[ VAR13 & 3     ][0]; VAR40 = VAR47[ VAR13 & 3     ][1]; VAR41 = VAR47[(VAR13 & 3) ^ 3][0]; VAR42 = VAR47[ VAR13 & 3     ][1]; VAR43 = VAR47[ VAR13 & 3     ][0]; VAR44 = VAR47[(VAR13 & 3) ^ 3][1]; }  VAR21[VAR3 * 2 + 0] = VAR22[VAR4 + VAR39] + VAR23[VAR4 + VAR40] + VAR24[VAR4 + VAR41]; VAR21[VAR3 * 2 + 1] = VAR22[VAR5 + VAR42] + VAR23[VAR5 + VAR43] + VAR24[VAR5 + VAR44]; } else  { VAR1 *VAR21 = (VAR1 *) VAR2; const VAR1 *VAR22 = (const VAR1 *) VAR10; const VAR1 *VAR23 = (const VAR1 *) VAR11; const VAR1 *VAR24 = (const VAR1 *) VAR12; int VAR39, VAR40, VAR41, VAR42, VAR43, VAR44;  if (VAR14 == VAR48 || VAR14 == VAR49) { const VAR1 * const VAR50 = VAR51[VAR13 & 7]; const VAR1 * const VAR52 = VAR53[VAR13 & 7]; VAR39 = VAR40 = VAR52[(VAR3 * 2 + 0) & 7]; VAR41 =       VAR50[(VAR3 * 2 + 0) & 7]; VAR42 = VAR43 = VAR52[(VAR3 * 2 + 1) & 7]; VAR44 =       VAR50[(VAR3 * 2 + 1) & 7]; } else { const VAR1 * const VAR50  = VAR51 [VAR13 & 7]; const VAR1 * const VAR54 = VAR55[VAR13 & 7]; VAR39 = VAR41 = VAR54[(VAR3 * 2 + 0) & 7]; VAR40 =        VAR50[(VAR3 * 2 + 0) & 7]; VAR42 = VAR44 = VAR54[(VAR3 * 2 + 1) & 7]; VAR43 =        VAR50[(VAR3 * 2 + 1) & 7]; }  if (VAR14 == VAR56 || VAR14 == VAR57) { VAR21[VAR3] = VAR22[VAR4 + VAR39] + VAR23[VAR4 + VAR40] + VAR24[VAR4 + VAR41] + ((VAR22[VAR5 + VAR42] + VAR23[VAR5 + VAR43] + VAR24[VAR5 + VAR44]) << 4); } else { VAR21[VAR3 * 2 + 0] = VAR22[VAR4 + VAR39] + VAR23[VAR4 + VAR40] + VAR24[VAR4 + VAR41]; VAR21[VAR3 * 2 + 1] = VAR22[VAR5 + VAR42] + VAR23[VAR5 + VAR43] + VAR24[VAR5 + VAR44]; } } } "#1
175#175#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 = 0 , VAR9 , VAR10 , VAR11 = 0 ; if ( ( VAR8 = FUN2 ( VAR6 , VAR2 -> VAR12 , NULL , VAR2 -> VAR13 ) ) < 0 ) goto VAR14 ; if ( VAR6 -> VAR15 == 0 ) { FUN3 ( NULL , VAR16 , ) ; VAR8 = VAR17 ; goto VAR14 ; } if ( VAR6 -> VAR23 ) { int VAR24 = 0 ; for ( VAR9 = 0 ; VAR9 < VAR6 -> VAR18 [ 0 ] -> VAR19 ; VAR9 ++ ) VAR24 += VAR6 -> VAR18 [ 0 ] -> VAR25 [ VAR9 ] -> VAR24 ; VAR2 -> VAR24 = VAR24 * VAR26 ; } VAR6 -> VAR27 = VAR28 ; for ( VAR9 = 0 ; VAR9 < VAR6 -> VAR15 ; VAR9 ++ ) { struct VAR20 * VAR21 = VAR6 -> VAR18 [ VAR9 ] ; if ( VAR21 -> VAR19 == 0 ) continue ; VAR6 -> VAR29 = FUN4 ( VAR6 -> VAR29 , VAR21 -> VAR30 ) ; VAR6 -> VAR27 = FUN5 ( VAR6 -> VAR27 , VAR21 -> VAR30 + VAR21 -> VAR19 ) ; VAR8 = FUN6 ( & VAR21 -> VAR31 , VAR21 -> VAR25 [ 0 ] -> VAR22 , NULL , 0 , NULL ) ; if ( VAR8 < 0 ) goto VAR14 ; FUN7 ( VAR21 -> VAR31 -> VAR13 ) ; VAR21 -> VAR31 -> VAR13 = NULL ; VAR21 -> VAR11 = VAR11 ; for ( VAR10 = 0 ; VAR10 < VAR21 -> VAR31 -> VAR32 ; VAR10 ++ ) { VAR33 * VAR34 = FUN8 ( VAR2 , VAR9 ) ; if ( ! VAR34 ) { VAR8 = FUN9 ( VAR35 ) ; goto VAR14 ; } FUN10 ( VAR34 -> VAR36 , VAR21 -> VAR31 -> VAR37 [ VAR10 ] -> VAR36 ) ; } VAR11 += VAR21 -> VAR31 -> VAR32 ; } VAR6 -> VAR38 = VAR39 ; VAR6 -> VAR40 = VAR6 -> VAR29 ; if ( ! VAR6 -> VAR23 && VAR6 -> VAR27 - VAR6 -> VAR29 > 3 ) VAR6 -> VAR40 = VAR6 -> VAR27 - 2 ; return 0 ; VAR14 : FUN11 ( VAR6 ) ; return VAR8 ; } #1
176#176#"static int FUN1 ( VAR1 * VAR2 , int * VAR3 , int * VAR4 , int * VAR5 , VAR6 * VAR7 ) { struct VAR8 * VAR8 = VAR2 -> VAR9 ; int VAR10 , VAR11 , VAR12 ; struct VAR13 * VAR14 ; int VAR15 = 0 ; int VAR16 = 0 , VAR17 = 0 ; FUN2 ( VAR2 , VAR18 , , VAR10 , VAR14 -> VAR21 , VAR14 -> VAR17 , VAR14 -> VAR16 , VAR14 -> VAR22 ) ; if ( ! VAR14 -> VAR23 ) { if ( VAR14 -> VAR24 < 0 ) { VAR14 -> VAR23 = FUN4 ( VAR14 -> VAR25 , VAR14 -> VAR26 ) ; if ( ! VAR14 -> VAR23 ) { FUN2 ( VAR2 , VAR27 , VAR32 "" "" , VAR14 -> VAR33 ) ; VAR8 -> VAR19 = VAR10 ; VAR14 -> VAR30 = 0 ; if ( VAR14 -> VAR24 ) { VAR14 -> VAR24 = VAR14 -> VAR23 -> FUN5 ( VAR2 , VAR10 ) ; if ( ! VAR14 -> VAR24 ) { VAR14 -> VAR16 = VAR16 ; VAR14 -> VAR17 = VAR17 ; VAR8 -> VAR34 = 1 ; if ( ! VAR2 -> VAR35 -> VAR36 ) VAR2 -> VAR35 -> VAR36 = VAR14 -> VAR37 ; for ( VAR11 = 0 ; VAR11 < VAR8 -> VAR38 ; VAR11 ++ ) { struct VAR13 * VAR39 = VAR8 -> VAR20 + VAR11 ; if ( VAR39 -> VAR30 ) VAR2 -> VAR35 -> VAR36 = FUN6 ( VAR2 -> VAR35 -> VAR36 , VAR39 -> VAR37 ) ; } } else { VAR14 -> VAR40 ++ ; VAR14 -> VAR21 += VAR14 -> VAR17 ; VAR14 -> VAR17 = 0 ; } } else { VAR14 -> VAR41 = 0 ; VAR14 -> VAR42 = 0 ; if ( VAR14 -> VAR23 && VAR14 -> VAR23 -> VAR43 ) VAR14 -> VAR23 -> FUN7 ( VAR2 , VAR10 ) ; if ( VAR3 ) * VAR3 = VAR10 ; if ( VAR4 ) * VAR4 = VAR14 -> VAR21 ; if ( VAR5 ) * VAR5 = VAR14 -> VAR17 ; if ( VAR7 ) * VAR7 = VAR14 -> VAR37 ; VAR14 -> VAR21 += VAR14 -> VAR17 ; VAR14 -> VAR17 = 0 ; if ( VAR14 -> VAR21 == VAR14 -> VAR26 ) VAR14 -> VAR26 = VAR14 -> VAR21 = 0 ; VAR14 -> VAR37 = VAR14 -> VAR33 ; } VAR14 -> VAR44 = 1 ; for ( VAR11 = VAR14 -> VAR16 ; VAR11 < VAR14 -> VAR22 ; VAR11 ++ ) if ( VAR14 -> VAR29 [ VAR11 ] < 255 ) { VAR14 -> VAR44 = 0 ; break ; } if ( VAR14 -> VAR16 == VAR14 -> VAR22 ) VAR8 -> VAR19 = -1 ; return 0 ; } "#1
177#177#"static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 , int VAR9 , int VAR10 ) { int VAR11 = 3 << ( VAR7 - 1 ) , VAR12 , VAR13 , VAR14 , VAR15 , VAR16 ; for ( VAR12 = 0 ; VAR12 < VAR6 ; VAR12 += 4 ) { for ( VAR13 = 0 ; VAR13 < VAR5 ; VAR13 ++ ) { if ( VAR12 + 3 < VAR6 && ! ( ( VAR4 -> VAR17 [ VAR12 + 1 ] [ VAR13 + 1 ] & ( VAR18 | VAR19 | VAR20 ) ) || ( VAR4 -> VAR17 [ VAR12 + 2 ] [ VAR13 + 1 ] & ( VAR18 | VAR19 | VAR20 ) ) || ( VAR4 -> VAR17 [ VAR12 + 3 ] [ VAR13 + 1 ] & ( VAR18 | VAR19 | VAR20 ) ) || ( VAR4 -> VAR17 [ VAR12 + 4 ] [ VAR13 + 1 ] & ( VAR18 | VAR19 | VAR20 ) ) ) ) { if ( ! FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR23 ) ) continue ; VAR15 = FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; VAR15 = ( VAR15 << 1 ) | FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; VAR16 = 1 ; } else { VAR15 = 0 ; VAR16 = 0 ; } for ( VAR14 = VAR12 + VAR15 ; VAR14 < VAR12 + 4 && VAR14 < VAR6 ; VAR14 ++ ) { if ( ! VAR16 ) { if ( ! ( VAR4 -> VAR17 [ VAR14 + 1 ] [ VAR13 + 1 ] & ( VAR20 | VAR19 ) ) ) { int VAR25 = -1 ; if ( VAR10 && VAR14 == VAR12 + 3 ) VAR25 &= ~ ( VAR26 | VAR27 | VAR28 ) ; VAR16 = FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + FUN3 ( VAR4 -> VAR17 [ VAR14 + 1 ] [ VAR13 + 1 ] & VAR25 , VAR8 ) ) ; } } if ( VAR16 ) { int VAR29 ; int VAR30 = FUN4 ( VAR4 -> VAR17 [ VAR14 + 1 ] [ VAR13 + 1 ] , & VAR29 ) ; VAR4 -> VAR31 [ VAR14 ] [ VAR13 ] = ( FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR30 ) ^ VAR29 ) ? - VAR11 : VAR11 ; FUN5 ( VAR4 , VAR13 , VAR14 , VAR4 -> VAR31 [ VAR14 ] [ VAR13 ] < 0 ) ; } VAR16 = 0 ; VAR4 -> VAR17 [ VAR14 + 1 ] [ VAR13 + 1 ] &= ~ VAR19 ; } } } if ( VAR9 ) { int VAR32 ; VAR32 = FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; VAR32 = ( VAR32 << 1 ) + FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; VAR32 = ( VAR32 << 1 ) + FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; VAR32 = ( VAR32 << 1 ) + FUN2 ( & VAR4 -> VAR21 , VAR4 -> VAR21 . VAR22 + VAR24 ) ; if ( VAR32 != 0xa ) FUN6 ( VAR2 -> VAR33 , VAR34 , "" "" ) ; } } "#1
178#178#int FUN1 ( const char * VAR1 , char * * VAR2 , VAR3 * VAR4 ) { int VAR5 ; VAR6 * VAR7 = fopen ( VAR1 , , VAR1 , strerror ( VAR9 ) ) ; return FUN3 ( VAR9 ) ; } FUN4 ( VAR7 , 0 , VAR10 ) ; * VAR4 = FUN5 ( VAR7 ) ; FUN4 ( VAR7 , 0 , VAR11 ) ; * VAR2 = FUN6 ( * VAR4 + 1 ) ; if ( ! * VAR2 ) { FUN2 ( NULL , VAR8 , , VAR1 , strerror ( VAR9 ) ) ; VAR5 = FUN3 ( VAR9 ) ; } else VAR5 = VAR13 ; } else { VAR5 = 0 ; ( * VAR2 ) [ * VAR4 ++ ] = ' ' ; } fclose ( VAR7 ) ; return VAR5 ; } #0
179#179#"static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; VAR10 * VAR11 = VAR3 ; const VAR12 * VAR13 = VAR6 -> VAR3 ; int VAR14 = VAR6 -> VAR15 ; int VAR16 = 0 ; int VAR17 = 0 ; int VAR18 , VAR19 ; int VAR20 = 0 ; for ( VAR18 = 0 ; VAR18 < VAR8 -> VAR21 ; VAR18 ++ ) { VAR22 * VAR23 = & VAR8 -> VAR24 [ VAR18 ] ; VAR23 -> VAR25 [ 0 ] = VAR23 -> VAR25 [ 1 ] = NULL ; VAR20 = FUN2 ( VAR20 , VAR23 -> VAR20 ) ; } if ( VAR13 ) { VAR26 * VAR27 = & VAR8 -> VAR24 [ 0 ] . VAR28 ; VAR19 = FUN3 ( VAR27 , VAR13 , VAR14 , VAR8 -> VAR21 > 1 ) ; if ( VAR19 < 0 ) { FUN4 ( VAR2 , VAR29 , ) ; return VAR19 ; } if ( VAR16 != VAR23 -> VAR28 . VAR30 * VAR23 -> VAR28 . VAR31 ) { FUN4 ( VAR2 , VAR29 , "" "" ) ; return VAR44 ; } VAR17 = VAR19 ; VAR13 += VAR23 -> VAR28 . VAR46 ; VAR14 -= VAR23 -> VAR28 . VAR46 ; } for ( VAR18 = 0 ; VAR18 < VAR2 -> VAR35 ; VAR18 ++ ) { VAR36 * VAR37 = & VAR8 -> VAR38 [ VAR18 ] ; if ( VAR37 -> copy ) { memcpy ( VAR11 -> VAR41 [ VAR18 ] , VAR11 -> VAR41 [ VAR37 -> VAR47 ] , VAR11 -> VAR43 [ 0 ] ) ; } else if ( VAR37 -> VAR48 ) { memset ( VAR11 -> VAR41 [ VAR18 ] , 0 , VAR11 -> VAR43 [ 0 ] ) ; } if ( VAR8 -> VAR49 ) { VAR8 -> VAR50 -> FUN8 ( ( float * ) VAR11 -> VAR41 [ VAR18 ] , ( float * ) VAR11 -> VAR41 [ VAR18 ] , VAR8 -> VAR51 , FUN9 ( VAR17 , 8 ) ) ; } } VAR11 -> VAR34 = VAR17 ; * VAR4 = ! ! VAR17 ; return VAR6 -> VAR15 ; } "#0
180#180#int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { int VAR5 , VAR6 , VAR7 ; unsigned char * VAR8 ; VAR5 = VAR3 / 8 ; VAR6 = 1 << ( 7 - ( VAR3 & 0x07 ) ) ; VAR7 = ~ VAR6 ; VAR2 -> VAR9 &= ~ ( VAR10 | 0x07 ) ; if ( VAR2 == NULL ) return ( 0 ) ; if ( ( VAR2 -> VAR11 < ( VAR5 + 1 ) ) || ( VAR2 -> VAR12 == NULL ) ) { if ( ! VAR4 ) return ( 1 ) ; if ( VAR2 -> VAR12 == NULL ) VAR8 = ( unsigned char * ) FUN2 ( VAR5 + 1 ) ; else VAR8 = ( unsigned char * ) FUN3 ( VAR2 -> VAR12 , VAR5 + 1 ) ; if ( VAR8 == NULL ) return ( 0 ) ; if ( VAR5 + 1 - VAR2 -> VAR11 > 0 ) memset ( VAR8 + VAR2 -> VAR11 , 0 , VAR5 + 1 - VAR2 -> VAR11 ) ; VAR2 -> VAR12 = VAR8 ; VAR2 -> VAR11 = VAR5 + 1 ; } VAR2 -> VAR12 [ VAR5 ] = ( ( VAR2 -> VAR12 [ VAR5 ] ) & VAR7 ) | VAR6 ; while ( ( VAR2 -> VAR11 > 0 ) && ( VAR2 -> VAR12 [ VAR2 -> VAR11 - 1 ] == 0 ) ) VAR2 -> VAR11 -- ; return ( 1 ) ; } #0
181#181#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int * VAR5 , VAR6 * VAR7 , int VAR8 ) { VAR9 * VAR10 = VAR2 -> VAR11 ; VAR12 * VAR13 = VAR10 -> VAR14 ; VAR15 * VAR16 ; int VAR17 , VAR18 , VAR19 , VAR20 , VAR21 , VAR22 ; uint64_t VAR23 ; if ( FUN2 ( VAR13 ) > VAR2 -> VAR24 + VAR2 -> VAR25 ) { FUN3 ( VAR10 , VAR26 , VAR27 ) ; return VAR28 ; } if ( VAR17 > 4096 ) * VAR7 = 0 ; VAR17 -= VAR2 -> VAR44 [ * VAR7 ] ; if ( VAR18 & VAR45 ) { FUN8 ( VAR13 ) ; } else if ( VAR17 > 2 * VAR2 -> VAR25 || FUN9 ( VAR16 -> VAR38 - * VAR4 ) > VAR16 -> VAR46 ) { FUN3 ( VAR10 , VAR26 , "" "" ) ; return VAR28 ; } VAR16 -> VAR38 = * VAR4 ; VAR16 -> VAR47 = VAR18 ; return VAR17 ; } "#0
182#182#"int FUN1 ( VAR1 ) ( VAR2 * VAR3 , VAR4 * VAR5 , const VAR4 * VAR6 , int * VAR7 , int VAR8 , int VAR9 , int VAR10 ) { int VAR11 , VAR12 ; int VAR13 = VAR3 -> VAR13 ; int VAR14 = VAR3 -> VAR14 ; int VAR15 = VAR3 -> VAR16 % VAR3 -> VAR17 ; int VAR16 = VAR3 -> VAR16 / VAR3 -> VAR17 ; FUN2 ( VAR3 -> VAR18 == VAR19 ) ; FUN2 ( VAR3 -> VAR20 == sizeof ( VAR21 ) ) ; if ( VAR3 -> VAR22 == 1 && VAR3 -> VAR23 == 0 ) { int64_t VAR24 = ( 1LL << 32 ) * VAR3 -> VAR14 / VAR3 -> VAR17 + ( 1LL << 32 ) * VAR13 ; int64_t VAR25 = ( 1LL << 32 ) * VAR3 -> VAR16 / VAR3 -> VAR17 ; int VAR26 = ( VAR8 * ( VAR27 ) VAR3 -> VAR17 - VAR14 + VAR3 -> VAR16 - 1 ) / VAR3 -> VAR16 ; VAR9 = FUN3 ( VAR9 , VAR26 ) ; for ( VAR11 = 0 ; VAR11 < VAR9 ; VAR11 ++ ) { VAR5 [ VAR11 ] = VAR6 [ VAR24 >> 32 ] ; VAR24 += VAR25 ; } VAR13 += VAR11 * VAR16 ; VAR13 += ( VAR14 + VAR11 * ( VAR27 ) VAR15 ) / VAR3 -> VAR17 ; VAR14 = ( VAR14 + VAR11 * ( VAR27 ) VAR15 ) % VAR3 -> VAR17 ; FUN4 ( VAR13 >= 0 ) ; * VAR7 = VAR13 ; VAR13 = 0 ; } else if ( VAR13 >= 0 ) { int64_t VAR28 = ( 1LL + VAR8 - VAR3 -> VAR22 ) << VAR3 -> VAR23 ; int64_t VAR29 = ( VAR28 - VAR13 ) * VAR3 -> VAR17 - VAR3 -> VAR14 ; int VAR30 = ( VAR29 + VAR3 -> VAR16 - 1 ) / VAR3 -> VAR16 ; int VAR31 = FUN3 ( VAR9 , VAR30 ) ; int VAR32 ; if ( ! VAR3 -> VAR33 ) { VAR32 = VAR13 >> VAR3 -> VAR23 ; VAR13 &= VAR3 -> VAR34 ; for ( VAR11 = 0 ; VAR11 < VAR31 ; VAR11 ++ ) { VAR21 * VAR35 = ( ( VAR21 * ) VAR3 -> VAR36 ) + VAR3 -> VAR37 * VAR13 ; #ifdef COMMON_CORE VAR38 #else FELEM2 VAR39 = 0 ; for ( VAR12 = 0 ; VAR12 < VAR3 -> VAR22 ; VAR12 ++ ) { VAR39 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 ] ; } FUN5 ( VAR5 [ VAR11 ] , VAR39 ) ; #endif VAR14 += VAR15 ; VAR13 += VAR16 ; if ( VAR14 >= VAR3 -> VAR17 ) { VAR14 -= VAR3 -> VAR17 ; VAR13 ++ ; } VAR32 += VAR13 >> VAR3 -> VAR23 ; VAR13 &= VAR3 -> VAR34 ; } } else { VAR32 = VAR13 >> VAR3 -> VAR23 ; VAR13 &= VAR3 -> VAR34 ; for ( VAR11 = 0 ; VAR11 < VAR31 ; VAR11 ++ ) { VAR21 * VAR35 = ( ( VAR21 * ) VAR3 -> VAR36 ) + VAR3 -> VAR37 * VAR13 ; FELEM2 VAR39 = 0 , VAR41 = 0 ; #ifdef LINEAR_CORE VAR42 #else for ( VAR12 = 0 ; VAR12 < VAR3 -> VAR22 ; VAR12 ++ ) { VAR39 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 ] ; VAR41 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 + VAR3 -> VAR37 ] ; } #endif VAR39 += ( VAR41 - VAR39 ) * ( VAR43 ) VAR14 / VAR3 -> VAR17 ; FUN5 ( VAR5 [ VAR11 ] , VAR39 ) ; VAR14 += VAR15 ; VAR13 += VAR16 ; if ( VAR14 >= VAR3 -> VAR17 ) { VAR14 -= VAR3 -> VAR17 ; VAR13 ++ ; } VAR32 += VAR13 >> VAR3 -> VAR23 ; VAR13 &= VAR3 -> VAR34 ; } } * VAR7 = VAR32 ; } else { int VAR32 = 0 ; for ( VAR11 = 0 ; VAR11 < VAR9 ; VAR11 ++ ) { VAR21 * VAR35 ; FELEM2 VAR39 = 0 ; VAR32 += VAR13 >> VAR3 -> VAR23 ; VAR13 &= VAR3 -> VAR34 ; VAR35 = ( ( VAR21 * ) VAR3 -> VAR36 ) + VAR3 -> VAR37 * VAR13 ; if ( VAR32 + VAR3 -> VAR22 > VAR8 || - VAR32 >= VAR8 ) { break ; } else if ( VAR32 < 0 ) { for ( VAR12 = 0 ; VAR12 < VAR3 -> VAR22 ; VAR12 ++ ) VAR39 += VAR6 [ FUN6 ( VAR32 + VAR12 ) ] * ( VAR40 ) VAR35 [ VAR12 ] ; FUN5 ( VAR5 [ VAR11 ] , VAR39 ) ; } else if ( VAR3 -> VAR33 ) { FELEM2 VAR41 = 0 ; #ifdef LINEAR_CORE VAR42 #else for ( VAR12 = 0 ; VAR12 < VAR3 -> VAR22 ; VAR12 ++ ) { VAR39 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 ] ; VAR41 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 + VAR3 -> VAR37 ] ; } #endif VAR39 += ( VAR41 - VAR39 ) * ( VAR43 ) VAR14 / VAR3 -> VAR17 ; FUN5 ( VAR5 [ VAR11 ] , VAR39 ) ; } else { #ifdef COMMON_CORE VAR38 #else for ( VAR12 = 0 ; VAR12 < VAR3 -> VAR22 ; VAR12 ++ ) { VAR39 += VAR6 [ VAR32 + VAR12 ] * ( VAR40 ) VAR35 [ VAR12 ] ; } FUN5 ( VAR5 [ VAR11 ] , VAR39 ) ; #endif } VAR14 += VAR15 ; VAR13 += VAR16 ; if ( VAR14 >= VAR3 -> VAR17 ) { VAR14 -= VAR3 -> VAR17 ; VAR13 ++ ; } } * VAR7 = FUN7 ( VAR32 , 0 ) ; VAR13 += FUN3 ( VAR32 , 0 ) << VAR3 -> VAR23 ; } if ( VAR10 ) { VAR3 -> VAR14 = VAR14 ; VAR3 -> VAR13 = VAR13 ; } return VAR11 ; } "#1
183#183#static inline void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , VAR3 * VAR6 , int VAR7 , VAR3 * * VAR8 , VAR9 * VAR10 ) { int VAR11 , VAR12 ; int VAR13 , VAR14 , VAR15 ; const int VAR16 = VAR2 -> VAR17 -> VAR16 ; const int VAR18 = 8 >> VAR16 ; VAR13 = VAR2 -> VAR13 ; VAR14 = VAR2 -> VAR14 ; switch ( VAR2 -> VAR19 ) { case VAR20 : FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , 0 , 0 , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 1 ] , 2 * VAR18 , VAR14 ) ; break ; case VAR22 : VAR11 = 0 ; VAR12 = 0 ; for ( VAR15 = 0 ; VAR15 < 4 ; VAR15 ++ ) { FUN3 ( VAR2 , VAR4 + ( ( VAR15 & 1 ) + ( VAR15 >> 1 ) * VAR2 -> VAR23 ) * VAR18 , VAR8 [ 0 ] , 0 , 0 , ( 2 * VAR13 + ( VAR15 & 1 ) ) * VAR18 , ( 2 * VAR14 + ( VAR15 >> 1 ) ) * VAR18 , VAR2 -> VAR24 , VAR2 -> VAR25 , VAR2 -> VAR23 , VAR2 -> VAR26 >> VAR16 , VAR2 -> VAR27 >> VAR16 , VAR18 , VAR18 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 1 ] ) ; VAR11 += VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 0 ] ; VAR12 += VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 1 ] ; } if ( ! VAR28 || ! ( VAR2 -> VAR29 & VAR30 ) ) FUN4 ( VAR2 , VAR5 , VAR6 , VAR8 , VAR10 , VAR11 , VAR12 ) ; break ; case VAR31 : if ( VAR2 -> VAR32 == VAR33 ) { FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 1 , 0 , VAR2 -> VAR34 [ VAR7 ] [ 0 ] , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 1 ] , VAR18 , VAR14 ) ; FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 1 , 1 , VAR2 -> VAR34 [ VAR7 ] [ 1 ] , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 1 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 1 ] [ 1 ] , VAR18 , VAR14 ) ; } else { if ( VAR2 -> VAR32 != VAR2 -> VAR34 [ VAR7 ] [ 0 ] + 1 && VAR2 -> VAR35 != VAR36 && ! VAR2 -> VAR37 ) { VAR8 = VAR2 -> VAR38 -> VAR39 . VAR40 ; } FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , 0 , VAR2 -> VAR34 [ VAR7 ] [ 0 ] , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 0 ] [ 1 ] , 2 * VAR18 , VAR14 >> 1 ) ; } break ; case VAR41 : for ( VAR15 = 0 ; VAR15 < 2 ; VAR15 ++ ) { VAR3 * * VAR42 ; if ( VAR2 -> VAR32 == VAR2 -> VAR34 [ VAR7 ] [ VAR15 ] + 1 || VAR2 -> VAR35 == VAR36 || VAR2 -> VAR37 ) { VAR42 = VAR8 ; } else { VAR42 = VAR2 -> VAR38 -> VAR39 . VAR40 ; } FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , 0 , VAR2 -> VAR34 [ VAR7 ] [ VAR15 ] , VAR42 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ VAR15 ] [ 1 ] + 2 * VAR18 * VAR15 , VAR18 , VAR14 >> 1 ) ; VAR4 += 2 * VAR18 * VAR2 -> VAR23 ; VAR5 += ( 2 * VAR18 >> VAR2 -> VAR43 ) * VAR2 -> VAR44 ; VAR6 += ( 2 * VAR18 >> VAR2 -> VAR43 ) * VAR2 -> VAR44 ; } break ; case VAR45 : if ( VAR2 -> VAR32 == VAR33 ) { for ( VAR15 = 0 ; VAR15 < 2 ; VAR15 ++ ) { int VAR46 ; for ( VAR46 = 0 ; VAR46 < 2 ; VAR46 ++ ) { FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 1 , VAR46 , VAR46 ^ VAR15 , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 2 * VAR15 + VAR46 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 2 * VAR15 + VAR46 ] [ 1 ] , VAR18 , VAR14 ) ; } VAR10 = VAR2 -> VAR47 . VAR48 ; } } else { for ( VAR15 = 0 ; VAR15 < 2 ; VAR15 ++ ) { FUN2 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , 0 , VAR2 -> VAR32 != VAR15 + 1 , VAR8 , VAR10 , VAR2 -> VAR21 [ VAR7 ] [ 2 * VAR15 ] [ 0 ] , VAR2 -> VAR21 [ VAR7 ] [ 2 * VAR15 ] [ 1 ] , 2 * VAR18 , VAR14 >> 1 ) ; VAR10 = VAR2 -> VAR47 . VAR48 ; if ( ! VAR2 -> VAR37 ) { VAR8 = VAR2 -> VAR38 -> VAR39 . VAR40 ; } } } break ; default : FUN5 ( 0 ) ; } } #1
184#184#int FUN1 ( enum PixelFormat VAR1 , int VAR2 , int VAR3 ) { const VAR4 * VAR5 = & VAR6 [ VAR1 ] ; int VAR7 [ 4 ] ; int VAR8 [ 4 ] ; if ( ( unsigned ) VAR1 >= VAR9 || VAR5 -> VAR10 & VAR11 ) return FUN2 ( VAR12 ) ; FUN3 ( VAR7 , VAR8 , VAR5 ) ; return FUN4 ( VAR2 , VAR3 , VAR7 [ VAR3 ] , VAR8 [ VAR3 ] , VAR5 ) ; } #0
185#185#void FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 , VAR4 * VAR6 ) { int64_t VAR7 = VAR8 ; int VAR9 = 0 ; int VAR10 ; if ( VAR2 -> VAR11 || VAR2 -> VAR12 ) { if ( VAR2 -> VAR13 -> VAR5 != VAR8 ) VAR7 = VAR2 -> VAR13 -> VAR5 ; } if ( ! VAR2 -> VAR11 ) FUN2 ( VAR2 -> VAR14 , VAR15 , , VAR3 ) ; } if ( VAR6 ) * VAR6 = FUN3 ( VAR2 -> VAR14 , VAR9 ) ; } #1
186#186#"static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 ; VAR4 -> VAR7 = 0 ; VAR4 -> VAR8 = VAR2 ; VAR4 -> VAR9 = 0 ; FUN2 ( & VAR4 -> VAR10 ) ; for ( VAR6 = 0 ; VAR6 < VAR11 ; VAR6 ++ ) { FUN3 ( & VAR4 -> VAR12 [ VAR6 ] , 44100 , VAR4 -> VAR13 ) ; } FUN4 ( VAR2 , VAR14 , , ( VAR4 -> VAR16 ) ? ) ; FUN4 ( VAR2 , VAR14 , : , VAR4 -> VAR18 , VAR19 [ VAR4 -> VAR18 ] ) ; if ( VAR4 -> VAR20 ) FUN5 ( VAR2 -> VAR21 , VAR22 ) ; FUN4 ( VAR2 , VAR14 , : : "" "" ) ; return 0 ; } "#0
187#187#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR4 ; VAR5 * VAR6 ; FUN2 ( VAR4 ) ; FUN2 ( VAR4 ) ; FUN2 ( VAR4 ) ; VAR6 = FUN3 ( VAR2 , NULL ) ; if ( ! VAR6 ) return FUN4 ( VAR7 ) ; VAR6 -> VAR8 -> VAR9 = VAR10 ; VAR6 -> VAR8 -> VAR11 = VAR12 ; FUN2 ( VAR4 ) ; VAR6 -> VAR8 -> VAR13 = FUN2 ( VAR4 ) ; if ( FUN5 ( VAR2 , VAR6 -> VAR8 , VAR4 , 2 * 4 ) < 0 ) return FUN4 ( VAR7 ) ; if ( FUN2 ( VAR4 ) ) { VAR6 -> VAR8 -> VAR14 = 2 ; VAR6 -> VAR8 -> VAR15 = VAR16 ; } else { VAR6 -> VAR8 -> VAR14 = 1 ; VAR6 -> VAR8 -> VAR15 = VAR17 ; } VAR6 -> VAR8 -> VAR18 = 4 ; VAR6 -> VAR8 -> VAR19 = ( VAR20 ) VAR6 -> VAR8 -> VAR18 * VAR6 -> VAR8 -> VAR14 * VAR6 -> VAR8 -> VAR13 ; VAR6 -> VAR8 -> VAR21 = 1 ; return 0 ; } #0
188#188#static int FUN1 ( VAR1 * VAR2 , VAR1 * VAR3 ) { int VAR4 ; int VAR5 = ( VAR2 [ 3 ] & 0xC0 ) == 0x80 && ( VAR2 [ 4 ] & 0xC0 ) != 0x40 && ( ( VAR2 [ 4 ] & 0xC0 ) == 0x00 || ( VAR2 [ 4 ] & 0xC0 ) >> 2 == ( VAR2 [ 6 ] & 0xF0 ) ) ; for ( VAR2 += 3 ; VAR2 < VAR3 && * VAR2 == 0xFF ; VAR2 ++ ) ; if ( ( * VAR2 & 0xC0 ) == 0x40 ) VAR2 += 2 ; if ( ( * VAR2 & 0xF0 ) == 0x20 ) { VAR4 = VAR2 [ 0 ] & VAR2 [ 2 ] & VAR2 [ 4 ] & 1 ; VAR2 += 5 ; } else if ( ( * VAR2 & 0xF0 ) == 0x30 ) { VAR4 = VAR2 [ 0 ] & VAR2 [ 2 ] & VAR2 [ 4 ] & VAR2 [ 5 ] & VAR2 [ 7 ] & VAR2 [ 9 ] & 1 ; VAR2 += 10 ; } else VAR4 = * VAR2 == 0x0F ; return VAR4 || VAR5 ; } #1
189#189#"int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 = 1 ; VAR2 -> VAR5 -- ; FUN2 ( VAR2 , 1 , -1 ) ; if ( ( VAR2 -> VAR5 == 0 ) && VAR2 -> VAR6 ) { if ( VAR3 ) FUN3 ( VAR7 ) ; VAR4 = VAR2 -> FUN4 ( VAR2 ) ; if ( VAR3 ) FUN5 ( VAR7 ) ; if ( ! VAR4 ) return 0 ; } #ifdef VAR8 if ( VAR2 -> VAR5 < 0 ) { fprintf ( VAR9 , "" "" ) ; FUN6 ( ) ; } #endif if ( ! FUN7 ( VAR2 , 0 ) ) { FUN8 ( VAR10 , VAR11 ) ; return 0 ; } return VAR4 ; } "#1
190#190#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 , VAR7 * VAR8 , int VAR9 ) { unsigned VAR10 ; VAR2 -> VAR11 . FUN2 ( VAR4 ) ; VAR10 = FUN3 ( VAR2 , VAR6 ) ; if ( VAR10 == 0xfffff ) { FUN4 ( VAR2 -> VAR12 , VAR13 , "" "" ) ; return VAR14 ; } VAR10 = ( VAR10 * ( VAR8 [ 0 ] << VAR9 ) ) + VAR2 -> VAR15 [ VAR5 ] ; VAR2 -> VAR15 [ VAR5 ] = VAR10 ; VAR4 [ 0 ] = VAR10 ; return 0 ; } "#0
191#191#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 , const VAR7 * VAR8 ) { const VAR7 * VAR9 = ( VAR8 + VAR6 ) ; uint32_t VAR10 , VAR11 ; VAR7 * VAR12 , * VAR13 , * VAR14 , * VAR15 ; unsigned int VAR16 , VAR17 ; char * VAR18 , * VAR19 , * VAR20 , * VAR21 ; VAR10 = 0 ; VAR11 = 0 ; for ( VAR17 = VAR4 -> VAR22 ; VAR17 < VAR4 -> VAR23 ; VAR17 += 4 ) { VAR18 = VAR19 = VAR20 = VAR21 = VAR2 -> VAR24 -> VAR8 [ 0 ] + ( VAR2 -> VAR25 ? VAR4 -> VAR26 : VAR4 -> VAR26 * 3 ) + ( VAR17 * VAR2 -> VAR24 -> VAR27 [ 0 ] ) ; if ( VAR2 -> VAR28 -> VAR29 - VAR17 > 1 ) { VAR19 = VAR18 + VAR2 -> VAR24 -> VAR27 [ 0 ] ; if ( VAR2 -> VAR28 -> VAR29 - VAR17 > 2 ) { VAR20 = VAR19 + VAR2 -> VAR24 -> VAR27 [ 0 ] ; if ( VAR2 -> VAR28 -> VAR29 - VAR17 > 3 ) { VAR21 = VAR20 + VAR2 -> VAR24 -> VAR27 [ 0 ] ; } } } for ( VAR16 = VAR4 -> VAR26 ; VAR16 < VAR4 -> VAR30 ; VAR16 += 4 ) { if ( ( VAR5 & 0x01 ) && ! ( VAR11 >>= 1 ) ) { if ( ( VAR8 + 4 ) > VAR9 ) return VAR31 ; VAR10 = FUN2 ( VAR8 ) ; VAR8 += 4 ; VAR11 = 0x80000000 ; } if ( ! ( VAR5 & 0x01 ) || ( VAR10 & VAR11 ) ) { if ( ! ( VAR5 & 0x02 ) && ! ( VAR11 >>= 1 ) ) { if ( ( VAR8 + 4 ) > VAR9 ) return VAR31 ; VAR10 = FUN2 ( VAR8 ) ; VAR8 += 4 ; VAR11 = 0x80000000 ; } if ( ( VAR5 & 0x02 ) || ( ~ VAR10 & VAR11 ) ) { VAR7 * VAR32 ; if ( VAR8 >= VAR9 ) return VAR31 ; VAR32 = VAR4 -> VAR33 [ * VAR8 ++ ] ; if ( VAR2 -> VAR25 ) { VAR21 [ 0 ] = VAR21 [ 1 ] = VAR20 [ 0 ] = VAR20 [ 1 ] = VAR32 [ 6 ] ; VAR21 [ 2 ] = VAR21 [ 3 ] = VAR20 [ 2 ] = VAR20 [ 3 ] = VAR32 [ 9 ] ; VAR19 [ 0 ] = VAR19 [ 1 ] = VAR18 [ 0 ] = VAR18 [ 1 ] = VAR32 [ 0 ] ; VAR19 [ 2 ] = VAR19 [ 3 ] = VAR18 [ 2 ] = VAR18 [ 3 ] = VAR32 [ 3 ] ; } else { VAR32 += 6 ; memcpy ( VAR21 + 0 , VAR32 , 3 ) ; memcpy ( VAR21 + 3 , VAR32 , 3 ) ; memcpy ( VAR20 + 0 , VAR32 , 3 ) ; memcpy ( VAR20 + 3 , VAR32 , 3 ) ; VAR32 += 3 ; memcpy ( VAR21 + 6 , VAR32 , 3 ) ; memcpy ( VAR21 + 9 , VAR32 , 3 ) ; memcpy ( VAR20 + 6 , VAR32 , 3 ) ; memcpy ( VAR20 + 9 , VAR32 , 3 ) ; VAR32 -= 9 ; memcpy ( VAR19 + 0 , VAR32 , 3 ) ; memcpy ( VAR19 + 3 , VAR32 , 3 ) ; memcpy ( VAR18 + 0 , VAR32 , 3 ) ; memcpy ( VAR18 + 3 , VAR32 , 3 ) ; VAR32 += 3 ; memcpy ( VAR19 + 6 , VAR32 , 3 ) ; memcpy ( VAR19 + 9 , VAR32 , 3 ) ; memcpy ( VAR18 + 6 , VAR32 , 3 ) ; memcpy ( VAR18 + 9 , VAR32 , 3 ) ; } } else if ( VAR10 & VAR11 ) { if ( ( VAR8 + 4 ) > VAR9 ) return VAR31 ; VAR12 = VAR4 -> VAR34 [ * VAR8 ++ ] ; VAR13 = VAR4 -> VAR34 [ * VAR8 ++ ] ; VAR14 = VAR4 -> VAR34 [ * VAR8 ++ ] ; VAR15 = VAR4 -> VAR34 [ * VAR8 ++ ] ; if ( VAR2 -> VAR25 ) { VAR7 * VAR32 ; VAR32 = VAR21 ; * VAR32 ++ = VAR14 [ 6 ] ; * VAR32 ++ = VAR14 [ 9 ] ; * VAR32 ++ = VAR15 [ 6 ] ; * VAR32 = VAR15 [ 9 ] ; VAR32 = VAR20 ; * VAR32 ++ = VAR14 [ 0 ] ; * VAR32 ++ = VAR14 [ 3 ] ; * VAR32 ++ = VAR15 [ 0 ] ; * VAR32 = VAR15 [ 3 ] ; VAR32 = VAR19 ; * VAR32 ++ = VAR12 [ 6 ] ; * VAR32 ++ = VAR12 [ 9 ] ; * VAR32 ++ = VAR13 [ 6 ] ; * VAR32 = VAR13 [ 9 ] ; VAR32 = VAR18 ; * VAR32 ++ = VAR12 [ 0 ] ; * VAR32 ++ = VAR12 [ 3 ] ; * VAR32 ++ = VAR13 [ 0 ] ; * VAR32 = VAR13 [ 3 ] ; } else { memcpy ( VAR21 + 0 , VAR14 + 6 , 6 ) ; memcpy ( VAR21 + 6 , VAR15 + 6 , 6 ) ; memcpy ( VAR20 + 0 , VAR14 + 0 , 6 ) ; memcpy ( VAR20 + 6 , VAR15 + 0 , 6 ) ; memcpy ( VAR19 + 0 , VAR12 + 6 , 6 ) ; memcpy ( VAR19 + 6 , VAR13 + 6 , 6 ) ; memcpy ( VAR18 + 0 , VAR12 + 0 , 6 ) ; memcpy ( VAR18 + 6 , VAR13 + 0 , 6 ) ; } } } if ( VAR2 -> VAR25 ) { VAR18 += 4 ; VAR19 += 4 ; VAR20 += 4 ; VAR21 += 4 ; } else { VAR18 += 12 ; VAR19 += 12 ; VAR20 += 12 ; VAR21 += 12 ; } } } return 0 ; } #1
192#192#int FUN1 ( const VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 , int VAR6 , VAR7 * VAR8 ) { int VAR9 , VAR10 , VAR11 = -1 ; int VAR12 ; VAR4 * VAR13 = NULL ; VAR1 * VAR14 , * VAR15 , * VAR16 , * VAR17 ; VAR18 * VAR19 = NULL ; if ( FUN2 ( VAR2 , 2 ) || FUN2 ( VAR2 , 3 ) ) return 1 ; if ( ! FUN3 ( VAR2 ) || FUN4 ( VAR2 , FUN5 ( ) ) <= 0 ) return 0 ; if ( VAR3 == VAR20 ) VAR3 = FUN6 ( FUN7 ( VAR2 ) ) ; if ( VAR6 ) { for ( VAR9 = 1 ; VAR9 < VAR21 ; VAR9 ++ ) { BN_ULONG VAR22 = FUN8 ( VAR2 , VAR23 [ VAR9 ] ) ; if ( VAR22 == ( VAR24 ) - 1 ) goto VAR25 ; if ( VAR22 == 0 ) return FUN2 ( VAR2 , VAR23 [ VAR9 ] ) ; } if ( ! FUN9 ( VAR8 , 1 , -1 ) ) goto VAR25 ; } if ( VAR5 != NULL ) VAR13 = VAR5 ; else if ( ( VAR13 = FUN10 ( ) ) == NULL ) goto VAR25 ; FUN11 ( VAR13 ) ; VAR14 = FUN12 ( VAR13 ) ; VAR16 = FUN12 ( VAR13 ) ; VAR15 = FUN12 ( VAR13 ) ; VAR17 = FUN12 ( VAR13 ) ; if ( VAR17 == NULL ) goto VAR25 ; if ( ! FUN13 ( VAR14 , VAR2 ) || ! FUN14 ( VAR14 , 1 ) ) goto VAR25 ; if ( ! FUN13 ( VAR16 , VAR2 ) || ! FUN14 ( VAR16 , 3 ) ) goto VAR25 ; VAR12 = 1 ; while ( ! FUN15 ( VAR14 , VAR12 ) ) VAR12 ++ ; if ( ! FUN16 ( VAR15 , VAR14 , VAR12 ) ) goto VAR25 ; VAR19 = FUN17 ( ) ; if ( VAR19 == NULL ) goto VAR25 ; if ( ! FUN18 ( VAR19 , VAR2 , VAR13 ) ) goto VAR25 ; for ( VAR9 = 0 ; VAR9 < VAR3 ; VAR9 ++ ) { if ( ! FUN19 ( VAR17 , VAR16 ) || ! FUN20 ( VAR17 , 2 ) ) goto VAR25 ; VAR10 = FUN21 ( VAR17 , VAR2 , VAR14 , VAR15 , VAR12 , VAR13 , VAR19 ) ; if ( VAR10 == -1 ) goto VAR25 ; if ( VAR10 ) { VAR11 = 0 ; goto VAR25 ; } if ( ! FUN9 ( VAR8 , 1 , VAR9 ) ) goto VAR25 ; } VAR11 = 1 ; VAR25 : if ( VAR13 != NULL ) { FUN22 ( VAR13 ) ; if ( VAR5 == NULL ) FUN23 ( VAR13 ) ; } FUN24 ( VAR19 ) ; return VAR11 ; } #0
193#193#int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 ) { VAR4 * VAR5 , * VAR6 , VAR7 , VAR8 ; int VAR9 , VAR10 ; FUN2 ( VAR2 ) ; FUN2 ( VAR3 ) ; if ( FUN3 ( VAR3 ) ) { FUN4 ( VAR2 ) ; return 1 ; } VAR9 = VAR3 -> VAR11 ; VAR5 = VAR3 -> VAR12 ; VAR10 = VAR9 - ( VAR5 [ VAR9 - 1 ] == 1 ) ; if ( VAR3 != VAR2 ) { if ( FUN5 ( VAR2 , VAR10 ) == NULL ) return 0 ; VAR2 -> VAR13 = VAR3 -> VAR13 ; } VAR6 = VAR2 -> VAR12 ; VAR7 = VAR5 [ -- VAR9 ] ; VAR8 = ( VAR7 & 1 ) ? VAR14 : 0 ; if ( VAR7 >>= 1 ) VAR6 [ VAR9 ] = VAR7 ; while ( VAR9 > 0 ) { VAR7 = VAR5 [ -- VAR9 ] ; VAR6 [ VAR9 ] = ( ( VAR7 >> 1 ) & VAR15 ) | VAR8 ; VAR8 = ( VAR7 & 1 ) ? VAR14 : 0 ; } VAR2 -> VAR11 = VAR10 ; if ( ! VAR2 -> VAR11 ) VAR2 -> VAR13 = 0 ; FUN2 ( VAR2 ) ; return 1 ; } #1
194#194#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 [ 0 ] -> VAR11 ; int VAR12 , VAR13 ; VAR13 = VAR14 * VAR9 -> VAR15 ; VAR4 -> VAR16 = FUN2 ( VAR2 -> VAR17 ) ; VAR4 -> VAR18 = 0 ; VAR12 = FUN3 ( VAR2 -> VAR17 , VAR4 , VAR13 ) ; if ( VAR12 != VAR13 ) { FUN4 ( VAR4 ) ; return VAR12 < 0 ? VAR12 : FUN5 ( VAR19 ) ; } if ( FUN6 ( VAR4 -> VAR20 ) & 0x8000 ) { FUN4 ( VAR4 ) ; return VAR21 ; } VAR4 -> VAR13 = VAR13 ; VAR4 -> VAR22 = 1 ; VAR4 -> VAR23 = ( VAR4 -> VAR16 - VAR6 -> VAR24 ) / VAR13 ; return 0 ; } #1
195#195#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 = FUN2 ( VAR2 -> VAR4 . VAR5 , 4 ) ; int VAR6 = FUN2 ( VAR2 -> VAR4 . VAR7 , 4 ) ; int VAR8 , VAR9 , VAR10 , VAR11 ; for ( VAR8 = 0 ; VAR8 < 3 ; VAR8 ++ ) { int VAR12 = VAR13 >> ( VAR8 ? VAR2 -> VAR14 : 0 ) ; int VAR15 = VAR13 >> ( VAR8 ? VAR2 -> VAR16 : 0 ) ; VAR9 = VAR2 -> VAR4 . VAR5 >> ( VAR8 ? VAR2 -> VAR14 : 0 ) ; VAR10 = VAR2 -> VAR4 . VAR7 >> ( VAR8 ? VAR2 -> VAR16 : 0 ) ; VAR11 = FUN3 ( 1 << VAR17 , VAR15 / 2 ) ; VAR9 = FUN4 ( FUN5 ( VAR9 , VAR17 ) , 8 ) ; VAR10 = VAR11 + FUN5 ( VAR10 , VAR17 ) + VAR15 / 2 ; VAR2 -> VAR18 [ VAR8 ] . VAR19 = FUN6 ( ( VAR9 + VAR12 ) , VAR10 * sizeof ( VAR20 ) ) ; VAR2 -> VAR18 [ VAR8 ] . VAR21 = FUN7 ( ( VAR9 + 16 ) , sizeof ( VAR20 ) ) ; VAR2 -> VAR18 [ VAR8 ] . VAR22 = VAR2 -> VAR18 [ VAR8 ] . VAR19 + VAR11 * VAR9 ; if ( ! VAR2 -> VAR18 [ VAR8 ] . VAR19 || ! VAR2 -> VAR18 [ VAR8 ] . VAR21 ) return FUN8 ( VAR23 ) ; } VAR9 = VAR2 -> VAR4 . VAR5 ; VAR10 = VAR2 -> VAR4 . VAR7 ; VAR2 -> VAR24 = FUN7 ( VAR3 , VAR6 ) ; VAR2 -> VAR25 = FUN7 ( VAR3 , VAR6 * 16 * sizeof ( * VAR2 -> VAR25 ) ) ; VAR2 -> VAR26 = FUN7 ( ( VAR9 + 64 ) , VAR13 ) ; VAR2 -> VAR27 = FUN7 ( ( VAR9 + 64 + VAR13 ) , ( VAR10 + VAR13 ) * sizeof ( * VAR2 -> VAR27 ) ) ; VAR2 -> VAR28 = FUN7 ( ( VAR9 + 64 ) , VAR13 ) ; if ( ! VAR2 -> VAR24 || ! VAR2 -> VAR25 || ! VAR2 -> VAR27 || ! VAR2 -> VAR28 ) return FUN8 ( VAR23 ) ; return 0 ; } #1
196#196#"static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; VAR14 * VAR15 = VAR3 ; GetBitContext VAR16 ; FUN2 ( & VAR16 , VAR8 , VAR9 * 8 ) ; while ( FUN3 ( & VAR16 ) + VAR12 -> VAR17 <= VAR9 * 8 ) * VAR15 ++ = FUN4 ( VAR12 , FUN5 ( & VAR16 , VAR12 -> VAR17 ) ) ; if ( VAR9 * 8 != FUN3 ( & VAR16 ) ) FUN6 ( VAR2 , VAR18 , "" "" ) ; * VAR4 = ( VAR7 * ) VAR15 - ( VAR7 * ) VAR3 ; return VAR9 ; } "#1
197#197#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { int VAR6 , VAR7 ; const int VAR8 = VAR2 -> VAR9 -> VAR8 ; const int VAR10 = VAR2 -> VAR9 -> VAR10 ; VAR11 * VAR12 = ( VAR11 * ) VAR2 -> VAR13 . VAR14 [ 0 ] ; VAR11 * VAR15 = ( VAR11 * ) VAR2 -> VAR16 . VAR14 [ 0 ] ; const int VAR17 = VAR2 -> VAR16 . VAR18 [ 0 ] >> 1 ; unsigned int VAR19 , VAR20 , VAR21 , VAR22 ; if ( VAR2 -> VAR23 > 1 ) { VAR22 = 20 ; VAR19 = FUN2 ( VAR4 + 8 ) ; VAR21 = FUN2 ( VAR4 + 12 ) ; VAR20 = FUN2 ( VAR4 + 16 ) ; } else { VAR22 = 0 ; VAR19 = FUN3 ( VAR4 - 4 ) ; VAR21 = FUN3 ( VAR4 - 2 ) ; VAR20 = FUN4 ( VAR5 - VAR19 - VAR21 , 0 ) ; } if ( VAR19 + VAR20 + VAR21 + VAR22 != VAR5 || VAR19 > ( 1 << 26 ) || VAR20 > ( 1 << 26 ) || VAR21 > ( 1 << 26 ) ) { FUN5 ( VAR2 -> VAR9 , VAR24 , , VAR19 - ( FUN12 ( & VAR2 -> VAR31 ) + 31 ) / 32 * 4 , - ( ( ( const char * ) VAR2 -> VAR33 - ( const char * ) VAR4 + 3 ) & ~ 3 ) + ( VAR22 + VAR19 + VAR21 + VAR20 ) , - ( ( ( const char * ) VAR2 -> VAR32 - ( const char * ) VAR4 + 2 ) & ~ 2 ) + ( VAR22 + VAR19 + VAR21 ) ) ; return 0 ; } #1
198#198#"const VAR1 * FUN1 ( VAR2 * VAR3 , FUN2 ( VAR1 ) * VAR4 , FUN2 ( VAR1 ) * VAR5 ) { const VAR1 * VAR6 , * VAR7 = NULL ; FUN2 ( VAR1 ) * VAR8 , * VAR9 ; int VAR10 , VAR11 , VAR12 ; unsigned long VAR13 = 0 , VAR14 = 0 , VAR15 = 0 , VAR16 = 0 ; #ifndef VAR17 FUN2 ( VAR1 ) * VAR18 = NULL ; #endif #ifdef VAR19 fprintf ( VAR20 , , ( void * ) VAR6 , VAR6 -> VAR21 ) ; } fprintf ( VAR20 , , ( void * ) VAR6 , VAR6 -> VAR21 ) ; } #endif if ( FUN5 ( VAR3 ) ) { VAR8 = VAR5 ; VAR9 = VAR4 ; } else if ( VAR3 -> VAR22 & VAR23 ) { VAR8 = VAR5 ; VAR9 = VAR4 ; #ifndef OPENSSL_NO_CHACHA if ( VAR3 -> VAR22 & VAR24 && FUN3 ( VAR4 ) > 0 ) { VAR6 = FUN4 ( VAR4 , 0 ) ; if ( VAR6 -> VAR25 == VAR26 ) { int VAR27 = FUN3 ( VAR5 ) ; int VAR28 = 0 ; for ( VAR10 = 0 ; VAR10 < VAR27 ; VAR10 ++ ) { VAR6 = FUN4 ( VAR5 , VAR10 ) ; if ( VAR6 -> VAR25 == VAR26 ) { VAR28 = 1 ; break ; } } if ( VAR28 ) { VAR18 = FUN6 ( ) ; if ( VAR18 != NULL ) { FUN7 ( VAR18 , VAR6 ) ; for ( VAR10 ++ ; VAR10 < VAR27 ; VAR10 ++ ) { VAR6 = FUN4 ( VAR5 , VAR10 ) ; if ( VAR6 -> VAR25 == VAR26 ) FUN7 ( VAR18 , VAR6 ) ; } for ( VAR10 = 0 ; VAR10 < VAR27 ; VAR10 ++ ) { VAR6 = FUN4 ( VAR5 , VAR10 ) ; if ( VAR6 -> VAR25 != VAR26 ) FUN7 ( VAR18 , VAR6 ) ; } VAR8 = VAR18 ; } } } } # endif } else { VAR8 = VAR4 ; VAR9 = VAR5 ; } if ( ! FUN8 ( VAR3 ) ) { FUN9 ( VAR3 ) ; FUN10 ( VAR3 ) ; } for ( VAR10 = 0 ; VAR10 < FUN3 ( VAR8 ) ; VAR10 ++ ) { VAR6 = FUN4 ( VAR8 , VAR10 ) ; if ( ! FUN11 ( VAR3 ) && ( ( VAR3 -> VAR29 < VAR6 -> VAR30 ) || ( VAR3 -> VAR29 > VAR6 -> VAR31 ) ) ) continue ; if ( FUN11 ( VAR3 ) && ( FUN12 ( VAR3 -> VAR29 , VAR6 -> VAR32 ) || FUN13 ( VAR3 -> VAR29 , VAR6 -> VAR33 ) ) ) continue ; if ( ! FUN8 ( VAR3 ) ) { VAR15 = VAR3 -> VAR34 -> VAR35 . VAR15 ; VAR16 = VAR3 -> VAR34 -> VAR35 . VAR16 ; #ifndef OPENSSL_NO_SRP if ( VAR3 -> VAR36 . VAR37 & VAR38 ) { VAR15 |= VAR38 ; VAR16 |= VAR39 ; } #endif VAR13 = VAR6 -> VAR40 ; VAR14 = VAR6 -> VAR41 ; #ifndef OPENSSL_NO_PSK if ( ( VAR13 & VAR42 ) && VAR3 -> VAR43 == NULL ) continue ; #endif VAR12 = ( VAR13 & VAR15 ) && ( VAR14 & VAR16 ) ; #ifdef VAR19 fprintf ( VAR20 , "" "" , VAR12 , VAR13 , VAR14 , VAR15 , VAR16 , ( void * ) VAR6 , VAR6 -> VAR21 ) ; #endif #ifndef OPENSSL_NO_EC if ( VAR13 & VAR44 ) VAR12 = VAR12 && FUN14 ( VAR3 , VAR6 -> VAR45 ) ; #endif if (!VAR12) continue; } VAR11 = FUN15(VAR9, VAR6); if (VAR11 >= 0) {  if (!FUN16(VAR3, VAR46, VAR6->VAR47, 0, (void *)VAR6)) continue; #if !FUN17(VAR48) if ((VAR13 & VAR44) && (VAR14 & VAR49) && VAR3->VAR34->VAR50) { if (!VAR7) VAR7 = FUN4(VAR9, VAR11); continue; } #endif VAR7 = FUN4(VAR9, VAR11); break; } } #ifndef VAR17 FUN18(VAR18); #endif return VAR7; } "#0
199#199#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , VAR9 * VAR10 , int VAR11 , int * VAR12 , VAR13 * VAR14 ) { int VAR15 ; int VAR16 = 0 , VAR17 = 0 , VAR18 = 0 , VAR19 = 0 ; int VAR20 ; VAR15 = FUN2 ( VAR4 ) ; VAR11 -- ; VAR20 = VAR15 >> 6 ; if ( VAR20 != 3 ) { VAR16 = FUN2 ( VAR4 ) ; VAR11 -- ; } if ( VAR20 != 1 ) { VAR18 = FUN3 ( VAR4 , & VAR11 ) ; VAR19 = FUN3 ( VAR4 , & VAR11 ) ; VAR17 = FUN2 ( VAR4 ) ; VAR11 -- ; } if ( VAR11 < 0 ) return -1 ; VAR6 -> VAR21 = VAR11 ; if ( VAR20 & 1 ) { if ( VAR20 == 3 ) { VAR11 = VAR18 ; * VAR14 = VAR19 ; } if ( VAR6 -> VAR21 < VAR11 ) return -1 ; VAR6 -> VAR21 -= VAR11 ; if ( FUN4 ( VAR10 , VAR11 + 9 ) < 0 ) return FUN5 ( VAR22 ) ; VAR10 -> VAR23 [ 0 ] = 0 ; FUN6 ( VAR10 -> VAR23 + 1 , 1 ) ; FUN6 ( VAR10 -> VAR23 + 5 , 0 ) ; FUN7 ( VAR4 , VAR10 -> VAR23 + 9 , VAR11 ) ; return 0 ; } * VAR12 = VAR16 ; if ( ( VAR16 & 0x7F ) == 1 || VAR8 -> VAR24 != VAR17 ) { VAR8 -> VAR25 = ( ( VAR15 & 0x3F ) << 1 ) + 1 ; VAR8 -> VAR26 = VAR18 + 8 * VAR8 -> VAR25 + 1 ; FUN8 ( & VAR8 -> VAR10 ) ; if ( FUN4 ( & VAR8 -> VAR10 , VAR8 -> VAR26 ) < 0 ) return FUN5 ( VAR27 ) ; VAR8 -> VAR28 = 8 * VAR8 -> VAR25 + 1 ; VAR8 -> VAR29 = 0 ; VAR8 -> VAR24 = VAR17 ; VAR8 -> VAR30 = FUN9 ( VAR4 ) ; } if ( VAR20 == 2 ) VAR11 = FUN10 ( VAR11 , VAR19 ) ; if ( ++ VAR8 -> VAR29 > VAR8 -> VAR25 ) return 1 ; FUN6 ( VAR8 -> VAR10 . VAR23 - 7 + 8 * VAR8 -> VAR29 , 1 ) ; FUN6 ( VAR8 -> VAR10 . VAR23 - 3 + 8 * VAR8 -> VAR29 , VAR8 -> VAR28 - 8 * VAR8 -> VAR25 - 1 ) ; if ( VAR8 -> VAR28 + VAR11 > VAR8 -> VAR26 ) return 1 ; if ( FUN7 ( VAR4 , VAR8 -> VAR10 . VAR23 + VAR8 -> VAR28 , VAR11 ) != VAR11 ) return FUN5 ( VAR22 ) ; VAR8 -> VAR28 += VAR11 ; VAR6 -> VAR21 -= VAR11 ; if ( VAR20 == 2 || VAR8 -> VAR28 == VAR8 -> VAR26 ) { VAR8 -> VAR10 . VAR23 [ 0 ] = VAR8 -> VAR29 - 1 ; * VAR10 = VAR8 -> VAR10 ; VAR8 -> VAR10 . VAR23 = NULL ; VAR8 -> VAR10 . VAR31 = 0 ; if ( VAR8 -> VAR25 != VAR8 -> VAR29 ) memmove ( VAR10 -> VAR23 + 1 + 8 * VAR8 -> VAR29 , VAR10 -> VAR23 + 1 + 8 * VAR8 -> VAR25 , VAR8 -> VAR28 - 1 - 8 * VAR8 -> VAR25 ) ; VAR10 -> VAR31 = VAR8 -> VAR28 + 8 * ( VAR8 -> VAR29 - VAR8 -> VAR25 ) ; VAR10 -> VAR32 = VAR33 ; VAR10 -> VAR19 = VAR8 -> VAR30 ; VAR8 -> VAR25 = 0 ; return 0 ; } return 1 ; } #0
200#200#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR2 -> VAR8 ; VAR9 * VAR10 = VAR4 -> VAR11 [ 0 ] ; VAR12 * VAR13 , * VAR14 = NULL , * VAR15 = NULL ; int VAR16 ; if ( ( VAR16 = FUN2 ( & VAR7 -> VAR2 , 0 , & VAR14 , 0 ) ) < 0 || ( VAR16 = FUN2 ( & VAR7 -> VAR2 , 1 , & VAR15 , 0 ) ) < 0 ) return VAR16 ; if ( VAR4 -> VAR17 || ! VAR15 ) { VAR13 = FUN3 ( VAR14 ) ; if ( ! VAR13 ) return FUN4 ( VAR18 ) ; } else { VAR13 = FUN5 ( VAR10 , VAR10 -> VAR19 , VAR10 -> VAR20 ) ; if ( ! VAR13 ) return FUN4 ( VAR18 ) ; FUN6 ( VAR13 , VAR14 ) ; VAR7 -> FUN7 ( VAR7 , VAR13 , VAR14 , VAR15 ) ; } VAR13 -> VAR21 = FUN8 ( VAR7 -> VAR2 . VAR21 , VAR7 -> VAR2 . VAR22 , VAR10 -> VAR22 ) ; return FUN9 ( VAR10 , VAR13 ) ; } #0
201#201#int FUN1 ( VAR1 * VAR2 , unsigned char * * VAR3 ) { unsigned char * VAR4 ; if ( ( VAR2 == NULL ) || ( VAR2 -> VAR5 == NULL ) ) return ( 0 ) ; if ( VAR3 == NULL ) return ( FUN2 ( 0 , VAR2 -> VAR6 , VAR7 ) ) ; VAR4 = * VAR3 ; FUN3 ( & VAR4 , 0 , VAR2 -> VAR6 , VAR7 , VAR8 ) ; memcpy ( VAR4 , VAR2 -> VAR5 , VAR2 -> VAR6 ) ; VAR4 += VAR2 -> VAR6 ; * VAR3 = VAR4 ; return ( VAR2 -> VAR6 ) ; } #1
202#202#"static int FUN1 ( void * VAR1 , const VAR2 * VAR3 , const char * VAR4 , int * VAR5 ) { int VAR6 ; if ( ! VAR4 || ! strcmp ( VAR4 , % VAR8 "" "" "#1
203#203#static void FUN1 ( const VAR1 * VAR2 , VAR3 * restrict VAR4 , int VAR5 ) { int VAR6 ; for ( VAR6 = 0 ; VAR6 < 4 ; VAR6 ++ ) { VAR4 [ 0 ] = FUN2 ( VAR4 [ 0 ] + VAR2 [ 0 ] ) ; VAR4 [ 1 ] = FUN2 ( VAR4 [ 1 ] + VAR2 [ 1 ] ) ; VAR4 [ 2 ] = FUN2 ( VAR4 [ 2 ] + VAR2 [ 2 ] ) ; VAR4 [ 3 ] = FUN2 ( VAR4 [ 3 ] + VAR2 [ 3 ] ) ; VAR4 += VAR5 ; VAR2 += 8 ; } } #0
204#204#VAR1 * FUN1 ( VAR2 * VAR3 , enum AVPacketSideDataType VAR4 , int * VAR5 ) { int VAR6 ; for ( VAR6 = 0 ; VAR6 < VAR3 -> VAR7 ; VAR6 ++ ) { if ( VAR3 -> VAR8 [ VAR6 ] . VAR4 == VAR4 ) { if ( VAR5 ) * VAR5 = VAR3 -> VAR8 [ VAR6 ] . VAR5 ; return VAR3 -> VAR8 [ VAR6 ] . VAR9 ; } } return NULL ; } #1
205#205#static av_cold int FUN1 ( VAR1 * VAR2 ) { FUN2 ( VAR2 , 0 , 1 , 1 ) ; FUN3 ( VAR2 -> VAR3 , 1 ) ; return 0 ; } #0
206#206#static int FUN1 ( CT_TEST_FIXTURE VAR1 ) { int VAR2 = 0 ; VAR3 * VAR4 = NULL , * VAR5 = NULL ; FUN2 ( VAR6 ) * VAR7 = NULL ; VAR6 * VAR8 = NULL ; char VAR9 [ VAR10 ] ; int VAR11 = 0 ; unsigned char * VAR12 = NULL ; size_t VAR13 = 0 ; VAR14 * VAR15 = FUN3 ( ) ; if ( VAR1 . VAR16 != NULL ) { VAR11 = FUN4 ( VAR1 . VAR17 , VAR1 . VAR16 , VAR9 , VAR10 - 1 ) ; if ( VAR11 < 0 ) { fprintf ( VAR18 , , VAR1 . VAR22 ) ; goto VAR19 ; } FUN8 ( VAR15 , VAR4 ) ; if ( VAR1 . VAR27 != NULL ) { VAR5 = FUN7 ( VAR1 . VAR26 , VAR1 . VAR27 ) ; if ( VAR5 == NULL ) { fprintf ( VAR18 , , VAR1 . VAR22 ) ; goto VAR19 ; } if ( VAR1 . VAR16 && FUN12 ( VAR25 , VAR9 ) ) { goto VAR19 ; } if ( VAR1 . VAR30 ) { int VAR31 ; VAR7 = FUN13 ( VAR25 ) ; for ( VAR31 = 0 ; VAR31 < FUN14 ( VAR7 ) ; ++ VAR31 ) { VAR6 * VAR32 = FUN15 ( VAR7 , VAR31 ) ; if ( ! FUN16 ( VAR32 , VAR33 ) ) { fprintf ( VAR18 , , VAR1 . VAR22 ) ; goto VAR19 ; } } if ( VAR1 . VAR12 != NULL ) { const unsigned char * VAR34 = VAR1 . VAR12 ; if ( FUN18 ( & VAR7 , & VAR34 , VAR1 . VAR13 ) == NULL ) { fprintf ( VAR18 , ) ; goto VAR19 ; } } VAR2 = 1 ; VAR19 : FUN21 ( VAR4 ) ; FUN21 ( VAR5 ) ; FUN22 ( VAR7 ) ; FUN23 ( VAR8 ) ; FUN24 ( VAR15 ) ; FUN25 ( VAR12 ) ; return VAR2 ; } #1
207#207#int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 , VAR7 , VAR8 , VAR9 ; int VAR10 , VAR11 ; const int VAR12 = VAR2 -> VAR13 ? 1 : 8 ; int VAR14 , VAR15 ; VAR3 = FUN2 ( & VAR2 -> VAR16 , 16 ) ; VAR4 = FUN2 ( & VAR2 -> VAR16 , 8 ) ; if ( VAR3 != 6 + 2 * VAR4 ) { FUN3 ( VAR2 -> VAR17 , VAR18 , , VAR11 ) ; for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR4 ; VAR10 ++ ) if ( VAR11 == VAR2 -> VAR20 [ VAR10 ] ) break ; if ( VAR10 == VAR2 -> VAR4 ) { FUN3 ( VAR2 -> VAR17 , VAR18 , , VAR2 -> VAR13 ? , VAR2 -> VAR42 ? , VAR8 , VAR9 , VAR14 , VAR2 -> VAR43 , VAR2 -> VAR44 ? : ) ; return -1 ; } #1
208#208#"static void FUN1 ( void ) { static char VAR1 [ VAR2 ] ; char * VAR3 = VAR1 ; size_t VAR4 = 0 ; static int VAR5 = 1 ; int VAR6 ; FUN2 ( VAR7 ) ; if ( ! VAR5 ) { FUN3 ( VAR7 ) ; return ; } for ( VAR6 = 1 ; VAR6 <= VAR8 ; VAR6 ++ ) { VAR9 * VAR10 = & VAR11 [ VAR6 - 1 ] ; VAR10 -> VAR12 = FUN4 ( VAR13 , 0 , VAR6 ) ; if ( VAR10 -> VAR14 == NULL ) { if ( FUN5 ( VAR6 , VAR3 , sizeof ( VAR1 ) - VAR4 ) ) { size_t VAR15 = strlen ( VAR3 ) + 1 ; VAR10 -> VAR14 = VAR3 ; VAR4 += VAR15 ; if ( VAR4 > sizeof ( VAR1 ) ) VAR4 = sizeof ( VAR1 ) ; VAR3 += VAR15 ; } } if ( VAR10 -> VAR14 == NULL ) VAR10 -> VAR14 = "" "" ; } VAR5 = 0 ; FUN3 ( VAR7 ) ; FUN6 ( VAR11 ) ; } "#1
209#209#static int FUN1 ( VAR1 * VAR2 , unsigned long * VAR3 , VAR4 * VAR5 ) { int VAR6 ; unsigned char * VAR7 ; VAR6 = FUN2 ( VAR5 , NULL ) ; if ( ! FUN3 ( VAR2 , ( int ) ( VAR6 + ( * VAR3 ) + 3 ) ) ) { FUN4 ( VAR8 , VAR9 ) ; return 0 ; } VAR7 = ( unsigned char * ) & ( VAR2 -> VAR10 [ * VAR3 ] ) ; FUN5 ( VAR6 , VAR7 ) ; FUN2 ( VAR5 , & VAR7 ) ; * VAR3 += VAR6 + 3 ; return 1 ; } #1
210#210#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , int VAR7 , int VAR8 , VAR9 * VAR10 , int VAR11 ) { int VAR12 , VAR13 , VAR14 , VAR15 , VAR16 ; if ( ! ( VAR16 = FUN2 ( VAR2 , 1 ) ) ) { FUN3 ( VAR2 ) ; return 0 ; } else if ( VAR16 < 0 ) return VAR16 ; for ( VAR12 = 0 ; VAR12 < VAR6 -> VAR17 ; VAR12 ++ ) { VAR18 * VAR19 = VAR6 -> VAR19 + VAR12 ; VAR20 * VAR21 = VAR19 -> VAR21 + VAR7 ; int VAR22 = 0 ; if ( VAR19 -> VAR23 [ 0 ] [ 0 ] == VAR19 -> VAR23 [ 0 ] [ 1 ] || VAR19 -> VAR23 [ 1 ] [ 0 ] == VAR19 -> VAR23 [ 1 ] [ 1 ] ) continue ; for ( VAR13 = VAR21 -> VAR24 ; VAR13 < VAR21 -> VAR25 ; VAR13 ++ ) for ( VAR14 = VAR21 -> VAR26 , VAR15 = VAR13 * VAR19 -> VAR14 + VAR14 ; VAR14 < VAR21 -> VAR27 ; VAR14 ++ , VAR15 ++ , VAR22 ++ ) { VAR28 * VAR29 = VAR19 -> VAR29 + VAR15 ; int VAR30 , VAR31 , VAR32 ; if ( VAR29 -> VAR33 ) VAR30 = FUN2 ( VAR2 , 1 ) ; else VAR30 = FUN4 ( VAR2 , VAR21 -> VAR34 + VAR22 , VAR8 + 1 ) == VAR8 ; if ( ! VAR30 ) continue ; else if ( VAR30 < 0 ) return VAR30 ; if ( ! VAR29 -> VAR33 ) VAR29 -> VAR35 = VAR10 [ VAR12 ] + VAR11 - 1 - FUN4 ( VAR2 , VAR21 -> VAR36 + VAR22 , 100 ) ; if ( ( VAR31 = FUN5 ( VAR2 ) ) < 0 ) return VAR31 ; if ( ( VAR32 = FUN6 ( VAR2 ) ) < 0 ) return VAR32 ; VAR29 -> VAR37 += VAR32 ; if ( ( VAR16 = FUN2 ( VAR2 , FUN7 ( VAR31 ) + VAR29 -> VAR37 ) ) < 0 ) return VAR16 ; VAR29 -> VAR38 = VAR16 ; VAR29 -> VAR33 += VAR31 ; } } FUN3 ( VAR2 ) ; if ( VAR4 -> VAR39 & VAR40 ) { if ( FUN8 ( & VAR2 -> VAR41 ) == VAR42 ) { FUN9 ( & VAR2 -> VAR41 , 2 ) ; } else { FUN10 ( VAR2 -> VAR43 , VAR44 , "" "" ) ; } } for ( VAR12 = 0 ; VAR12 < VAR6 -> VAR17 ; VAR12 ++ ) { VAR18 * VAR19 = VAR6 -> VAR19 + VAR12 ; int VAR45 , VAR46 = VAR19 -> VAR21 [ VAR7 ] . VAR27 - VAR19 -> VAR21 [ VAR7 ] . VAR26 ; for ( VAR45 = VAR19 -> VAR21 [ VAR7 ] . VAR24 ; VAR45 < VAR19 -> VAR21 [ VAR7 ] . VAR25 ; VAR45 ++ ) { int VAR47 ; for ( VAR47 = VAR19 -> VAR21 [ VAR7 ] . VAR26 ; VAR47 < VAR19 -> VAR21 [ VAR7 ] . VAR27 ; VAR47 ++ ) { VAR28 * VAR29 = VAR19 -> VAR29 + VAR45 * VAR46 + VAR47 ; if ( FUN11 ( & VAR2 -> VAR41 ) < VAR29 -> VAR38 || sizeof ( VAR29 -> VAR48 ) < VAR29 -> VAR38 ) return FUN12 ( VAR49 ) ; FUN13 ( & VAR2 -> VAR41 , VAR29 -> VAR48 , VAR29 -> VAR38 ) ; VAR29 -> VAR50 += VAR29 -> VAR38 ; VAR29 -> VAR38 = 0 ; } } } return 0 ; } "#0
211#211#"int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { unsigned char * VAR5 ; int VAR6 ; switch ( VAR4 -> VAR7 ) { case VAR8 : FUN2 ( VAR2 , ) ; break ; case VAR10 : FUN2 ( VAR2 , , VAR4 -> VAR12 . VAR13 -> VAR14 ) ; break ; case VAR15 : FUN2 ( VAR2 , , VAR4 -> VAR12 . VAR13 -> VAR14 ) ; break ; case VAR17 : FUN2 ( VAR2 , , VAR5 [ 0 ] , VAR5 [ 1 ] , VAR5 [ 2 ] , VAR5 [ 3 ] ) ; else if ( VAR4 -> VAR12 . VAR21 -> VAR22 == 16 ) { FUN2 ( VAR2 , , VAR5 [ 0 ] << 8 | VAR5 [ 1 ] ) ; VAR5 += 2 ; } FUN4 ( VAR2 , ) ; break ; } break ; case VAR23 : FUN2 ( VAR2 , "" "" ) ; FUN5 ( VAR2 , VAR4 -> VAR12 . VAR24 ) ; break ; } return 1 ; } "#0
212#212#static int FUN1 ( VAR1 * VAR2 , unsigned short VAR3 , const unsigned char * VAR4 , unsigned short VAR5 , int * VAR6 , void * VAR7 ) { if ( VAR8 == VAR3 ) { VAR9 = ( memchr ( VAR4 , VAR10 , VAR5 ) != NULL ) ; } if ( VAR11 == VAR3 ) { VAR12 = ( memchr ( VAR4 , VAR10 , VAR5 ) != NULL ) ; } return 1 ; } #0
213#213#"int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 , VAR5 * VAR6 ) { VAR1 * VAR7 , * VAR8 = NULL , * VAR9 = NULL , * VAR10 = NULL , * VAR11 ; int VAR12 = 0 ; FUN2 ( VAR3 ) ; FUN2 ( VAR4 ) ; FUN3 ( VAR6 ) ; if ( ( VAR7 = FUN4 ( VAR6 ) ) == NULL ) goto VAR13 ; if ( ( VAR8 = FUN4 ( VAR6 ) ) == NULL ) goto VAR13 ; if ( ( VAR9 = FUN4 ( VAR6 ) ) == NULL ) goto VAR13 ; if ( ( VAR10 = FUN4 ( VAR6 ) ) == NULL ) goto VAR13 ; if ( ! FUN5 ( VAR9 , VAR3 , VAR4 ) ) goto VAR13 ; if ( FUN6 ( VAR9 ) ) goto VAR13 ; if ( ! FUN7 ( VAR10 , VAR4 ) ) goto VAR13 ; # if 0 if ( ! FUN8 ( VAR7 ) ) goto VAR13 ; while ( 1 ) { while ( ! FUN9 ( VAR9 ) ) { if ( FUN6 ( VAR9 ) ) goto VAR13 ; if ( ! FUN10 ( VAR9 , VAR9 ) ) goto VAR13 ; if ( FUN9 ( VAR7 ) ) { if ( ! FUN11 ( VAR7 , VAR7 , VAR4 ) ) goto VAR13 ; } if ( ! FUN10 ( VAR7 , VAR7 ) ) goto VAR13 ; } if ( FUN12 ( VAR9 , 1 ) ) break ; if ( FUN13 ( VAR9 ) < FUN13 ( VAR10 ) ) { VAR11 = VAR9 ; VAR9 = VAR10 ; VAR10 = VAR11 ; VAR11 = VAR7 ; VAR7 = VAR8 ; VAR8 = VAR11 ; } if ( ! FUN11 ( VAR9 , VAR9 , VAR10 ) ) goto VAR13 ; if ( ! FUN11 ( VAR7 , VAR7 , VAR8 ) ) goto VAR13 ; } # else { int VAR14; int VAR15 = FUN13(VAR9); int VAR16 = FUN13(VAR10);  int VAR17 = VAR4->VAR17; VAR18 *VAR19, *VAR20, *VAR21, *VAR22;  if (!FUN14(VAR9, VAR17)) goto VAR13; VAR19 = VAR9->VAR23; for (VAR14 = VAR9->VAR17; VAR14 < VAR17; VAR14++) VAR19[VAR14] = 0; VAR9->VAR17 = VAR17; if (!FUN14(VAR7, VAR17)) goto VAR13; VAR20 = VAR7->VAR23; VAR20[0] = 1; for (VAR14 = 1; VAR14 < VAR17; VAR14++) VAR20[VAR14] = 0; VAR7->VAR17 = VAR17; if (!FUN14(VAR8, VAR17)) goto VAR13; VAR22 = VAR8->VAR23; for (VAR14 = 0; VAR14 < VAR17; VAR14++) VAR22[VAR14] = 0; VAR8->VAR17 = VAR17; VAR21 = VAR10->VAR23;              while (1) { while (VAR15 && !(VAR19[0] & 1)) { BN_ULONG VAR24, VAR25, VAR26, VAR27, VAR28;  VAR24 = VAR19[0]; VAR26 = VAR20[0]; VAR28 = (VAR18)0 - (VAR26 & 1); VAR26 ^= VAR4->VAR23[0] & VAR28; for (VAR14 = 0; VAR14 < VAR17 - 1; VAR14++) { VAR25 = VAR19[VAR14 + 1]; VAR19[VAR14] = ((VAR24 >> 1) | (VAR25 << (VAR29 - 1))) & VAR30; VAR24 = VAR25; VAR27 = VAR20[VAR14 + 1] ^ (VAR4->VAR23[VAR14 + 1] & VAR28); VAR20[VAR14] = ((VAR26 >> 1) | (VAR27 << (VAR29 - 1))) & VAR30; VAR26 = VAR27; } VAR19[VAR14] = VAR24 >> 1; VAR20[VAR14] = VAR26 >> 1; VAR15--; }  if (VAR15 <= VAR29) { if (VAR19[0] == 0)  goto VAR13; if (VAR19[0] == 1) break; }  if (VAR15 < VAR16) { VAR14 = VAR15; VAR15 = VAR16; VAR16 = VAR14; VAR11 = VAR9; VAR9 = VAR10; VAR10 = VAR11; VAR11 = VAR7; VAR7 = VAR8; VAR8 = VAR11; VAR19 = VAR21; VAR21 = VAR10->VAR23; VAR20 = VAR22; VAR22 = VAR8->VAR23; } for (VAR14 = 0; VAR14 < VAR17; VAR14++) { VAR19[VAR14] ^= VAR21[VAR14]; VAR20[VAR14] ^= VAR22[VAR14]; } if (VAR15 == VAR16) { BN_ULONG VAR31; int VAR32 = (VAR15 - 1) / VAR29;  while ((VAR31 = VAR19[VAR32]) == 0 && VAR32) VAR32--; VAR15 = VAR32 * VAR29 + FUN15(VAR31); } } FUN16(VAR7); } # endif  if (!FUN7(VAR2, VAR7)) goto VAR13; FUN2(VAR2); VAR12 = 1;  VAR13: # ifdef VAR33                 FUN16(VAR8); FUN16(VAR9); FUN16(VAR10); # endif FUN17(VAR6); return VAR12; } "#1
214#214#static int FUN1 ( const unsigned char * * VAR1 , int * VAR2 , long * VAR3 , int VAR4 ) { const unsigned char * VAR5 = * VAR1 ; unsigned long VAR6 = 0 ; unsigned int VAR7 ; if ( VAR4 -- < 1 ) return ( 0 ) ; if ( * VAR5 == 0x80 ) { * VAR2 = 1 ; VAR6 = 0 ; VAR5 ++ ; } else { * VAR2 = 0 ; VAR7 = * VAR5 & 0x7f ; if ( * ( VAR5 ++ ) & 0x80 ) { if ( VAR7 > sizeof ( long ) ) return 0 ; if ( VAR4 -- == 0 ) return ( 0 ) ; while ( VAR7 -- > 0 ) { VAR6 <<= 8L ; VAR6 |= * ( VAR5 ++ ) ; if ( VAR4 -- == 0 ) return ( 0 ) ; } } else VAR6 = VAR7 ; } if ( VAR6 > VAR8 ) return 0 ; * VAR1 = VAR5 ; * VAR3 = ( long ) VAR6 ; return ( 1 ) ; } #1
215#215#static VAR1 FUN1 ( const char * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 ; if ( sscanf ( VAR2 , , & VAR4 , & VAR5 , & VAR6 ) == 3 ) return ( VAR4 * 60 + VAR5 ) * 1000 + VAR6 ; return VAR7 ; } #1
216#216#static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * const VAR5 = & VAR2 -> VAR5 ; const int VAR6 = VAR2 -> VAR6 ; int VAR7 , VAR8 [ 2 ] ; int VAR9 , VAR10 [ 2 ] ; VAR11 * VAR12 ; VAR11 * VAR13 ; VAR7 = VAR6 - ( VAR5 -> VAR14 << VAR15 ) ; VAR8 [ 1 ] = VAR8 [ 0 ] = VAR6 - 1 ; if ( VAR16 ) { const int VAR17 = FUN2 ( VAR5 -> VAR18 . VAR3 [ VAR6 - 1 ] ) ; const int VAR19 = FUN2 ( VAR3 ) ; if ( VAR5 -> VAR20 & 1 ) { if ( VAR17 != VAR19 ) { VAR8 [ 0 ] -= VAR5 -> VAR14 ; } } else { if ( VAR19 ) { VAR7 += VAR5 -> VAR14 & ( ( ( VAR5 -> VAR18 . VAR3 [ VAR7 ] >> 7 ) & 1 ) - 1 ) ; } if ( VAR17 != VAR19 ) { VAR8 [ 1 ] += VAR5 -> VAR14 ; } } } VAR2 -> VAR21 = VAR7 ; VAR2 -> VAR22 [ 0 ] = VAR8 [ 0 ] ; VAR2 -> VAR22 [ 1 ] = VAR8 [ 1 ] ; { int VAR23 = VAR2 -> VAR23 ; int VAR24 = VAR5 -> VAR18 . VAR25 [ VAR6 ] ; if ( VAR24 <= VAR23 && ( VAR8 [ 0 ] < 0 || ( ( VAR24 + VAR5 -> VAR18 . VAR25 [ VAR8 [ 0 ] ] + 1 ) >> 1 ) <= VAR23 ) && ( VAR7 < 0 || ( ( VAR24 + VAR5 -> VAR18 . VAR25 [ VAR7 ] + 1 ) >> 1 ) <= VAR23 ) ) { if ( ! VAR16 ) return 1 ; if ( ( VAR8 [ 0 ] < 0 || ( ( VAR24 + VAR5 -> VAR18 . VAR25 [ VAR8 [ 1 ] ] + 1 ) >> 1 ) <= VAR23 ) && ( VAR7 < VAR5 -> VAR14 || ( ( VAR24 + VAR5 -> VAR18 . VAR25 [ VAR7 - VAR5 -> VAR14 ] + 1 ) >> 1 ) <= VAR23 ) ) return 1 ; } } VAR9 = VAR5 -> VAR18 . VAR3 [ VAR7 ] ; VAR10 [ 0 ] = VAR5 -> VAR18 . VAR3 [ VAR8 [ 0 ] ] ; VAR10 [ 1 ] = VAR5 -> VAR18 . VAR3 [ VAR8 [ 1 ] ] ; if ( VAR2 -> VAR26 == 2 ) { if ( VAR2 -> VAR27 [ VAR7 ] != VAR2 -> VAR28 ) VAR9 = 0 ; if ( VAR2 -> VAR27 [ VAR8 [ 0 ] ] != VAR2 -> VAR28 ) VAR10 [ 0 ] = VAR10 [ 1 ] = 0 ; } else { if ( VAR2 -> VAR27 [ VAR7 ] == 0xFFFF ) VAR9 = 0 ; if ( VAR2 -> VAR27 [ VAR8 [ 0 ] ] == 0xFFFF ) VAR10 [ 0 ] = VAR10 [ 1 ] = 0 ; } VAR2 -> VAR9 = VAR9 ; VAR2 -> VAR10 [ 0 ] = VAR10 [ 0 ] ; VAR2 -> VAR10 [ 1 ] = VAR10 [ 1 ] ; if ( FUN3 ( VAR3 ) ) return 0 ; FUN4 ( VAR2 , VAR5 , VAR3 , VAR7 , VAR8 , VAR9 , VAR10 , VAR6 , 0 ) ; if ( VAR2 -> VAR29 == 2 ) FUN4 ( VAR2 , VAR5 , VAR3 , VAR7 , VAR8 , VAR9 , VAR10 , VAR6 , 1 ) ; VAR12 = VAR2 -> VAR30 [ VAR6 ] ; VAR13 = VAR2 -> VAR31 ; FUN5 ( & VAR13 [ 4 + 8 * 1 ] , & VAR12 [ 0 ] ) ; FUN5 ( & VAR13 [ 4 + 8 * 2 ] , & VAR12 [ 4 ] ) ; FUN5 ( & VAR13 [ 4 + 8 * 3 ] , & VAR12 [ 8 ] ) ; FUN5 ( & VAR13 [ 4 + 8 * 4 ] , & VAR12 [ 12 ] ) ; VAR2 -> VAR32 = VAR2 -> VAR33 [ VAR6 ] ; if ( VAR9 ) { VAR12 = VAR2 -> VAR30 [ VAR7 ] ; FUN5 ( & VAR13 [ 4 + 8 * 0 ] , & VAR12 [ 3 * 4 ] ) ; } if ( VAR10 [ 0 ] ) { VAR12 = VAR2 -> VAR30 [ VAR8 [ 0 ] ] ; VAR13 [ 3 + 8 * 1 ] = VAR12 [ 3 + 0 * 4 ] ; VAR13 [ 3 + 8 * 2 ] = VAR12 [ 3 + 1 * 4 ] ; VAR13 [ 3 + 8 * 3 ] = VAR12 [ 3 + 2 * 4 ] ; VAR13 [ 3 + 8 * 4 ] = VAR12 [ 3 + 3 * 4 ] ; } if ( ! VAR34 && VAR2 -> VAR35 . VAR36 ) { if ( FUN6 ( VAR9 ) ) { VAR13 [ 4 + 8 * 0 ] = VAR13 [ 5 + 8 * 0 ] = ( VAR2 -> VAR33 [ VAR7 ] & 0x4000 ) >> 12 ; VAR13 [ 6 + 8 * 0 ] = VAR13 [ 7 + 8 * 0 ] = ( VAR2 -> VAR33 [ VAR7 ] & 0x8000 ) >> 12 ; } if ( FUN6 ( VAR10 [ 0 ] ) ) { VAR13 [ 3 + 8 * 1 ] = VAR13 [ 3 + 8 * 2 ] = ( VAR2 -> VAR33 [ VAR8 [ 0 ] ] & 0x2000 ) >> 12 ; } if ( FUN6 ( VAR10 [ 1 ] ) ) { VAR13 [ 3 + 8 * 3 ] = VAR13 [ 3 + 8 * 4 ] = ( VAR2 -> VAR33 [ VAR8 [ 1 ] ] & 0x8000 ) >> 12 ; } if ( FUN6 ( VAR3 ) ) { VAR13 [ VAR37 [ 0 ] ] = VAR13 [ VAR37 [ 1 ] ] = VAR13 [ VAR37 [ 2 ] ] = VAR13 [ VAR37 [ 3 ] ] = ( VAR2 -> VAR32 & 0x1000 ) >> 12 ; VAR13 [ VAR37 [ 0 + 4 ] ] = VAR13 [ VAR37 [ 1 + 4 ] ] = VAR13 [ VAR37 [ 2 + 4 ] ] = VAR13 [ VAR37 [ 3 + 4 ] ] = ( VAR2 -> VAR32 & 0x2000 ) >> 12 ; VAR13 [ VAR37 [ 0 + 8 ] ] = VAR13 [ VAR37 [ 1 + 8 ] ] = VAR13 [ VAR37 [ 2 + 8 ] ] = VAR13 [ VAR37 [ 3 + 8 ] ] = ( VAR2 -> VAR32 & 0x4000 ) >> 12 ; VAR13 [ VAR37 [ 0 + 12 ] ] = VAR13 [ VAR37 [ 1 + 12 ] ] = VAR13 [ VAR37 [ 2 + 12 ] ] = VAR13 [ VAR37 [ 3 + 12 ] ] = ( VAR2 -> VAR32 & 0x8000 ) >> 12 ; } } return 0 ; } #0
217#217#"static inline void FUN1 ( VAR1 * VAR2 , int VAR3 ) { #if UNCHECKED_BITSTREAM_READER VAR2 -> VAR4 + = VAR3 ; #else VAR2->VAR4 += FUN2(VAR3, -VAR2->VAR4, VAR2->VAR5 - VAR2->VAR4); #endif } "#1
218#218#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , int * VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR10 ; int VAR11 , VAR12 , VAR13 ; int VAR14 = 0 , VAR15 = 1 << ( VAR9 -> VAR16 [ 1 ] - 1 ) ; VAR17 * VAR18 ; VAR19 * VAR20 ; PutBitContext VAR21 ; if ( VAR6 ) { if ( ( VAR12 = FUN2 ( & VAR9 -> VAR22 , VAR6 ) ) < 0 ) return VAR12 ; FUN3 ( VAR2 , & VAR9 -> VAR23 , FUN4 ( VAR6 ) ) ; } else if ( ! VAR9 -> VAR22 . VAR24 ) return 0 ; VAR13 = VAR9 -> VAR23 . VAR25 * VAR2 -> VAR15 < VAR15 ; VAR13 = VAR6 && VAR13 ; if ( VAR13 ) return 0 ; if ( ! VAR6 ) { if ( VAR9 -> VAR23 . VAR25 * VAR2 -> VAR15 < VAR15 ) { int VAR26 = ( VAR15 / VAR2 -> VAR15 ) - VAR9 -> VAR23 . VAR25 ; for ( int VAR11 = 0 ; VAR11 < VAR26 ; VAR11 ++ ) { VAR5 * VAR27 = FUN5 ( VAR2 , VAR9 -> VAR28 ) ; if ( ! VAR27 ) return FUN6 ( VAR29 ) ; FUN3 ( VAR2 , & VAR9 -> VAR23 , VAR27 ) ; } } } FUN7 ( VAR9 , VAR9 -> VAR30 , & VAR14 , VAR2 -> VAR15 ) ; if ( ! FUN8 ( VAR9 , VAR9 -> VAR30 , VAR14 ) ) return 0 ; if ( ( VAR12 = FUN9 ( VAR2 , VAR4 , 8192 , 0 ) ) < 0 ) return VAR12 ; FUN10 ( & VAR21 , VAR4 -> VAR31 , VAR4 -> VAR32 ) ; if ( VAR21 . VAR33 - FUN11 ( & VAR21 ) < 1 + FUN12 ( VAR9 -> VAR34 - 1 ) ) { FUN13 ( VAR2 , VAR35 , ) ; return FUN6 ( VAR36 ) ; } } for ( VAR11 = 0 ; VAR11 < VAR9 -> VAR28 * VAR14 ; VAR11 ++ ) VAR9 -> VAR47 [ VAR11 ] /= VAR9 -> VAR43 [ VAR11 ] ; for ( VAR11 = 0 ; VAR11 < VAR20 -> VAR48 ; VAR11 ++ ) { float * VAR49 = VAR9 -> VAR47 + VAR20 -> VAR50 [ VAR11 ] * VAR14 ; float * VAR51 = VAR9 -> VAR47 + VAR20 -> VAR52 [ VAR11 ] * VAR14 ; int VAR53 ; for ( VAR53 = 0 ; VAR53 < VAR14 ; VAR53 ++ ) { float VAR54 = VAR51 [ VAR53 ] ; VAR51 [ VAR53 ] -= VAR49 [ VAR53 ] ; if ( VAR49 [ VAR53 ] > 0 ) VAR51 [ VAR53 ] = - VAR51 [ VAR53 ] ; if ( VAR51 [ VAR53 ] < 0 ) VAR49 [ VAR53 ] = VAR54 ; } } if ( FUN17 ( VAR9 , & VAR9 -> VAR55 [ VAR20 -> VAR56 [ VAR20 -> VAR44 [ 0 ] ] ] , & VAR21 , VAR9 -> VAR47 , VAR14 , VAR9 -> VAR28 ) ) { FUN13 ( VAR2 , VAR35 , "" "" ) ; return FUN6 ( VAR36 ) ; } FUN18 ( & VAR21 ) ; VAR4 -> VAR32 = FUN11 ( & VAR21 ) >> 3 ; FUN19 ( & VAR9 -> VAR22 , VAR15 , & VAR4 -> VAR57 , & VAR4 -> VAR58 ) ; if ( VAR15 > VAR4 -> VAR58 ) { VAR59 * VAR60 = FUN20 ( VAR4 , VAR61 , 10 ) ; if ( ! VAR60 ) return FUN6 ( VAR29 ) ; FUN21 ( & VAR60 [ 4 ] , VAR15 - VAR4 -> VAR58 ) ; } * VAR7 = 1 ; return 0 ; } "#0
219#219#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { const void * * VAR5 ; int VAR6 ; if ( VAR3 > VAR7 - VAR2 -> VAR8 ) return 0 ; VAR6 = VAR2 -> VAR8 + VAR3 ; if ( VAR6 < VAR9 ) VAR6 = VAR9 ; if ( VAR2 -> VAR10 == NULL ) { if ( ( VAR2 -> VAR10 = FUN2 ( sizeof ( void * ) * VAR6 ) ) == NULL ) { return 0 ; } VAR2 -> VAR6 = VAR6 ; return 1 ; } if ( ! VAR4 ) { if ( VAR6 <= VAR2 -> VAR6 ) return 1 ; VAR6 = FUN3 ( VAR6 , VAR2 -> VAR6 ) ; if ( VAR6 == 0 ) return 0 ; } else if ( VAR6 == VAR2 -> VAR6 ) { return 1 ; } VAR5 = FUN4 ( ( void * ) VAR2 -> VAR10 , sizeof ( void * ) * VAR6 ) ; if ( VAR5 == NULL ) return 0 ; VAR2 -> VAR10 = VAR5 ; VAR2 -> VAR6 = VAR6 ; return 1 ; } #1
220#220#"void FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 ) { int VAR9 , VAR10 ; assert ( VAR6 >= 0 && VAR6 < VAR5 ) ; for ( VAR9 = 0 ; VAR9 < VAR8 ; VAR9 ++ ) { int VAR11 = 0 ; int VAR12 = 0x4000 ; for ( VAR10 = 0 ; VAR10 < VAR7 ; ) { VAR12 += VAR3 [ VAR9 + VAR10 ] * VAR4 [ VAR11 + VAR6 ] ; VAR11 += VAR5 ; VAR10 ++ ; VAR12 += VAR3 [ VAR9 - VAR10 ] * VAR4 [ VAR11 - VAR6 ] ; } if ( FUN2 ( VAR12 >> 15 ) != ( VAR12 >> 15 ) ) FUN3 ( NULL , VAR13 , "" "" ) ; VAR2 [ VAR9 ] = VAR12 >> 15 ; } } "#1
221#221#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR4 ; int VAR5 , VAR6 , VAR7 , VAR8 ; const VAR9 * VAR10 ; struct VAR11 * VAR12 ; int VAR13 = 0 ; VAR12 = FUN2 ( VAR2 -> VAR14 . VAR15 , VAR2 -> VAR14 . VAR16 * sizeof ( struct VAR11 ) ) ; if ( ! VAR12 ) return FUN3 ( VAR17 ) ; FUN4 ( & VAR2 -> VAR18 ) ; VAR10 = VAR2 -> VAR18 . VAR19 + FUN5 ( & VAR2 -> VAR18 ) / 8 ; VAR8 = FUN6 ( & VAR2 -> VAR18 ) ; for ( VAR6 = 0 ; VAR8 > 0 && VAR6 < VAR2 -> VAR14 . VAR16 ; VAR6 ++ ) for ( VAR5 = 0 ; VAR8 > 0 && VAR5 < VAR2 -> VAR14 . VAR15 ; VAR5 ++ ) { VAR7 = ( VAR13 + 1 ) * VAR2 -> VAR14 . VAR7 . VAR20 / VAR2 -> VAR14 . VAR7 . VAR21 - VAR13 * VAR2 -> VAR14 . VAR7 . VAR20 / VAR2 -> VAR14 . VAR7 . VAR21 ; VAR12 [ VAR13 ] . VAR7 = VAR7 ; VAR12 [ VAR13 ] . VAR5 = VAR5 ; VAR12 [ VAR13 ] . VAR6 = VAR6 ; FUN7 ( & VAR12 [ VAR13 ] . VAR18 , VAR10 , VAR8 ) ; VAR13 ++ ; VAR10 += VAR7 ; VAR8 -= VAR7 * 8 ; } VAR4 -> FUN8 ( VAR4 , VAR22 , VAR12 , NULL , VAR13 , sizeof ( struct VAR11 ) ) ; FUN9 ( & VAR2 -> VAR23 [ 0 ] . VAR24 [ 0 ] [ 0 ] ) ; FUN9 ( & VAR2 -> VAR23 [ 1 ] . VAR24 [ 0 ] [ 0 ] ) ; FUN9 ( & VAR2 -> VAR23 [ 2 ] . VAR24 [ 0 ] [ 0 ] ) ; FUN10 ( VAR12 ) ; return 0 ; } #0
222#222#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , MOVAtom VAR5 ) { VAR6 * VAR7 = & VAR2 -> VAR8 ; VAR9 * VAR10 = NULL ; VAR11 * VAR12 ; VAR13 * VAR14 ; uint64_t VAR15 ; int64_t VAR16 ; int VAR17 = 0 ; unsigned VAR18 , VAR19 = VAR7 -> VAR20 ; int VAR20 , VAR21 , VAR22 , VAR23 = 0 , VAR24 ; for ( VAR22 = 0 ; VAR22 < VAR2 -> VAR25 -> VAR26 ; VAR22 ++ ) { if ( VAR2 -> VAR25 -> VAR27 [ VAR22 ] -> VAR28 == VAR7 -> VAR29 ) { VAR10 = VAR2 -> VAR25 -> VAR27 [ VAR22 ] ; break ; } } if ( ! VAR10 ) { FUN2 ( VAR2 -> VAR25 , VAR30 , , VAR20 , VAR18 ) ; if ( ! VAR12 -> VAR35 && VAR12 -> VAR36 ) { VAR14 = FUN7 ( NULL , sizeof ( * VAR12 -> VAR14 ) ) ; if ( ! VAR14 ) return FUN8 ( VAR37 ) ; VAR12 -> VAR14 = VAR14 ; VAR12 -> VAR14 [ VAR12 -> VAR35 ] . VAR38 = VAR12 -> VAR36 ; VAR12 -> VAR14 [ VAR12 -> VAR35 ] . VAR39 = 0 ; VAR12 -> VAR35 ++ ; } if ( ( VAR40 ) VAR18 + VAR12 -> VAR35 >= VAR41 / sizeof ( * VAR12 -> VAR14 ) ) return VAR31 ; if ( ( VAR24 = FUN9 ( & VAR12 -> VAR14 , VAR18 + VAR12 -> VAR35 , sizeof ( * VAR12 -> VAR14 ) ) ) < 0 ) { VAR12 -> VAR35 = 0 ; return VAR24 ; } if ( VAR20 & VAR42 ) VAR17 = FUN5 ( VAR4 ) ; if ( VAR20 & VAR43 ) VAR19 = FUN5 ( VAR4 ) ; VAR16 = VAR12 -> VAR44 - VAR12 -> VAR45 ; VAR15 = VAR7 -> VAR46 + VAR17 ; VAR21 = 0 ; FUN6 ( VAR2 -> VAR25 , VAR65 VAR65VAR65VAR65 ) ; } else VAR10 -> VAR74 [ VAR10 -> VAR75 - 1 ] . VAR76 = VAR54 ; FUN6 ( VAR2 -> VAR25 , VAR65 , VAR10 -> VAR78 , VAR12 -> VAR36 + VAR22 , VAR15 , VAR54 , VAR48 , VAR21 , VAR52 ) ; VAR21 ++ ; VAR16 += VAR51 ; VAR15 += VAR48 ; VAR12 -> VAR79 += VAR48 ; VAR12 -> VAR80 += VAR51 ; VAR12 -> VAR81 ++ ; } if ( VAR4 -> VAR47 ) return VAR82 ; VAR7 -> VAR83 = VAR15 ; VAR10 -> VAR39 = VAR12 -> VAR44 = VAR16 + VAR12 -> VAR45 ; return 0 ; } #1
223#223#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 ; if ( ! FUN2 ( VAR4 = FUN3 ( sizeof ( * VAR4 ) ) ) ) return 0 ; if ( ! FUN2 ( VAR4 -> VAR5 = FUN4 ( ) ) ) { FUN5 ( VAR4 ) ; return 0 ; } VAR4 -> VAR6 = 0 ; VAR4 -> VAR7 = -1 ; FUN6 ( VAR2 , 1 ) ; FUN7 ( VAR2 , VAR4 ) ; return 1 ; } #0
224#224#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; VAR14 * VAR15 ; int VAR16 , VAR17 = VAR9 , VAR18 = 0 ; uint32_t VAR19 ; VAR20 * VAR21 ; VAR20 * VAR22 , * VAR23 ; int VAR24 , VAR25 , VAR26 , VAR27 , VAR28 ; VAR12 -> VAR29 -> VAR30 = VAR31 ; if ( ( VAR28 = VAR2 -> FUN2 ( VAR2 , VAR12 -> VAR29 ) ) < 0 ) { FUN3 ( VAR2 , VAR32 , ) ; return VAR34 ; } VAR19 = ( FUN6 ( VAR8 ) & 0x000fffff ) | VAR12 -> VAR40 ; if ( FUN7 ( VAR19 ) < 0 ) break ; FUN8 ( ( VAR41 * ) VAR15 , VAR19 ) ; if ( VAR27 + VAR15 -> VAR42 > VAR2 -> VAR43 ) { FUN3 ( VAR2 , VAR32 , ) ; return VAR34 ; } VAR27 += VAR15 -> VAR42 ; VAR18 += FUN9 ( VAR15 , VAR22 , VAR8 , VAR16 ) ; VAR8 += VAR16 ; VAR17 -= VAR16 ; if ( VAR12 -> VAR35 > 1 ) { VAR26 = VAR15 -> VAR2 -> VAR44 * VAR15 -> VAR42 ; VAR23 = VAR21 + VAR12 -> VAR45 [ VAR24 ] ; if ( VAR15 -> VAR42 == 1 ) { for ( VAR25 = 0 ; VAR25 < VAR26 ; VAR25 ++ ) { * VAR23 = VAR12 -> VAR36 [ VAR25 ] ; VAR23 += VAR2 -> VAR43 ; } } else { for ( VAR25 = 0 ; VAR25 < VAR26 ; VAR25 ++ ) { VAR23 [ 0 ] = VAR12 -> VAR36 [ VAR25 ++ ] ; VAR23 [ 1 ] = VAR12 -> VAR36 [ VAR25 ] ; VAR23 += VAR2 -> VAR43 ; } } } VAR2 -> VAR37 += VAR15 -> VAR37 ; } VAR2 -> VAR46 = VAR12 -> VAR39 [ 0 ] -> VAR46 ; VAR12 -> VAR29 -> VAR30 = VAR18 / ( VAR2 -> VAR43 * sizeof ( VAR20 ) ) ; * VAR4 = 1 ; * ( VAR47 * ) VAR3 = * VAR12 -> VAR29 ; return VAR9 ; } #0
225#225#static av_always_inline void FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; VAR10 * VAR11 = & VAR8 -> VAR12 [ VAR5 ] ; int VAR13 , VAR14 = FUN2 ( & VAR11 -> VAR15 ) >> 16 , VAR16 = VAR8 -> VAR16 ; VAR17 * VAR18 = VAR8 -> VAR18 -> VAR19 . VAR20 ; VAR21 * VAR22 ; VAR10 * VAR23 , * VAR24 ; VAR25 * VAR26 [ 3 ] = { VAR18 -> VAR27 [ 0 ] + 16 * VAR14 * VAR8 -> VAR28 , VAR18 -> VAR27 [ 1 ] + 8 * VAR14 * VAR8 -> VAR29 , VAR18 -> VAR27 [ 2 ] + 8 * VAR14 * VAR8 -> VAR29 } ; if ( VAR8 -> VAR30 == 1 ) VAR22 = VAR8 -> VAR31 + ( ( VAR8 -> VAR32 + 1 ) * ( VAR14 + 1 ) + 1 ) ; else VAR22 = VAR8 -> VAR33 + ( VAR8 -> VAR34 - VAR14 - 1 ) * 2 ; if ( VAR14 == 0 ) VAR23 = VAR11 ; else VAR23 = & VAR8 -> VAR12 [ ( VAR4 + VAR16 - 1 ) % VAR16 ] ; if ( VAR14 == VAR8 -> VAR34 - 1 ) VAR24 = VAR11 ; else VAR24 = & VAR8 -> VAR12 [ ( VAR4 + 1 ) % VAR16 ] ; for ( VAR13 = 0 ; VAR13 < VAR8 -> VAR32 ; VAR13 ++ , VAR22 ++ ) { VAR35 * VAR20 = & VAR11 -> VAR36 [ VAR13 ] ; if ( VAR23 != VAR11 ) FUN3 ( VAR11 , VAR23 , ( VAR13 + 1 ) + ( VAR8 -> VAR32 + 3 ) , VAR14 - 1 ) ; if ( VAR24 != VAR11 ) if ( VAR24 != & VAR8 -> VAR12 [ 0 ] ) FUN3 ( VAR11 , VAR24 , VAR13 + 1 , VAR14 + 1 ) ; if ( VAR16 == 1 ) { if ( VAR8 -> VAR37 . VAR38 ) FUN4 ( VAR8 -> VAR39 [ VAR13 + 1 ] , VAR26 [ 0 ] , NULL , NULL , VAR8 -> VAR28 , 0 , 1 ) ; else FUN4 ( VAR8 -> VAR39 [ VAR13 + 1 ] , VAR26 [ 0 ] , VAR26 [ 1 ] , VAR26 [ 2 ] , VAR8 -> VAR28 , VAR8 -> VAR29 , 0 ) ; } if ( VAR8 -> VAR37 . VAR38 ) FUN5 ( VAR8 , VAR26 [ 0 ] , VAR20 , VAR13 , VAR14 ) ; else FUN6 ( VAR8 , VAR26 , VAR20 , VAR13 , VAR14 , VAR6 ) ; VAR26 [ 0 ] += 16 ; VAR26 [ 1 ] += 8 ; VAR26 [ 2 ] += 8 ; FUN7 ( VAR11 , VAR14 , ( VAR8 -> VAR32 + 3 ) + VAR13 ) ; } } #0
226#226#char * FUN1 ( VAR1 * VAR2 , char * VAR3 ) { unsigned long VAR4 ; VAR5 * VAR6 , * * VAR7 ; char * VAR8 ; VAR2 -> VAR9 = 0 ; VAR7 = FUN2 ( VAR2 , VAR3 , & VAR4 ) ; if ( * VAR7 == NULL ) { VAR2 -> VAR10 ++ ; return ( NULL ) ; } else { VAR6 = * VAR7 ; * VAR7 = VAR6 -> VAR11 ; VAR8 = VAR6 -> VAR3 ; FUN3 ( ( char * ) VAR6 ) ; VAR2 -> VAR12 ++ ; } VAR2 -> VAR13 -- ; if ( ( VAR2 -> VAR14 > VAR15 ) && ( VAR2 -> VAR16 >= ( VAR2 -> VAR13 * VAR17 / VAR2 -> VAR14 ) ) ) FUN4 ( VAR2 ) ; return ( VAR8 ) ; } #1
227#227#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , MOVAtom VAR5 ) { VAR6 * VAR7 = & VAR2 -> VAR8 ; VAR9 * VAR10 = NULL ; VAR11 * VAR12 ; VAR13 * VAR14 ; uint64_t VAR15 ; int64_t VAR16 ; int VAR17 = 0 ; unsigned VAR18 , VAR19 = VAR7 -> VAR20 ; int VAR20 , VAR21 , VAR22 ; for ( VAR22 = 0 ; VAR22 < VAR2 -> VAR23 -> VAR24 ; VAR22 ++ ) { if ( VAR2 -> VAR23 -> VAR25 [ VAR22 ] -> VAR26 == VAR7 -> VAR27 ) { VAR10 = VAR2 -> VAR23 -> VAR25 [ VAR22 ] ; break ; } } if ( ! VAR10 ) { FUN2 ( VAR2 -> VAR23 , VAR28 , , VAR20 , VAR18 ) ; if ( ( VAR34 ) VAR18 + VAR12 -> VAR35 >= VAR36 / sizeof ( * VAR12 -> VAR14 ) ) return VAR29 ; if ( VAR20 & VAR37 ) VAR17 = FUN5 ( VAR4 ) ; if ( VAR20 & VAR38 ) VAR19 = FUN5 ( VAR4 ) ; VAR16 = VAR12 -> VAR39 - VAR12 -> VAR40 ; VAR15 = VAR7 -> VAR41 + VAR17 ; VAR21 = 0 ; FUN2 ( VAR2 -> VAR23 , VAR33 , VAR63 VAR63VAR63VAR63 ) ; } FUN2 ( VAR2 -> VAR23 , VAR33 , VAR63 , VAR10 -> VAR80 , VAR50 , VAR15 , VAR16 , VAR43 , VAR21 , VAR49 ) ; VAR21 ++ ; VAR16 += VAR46 ; VAR15 += VAR43 ; VAR12 -> VAR81 += VAR43 ; VAR12 -> VAR82 += VAR46 ; VAR12 -> VAR83 ++ ; } if ( VAR4 -> VAR42 ) return VAR84 ; VAR7 -> VAR85 = VAR15 ; VAR12 -> VAR39 = VAR16 + VAR12 -> VAR40 ; if ( VAR10 -> VAR47 < VAR12 -> VAR39 ) VAR10 -> VAR47 = VAR12 -> VAR39 ; return 0 ; } #0
228#228#void FUN1 ( VAR1 * VAR2 ) { unsigned int VAR3 ; VAR4 * VAR5 , * VAR6 ; if ( VAR2 == NULL ) return ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR7 ; VAR3 ++ ) { VAR5 = VAR2 -> VAR8 [ VAR3 ] ; while ( VAR5 != NULL ) { VAR6 = VAR5 -> VAR9 ; FUN2 ( VAR5 ) ; VAR5 = VAR6 ; } } FUN2 ( VAR2 -> VAR8 ) ; FUN2 ( VAR2 ) ; } #1
229#229#VAR1 * FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 , int VAR7 , double VAR8 ) { double VAR9 = FUN2 ( VAR3 * VAR8 / VAR4 , 1.0 ) ; int VAR10 = 1 << VAR6 ; if ( ! VAR2 || VAR2 -> VAR6 != VAR6 || VAR2 -> VAR7 != VAR7 || VAR2 -> VAR9 != VAR9 || VAR2 -> VAR11 != FUN3 ( ( int ) FUN4 ( VAR5 / VAR9 ) , 1 ) ) { VAR2 = FUN5 ( sizeof ( VAR1 ) ) ; if ( ! VAR2 ) return NULL ; VAR2 -> VAR6 = VAR6 ; VAR2 -> VAR12 = VAR10 - 1 ; VAR2 -> VAR7 = VAR7 ; VAR2 -> VAR9 = VAR9 ; VAR2 -> VAR11 = FUN3 ( ( int ) FUN4 ( VAR5 / VAR9 ) , 1 ) ; VAR2 -> VAR13 = FUN5 ( VAR2 -> VAR11 * ( VAR10 + 1 ) * sizeof ( VAR14 ) ) ; if ( ! VAR2 -> VAR13 ) goto VAR15 ; if ( FUN6 ( VAR2 -> VAR13 , VAR9 , VAR2 -> VAR11 , VAR10 , 1 << VAR16 , VAR17 ) ) goto VAR15 ; memcpy ( & VAR2 -> VAR13 [ VAR2 -> VAR11 * VAR10 + 1 ] , VAR2 -> VAR13 , ( VAR2 -> VAR11 - 1 ) * sizeof ( VAR14 ) ) ; VAR2 -> VAR13 [ VAR2 -> VAR11 * VAR10 ] = VAR2 -> VAR13 [ VAR2 -> VAR11 - 1 ] ; } VAR2 -> VAR18 = 0 ; if ( ! FUN7 ( & VAR2 -> VAR19 , & VAR2 -> VAR20 , VAR3 , VAR4 * ( VAR21 ) VAR10 , VAR22 / 2 ) ) goto VAR15 ; VAR2 -> VAR23 = VAR2 -> VAR20 ; VAR2 -> VAR24 = - VAR10 * ( ( VAR2 -> VAR11 - 1 ) / 2 ) ; VAR2 -> VAR25 = 0 ; return VAR2 ; VAR15 : FUN8 ( VAR2 -> VAR13 ) ; FUN8 ( VAR2 ) ; return NULL ; } #0
230#230#static int FUN1 ( VAR1 * VAR2 ) { VAR2 -> VAR3 |= VAR4 ; return 0 ; } #0
231#231#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; int64_t VAR9 , VAR10 , VAR11 ; int64_t VAR12 , VAR13 , VAR14 ; double VAR15 ; FUN2 ( VAR2 , "" "" , VAR4 / 1000000.0 ) ; if ( VAR7 -> VAR16 && VAR7 -> VAR16 < VAR7 -> VAR17 ) { if ( FUN3 ( VAR2 , VAR18 ) < VAR4 ) { VAR9 = VAR18 ; VAR10 = VAR7 -> VAR16 - VAR18 ; } else { VAR9 = VAR7 -> VAR16 ; VAR10 = VAR7 -> VAR17 - VAR18 ; } } else { VAR9 = VAR18 ; VAR10 = VAR7 -> VAR17 - VAR18 ; } while ( VAR9 <= VAR10 ) { VAR12 = FUN3 ( VAR2 , VAR9 ) ; VAR13 = FUN3 ( VAR2 , VAR10 ) ; if ( VAR12 > VAR4 || VAR13 <= VAR4 ) { VAR11 = VAR12 > VAR4 ? VAR9 : VAR10 ; goto VAR19 ; } VAR15 = ( double ) ( VAR10 - VAR9 ) * ( double ) ( VAR4 - VAR12 ) / ( double ) ( VAR13 - VAR12 ) ; VAR11 = ( ( ( VAR20 ) VAR15 ) / VAR18 ) * VAR18 ; if ( VAR11 <= VAR9 ) VAR11 = VAR9 ; else if ( VAR11 >= VAR10 ) VAR11 = VAR10 ; VAR14 = FUN3 ( VAR2 , VAR11 ) ; if ( VAR14 == VAR4 ) { goto VAR19 ; } else if ( VAR14 > VAR4 ) { VAR10 = VAR11 - VAR18 ; } else { VAR9 = VAR11 + VAR18 ; } } VAR11 = ( VAR5 & VAR21 ) ? VAR9 : VAR10 ; VAR19 : if ( FUN4 ( VAR2 , VAR11 ) < 0 ) return -1 ; VAR7 -> VAR22 = VAR23 ; VAR7 -> VAR24 = VAR7 -> VAR25 ; VAR7 -> VAR26 = VAR7 -> VAR25 ; VAR7 -> VAR27 = 1 ; return 0 ; } "#0
232#232#static int FUN1 ( int * VAR1 , int * VAR2 , const char * VAR3 , int VAR4 ) { char VAR5 [ 1024 ] ; int VAR6 , VAR7 , VAR8 , VAR9 ; for ( VAR9 = VAR4 ; VAR9 < VAR4 + 5 ; VAR9 ++ ) { if ( FUN2 ( VAR5 , sizeof ( VAR5 ) , VAR3 , VAR9 ) < 0 ) { * VAR1 = * VAR2 = 1 ; if ( FUN3 ( VAR5 , VAR10 ) > 0 ) return 0 ; return -1 ; } if ( FUN3 ( VAR5 , VAR10 ) > 0 ) break ; } if ( VAR9 == 5 ) goto VAR11 ; VAR7 = VAR9 ; for ( ; ; ) { VAR6 = 0 ; for ( ; ; ) { if ( ! VAR6 ) VAR8 = 1 ; else VAR8 = 2 * VAR6 ; if ( FUN2 ( VAR5 , sizeof ( VAR5 ) , VAR3 , VAR7 + VAR8 ) < 0 ) goto VAR11 ; if ( FUN3 ( VAR5 , VAR10 ) <= 0 ) break ; VAR6 = VAR8 ; if ( VAR6 >= ( 1 << 30 ) ) goto VAR11 ; } if ( ! VAR6 ) break ; VAR7 += VAR6 ; } * VAR1 = VAR9 ; * VAR2 = VAR7 ; return 0 ; VAR11 : return -1 ; } #0
233#233#"int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 , const VAR1 * VAR5 , VAR6 * VAR7 , VAR8 * VAR9 ) { int VAR10 , VAR11 , VAR12 , VAR13 = 0 , VAR14 , VAR15 , VAR16 , VAR17 ; int VAR18 = 1 ; VAR1 * VAR19 , * VAR20 ; const VAR1 * VAR21 ; VAR1 * VAR22 [ VAR23 ] ; VAR8 * VAR24 = NULL ; if ( FUN2 ( VAR4 , VAR25 ) != 0 || FUN2 ( VAR3 , VAR25 ) != 0 || FUN2 ( VAR5 , VAR25 ) != 0 ) { return FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR7 , VAR9 ) ; } FUN4 ( VAR3 ) ; FUN4 ( VAR4 ) ; FUN4 ( VAR5 ) ; if ( ! FUN5 ( VAR5 ) ) { FUN6 ( VAR26 , VAR27 ) ; return 0 ; } VAR12 = FUN7 ( VAR4 ) ; if ( VAR12 == 0 ) { if ( FUN8 ( VAR5 , 1 ) ) { VAR13 = 1 ; FUN9 ( VAR2 ) ; } else { VAR13 = FUN10 ( VAR2 ) ; } return VAR13 ; } FUN11 ( VAR7 ) ; VAR19 = FUN12 ( VAR7 ) ; VAR20 = FUN12 ( VAR7 ) ; VAR22 [ 0 ] = FUN12 ( VAR7 ) ; if ( VAR22 [ 0 ] == NULL ) goto VAR28 ; if ( VAR9 != NULL ) VAR24 = VAR9 ; else { if ( ( VAR24 = FUN13 ( ) ) == NULL ) goto VAR28 ; if ( ! FUN14 ( VAR24 , VAR5 , VAR7 ) ) goto VAR28 ; } if ( VAR3 -> VAR29 || FUN15 ( VAR3 , VAR5 ) >= 0 ) { if ( ! FUN16 ( VAR22 [ 0 ] , VAR3 , VAR5 , VAR7 ) ) goto VAR28 ; VAR21 = VAR22 [ 0 ] ; } else VAR21 = VAR3 ; if ( FUN17 ( VAR21 ) ) { FUN9 ( VAR2 ) ; VAR13 = 1 ; goto VAR28 ; } if ( ! FUN18 ( VAR22 [ 0 ] , VAR21 , VAR24 , VAR7 ) ) goto VAR28 ; VAR16 = FUN19 ( VAR12 ) ; if ( VAR16 > 1 ) { if ( ! FUN20 ( VAR19 , VAR22 [ 0 ] , VAR22 [ 0 ] , VAR24 , VAR7 ) ) goto VAR28 ; VAR11 = 1 << ( VAR16 - 1 ) ; for ( VAR10 = 1 ; VAR10 < VAR11 ; VAR10 ++ ) { if ( ( ( VAR22 [ VAR10 ] = FUN12 ( VAR7 ) ) == NULL ) || ! FUN20 ( VAR22 [ VAR10 ] , VAR22 [ VAR10 - 1 ] , VAR19 , VAR24 , VAR7 ) ) goto VAR28 ; } } VAR18 = 1 ; VAR17 = 0 ; VAR14 = VAR12 - 1 ; VAR15 = 0 ; #if 1 VAR11 = VAR5 - > VAR30 ; if ( VAR5 -> VAR19 [ VAR11 - 1 ] & ( ( ( VAR31 ) 1 ) << ( VAR32 - 1 ) ) ) { if ( FUN21 ( VAR20 , VAR11 ) == NULL ) goto VAR28 ; VAR20 -> VAR19 [ 0 ] = ( 0 - VAR5 -> VAR19 [ 0 ] ) & VAR33 ; for ( VAR10 = 1 ; VAR10 < VAR11 ; VAR10 ++ ) VAR20 -> VAR19 [ VAR10 ] = ( ~ VAR5 -> VAR19 [ VAR10 ] ) & VAR33 ; VAR20 -> VAR30 = VAR11 ; VAR20 -> VAR34 |= VAR35 ; } else #endif if ( ! FUN18 ( VAR20 , FUN22 ( ) , VAR24 , VAR7 ) ) goto VAR28 ; for ( ; ; ) { if ( FUN23 ( VAR4 , VAR14 ) == 0 ) { if ( ! VAR18 ) { if ( ! FUN20 ( VAR20 , VAR20 , VAR20 , VAR24 , VAR7 ) ) goto VAR28 ; } if ( VAR14 == 0 ) break ; VAR14 -- ; continue ; } VAR11 = VAR14 ; VAR17 = 1 ; VAR15 = 0 ; for ( VAR10 = 1 ; VAR10 < VAR16 ; VAR10 ++ ) { if ( VAR14 - VAR10 < 0 ) break ; if ( FUN23 ( VAR4 , VAR14 - VAR10 ) ) { VAR17 <<= ( VAR10 - VAR15 ) ; VAR17 |= 1 ; VAR15 = VAR10 ; } } VAR11 = VAR15 + 1 ; if ( ! VAR18 ) for ( VAR10 = 0 ; VAR10 < VAR11 ; VAR10 ++ ) { if ( ! FUN20 ( VAR20 , VAR20 , VAR20 , VAR24 , VAR7 ) ) goto VAR28 ; } if ( ! FUN20 ( VAR20 , VAR20 , VAR22 [ VAR17 >> 1 ] , VAR24 , VAR7 ) ) goto VAR28 ; VAR14 -= VAR15 + 1 ; VAR17 = 0 ; VAR18 = 0 ; if ( VAR14 < 0 ) break ; } #if FUN24 ( VAR36 ) if ( VAR37 [ 0 ] & ( VAR38 | VAR39 ) ) { VAR11 = VAR24 - > VAR40 . VAR30 ; VAR22 [ 0 ] -> VAR19 [ 0 ] = 1 ; for ( VAR10 = 1 ; VAR10 < VAR11 ; VAR10 ++ ) VAR22 [ 0 ] -> VAR19 [ VAR10 ] = 0 ; VAR22 [ 0 ] -> VAR30 = VAR11 ; if ( ! FUN25 ( VAR2 , VAR20 , VAR22 [ 0 ] , VAR24 , VAR7 ) ) goto VAR28 ; } else #endif if ( ! FUN26 ( VAR2 , VAR20 , VAR24 , VAR7 ) ) goto VAR28 ; VAR13 = 1 ; VAR28 : if ( VAR9 == NULL ) FUN27 ( VAR24 ) ; FUN28 ( VAR7 ) ; FUN4 ( VAR2 ) ; return VAR13 ; } "#0
234#234#static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * const VAR5 = & VAR2 -> VAR5 ; VAR6 * const VAR7 = VAR5 -> VAR7 ; VAR1 * VAR8 ; int VAR9 ; if ( VAR5 -> VAR7 -> VAR10 || VAR5 -> VAR7 -> VAR11 -> VAR12 & VAR13 ) return 0 ; if ( VAR3 == 1 ) { return FUN2 ( VAR7 , & VAR2 ) ; } else { for ( VAR9 = 1 ; VAR9 < VAR3 ; VAR9 ++ ) { VAR8 = VAR2 -> VAR14 [ VAR9 ] ; VAR8 -> VAR5 . VAR15 = VAR7 -> VAR15 ; VAR8 -> VAR5 . VAR16 = 0 ; VAR8 -> VAR17 = VAR2 -> VAR17 ; } VAR7 -> FUN3 ( VAR7 , VAR18 , VAR2 -> VAR14 , NULL , VAR3 , sizeof ( void * ) ) ; VAR8 = VAR2 -> VAR14 [ VAR3 - 1 ] ; VAR5 -> VAR19 = VAR8 -> VAR5 . VAR19 ; VAR5 -> VAR20 = VAR8 -> VAR5 . VAR20 ; VAR5 -> VAR21 = VAR8 -> VAR5 . VAR21 ; VAR5 -> VAR22 = VAR8 -> VAR5 . VAR22 ; for ( VAR9 = 1 ; VAR9 < VAR3 ; VAR9 ++ ) VAR2 -> VAR5 . VAR16 += VAR2 -> VAR14 [ VAR9 ] -> VAR5 . VAR16 ; } return 0 ; } #1
235#235#"static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , uint32_t VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; GetByteContext VAR9 ; uint32_t VAR10 = 0 ; int VAR11 , VAR12 , VAR13 ; uint8_t VAR14 , VAR15 , VAR16 , VAR17 , VAR18 ; FUN2 ( & VAR9 , VAR4 , VAR5 ) ; while ( FUN3 ( & VAR9 ) < VAR5 ) { VAR11 = FUN4 ( & VAR9 ) & 0x1F ; if ( VAR11 == 0 ) { VAR14 = FUN5 ( & VAR9 ) & 0xE0 ; VAR14 = VAR14 >> 5 ; if ( VAR14 == 0 ) { VAR7 -> VAR19 [ VAR10 ++ ] = FUN5 ( & VAR9 ) ; VAR7 -> VAR19 [ VAR10 ++ ] = FUN5 ( & VAR9 ) ; } else if ( VAR14 == 1 ) { VAR10 += FUN5 ( & VAR9 ) * 2 ; } else if ( VAR14 == 2 ) { VAR11 = FUN6 ( & VAR9 ) ; VAR11 *= 2 ; VAR10 += VAR11 ; } else if ( VAR14 == 3 ) { VAR11 = FUN5 ( & VAR9 ) * 2 ; while ( VAR11 > 0 ) { VAR7 -> VAR19 [ VAR10 ++ ] = FUN4 ( & VAR9 ) ; VAR11 -- ; } FUN7 ( & VAR9 , 1 ) ; } else { break ; } } else { VAR15 = FUN4 ( & VAR9 ) & 0x20 ; VAR16 = FUN4 ( & VAR9 ) & 0x40 ; VAR17 = FUN4 ( & VAR9 ) & 0x80 ; FUN7 ( & VAR9 , 1 ) ; VAR18 = FUN4 ( & VAR9 ) & 0x01 ; VAR13 = FUN6 ( & VAR9 ) ; VAR13 = ( VAR13 >> 1 ) & 0x7FFF ; VAR13 = VAR10 + ( VAR13 * 2 ) - 0x8000 ; VAR12 = VAR11 ; if ( ! VAR17 && VAR13 + 2 * VAR11 > VAR7 -> VAR20 * VAR7 -> VAR21 ) { FUN8 ( VAR2 , VAR22 , ) ; break ; } else if ( VAR10 + VAR11 >= VAR7 -> VAR20 * VAR7 -> VAR21 ) { FUN8 ( VAR2 , VAR22 , ) ; break ; } } else { if ( VAR13 < ( ! ! VAR16 ) * ( 2 * VAR7 -> VAR20 - 1 ) ) { FUN8 ( VAR2 , VAR22 , "" "" ) ; break ; } } if ( VAR15 ) { while ( VAR12 > 0 ) { if ( VAR16 ) { VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR15 [ VAR13 - ( 2 * VAR7 -> VAR20 ) + 1 ] ; VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR15 [ VAR13 ++ ] ; VAR13 ++ ; } else { VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR15 [ VAR13 ++ ] ; VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR15 [ VAR13 ++ ] ; } if ( VAR17 ) VAR13 -= 4 ; VAR12 -- ; } } else { while ( VAR12 > 0 ) { if ( VAR16 ) { VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR19 [ VAR13 - ( 2 * VAR7 -> VAR20 ) + 1 ] ; VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR19 [ VAR13 ++ ] ; VAR13 ++ ; } else { VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR19 [ VAR13 ++ ] ; VAR7 -> VAR19 [ VAR10 ++ ] = VAR7 -> VAR19 [ VAR13 ++ ] ; } if ( VAR17 ) VAR13 -= 4 ; VAR12 -- ; } } if ( VAR18 ) { VAR12 = VAR11 ; VAR10 -= VAR11 * 2 ; while ( VAR12 > 0 ) { VAR18 = VAR7 -> VAR19 [ VAR10 ] ; VAR7 -> VAR19 [ VAR10 ] = VAR7 -> VAR19 [ VAR10 + 1 ] ; VAR7 -> VAR19 [ VAR10 + 1 ] = VAR18 ; VAR12 -- ; VAR10 += 2 ; } } } } } "#0
236#236#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , char * VAR5 , unsigned char * VAR6 , unsigned int * VAR7 ) { int VAR8 ; unsigned char * VAR9 , * VAR10 ; VAR8 = FUN2 ( VAR5 , NULL ) ; if ( ( VAR9 = FUN3 ( VAR8 ) ) == NULL ) { FUN4 ( VAR11 , VAR12 ) ; return ( 0 ) ; } VAR10 = VAR9 ; FUN2 ( VAR5 , & VAR10 ) ; if ( ! FUN5 ( VAR9 , VAR8 , VAR6 , VAR7 , VAR4 , NULL ) ) return 0 ; FUN6 ( VAR9 ) ; return ( 1 ) ; } #1
237#237#static av_always_inline void FUN1 ( VAR1 * VAR2 , const int VAR3 , const int VAR4 , const int VAR5 , const int VAR6 , const int VAR7 , const int VAR8 , const int VAR9 , const int VAR10 , const int VAR11 , const int VAR12 ) { int VAR13 [ 4 ] , VAR14 [ 4 ] , VAR15 [ 4 ] , VAR16 [ 4 ] ; int VAR17 = 0 , VAR18 = 0 , VAR19 = 0 , VAR20 = 0 ; VAR1 * VAR21 ; int VAR22 = 1 , VAR23 = 1 ; int VAR24 , VAR25 ; int VAR26 ; int VAR27 ; for ( VAR26 = 0 , VAR21 = VAR2 ; VAR26 < 4 ; VAR26 ++ , VAR21 += VAR4 ) { VAR13 [ VAR26 ] = VAR21 [ -2 * VAR3 ] - VAR21 [ -1 * VAR3 ] ; VAR14 [ VAR26 ] = VAR21 [ 1 * VAR3 ] - VAR21 [ 0 * VAR3 ] ; VAR17 += VAR13 [ VAR26 ] ; VAR18 += VAR14 [ VAR26 ] ; } VAR24 = FUN2 ( VAR17 ) < ( VAR9 << 2 ) ; VAR25 = FUN2 ( VAR18 ) < ( VAR9 << 2 ) ; if ( ! VAR24 && ! VAR25 ) return ; for ( VAR26 = 0 , VAR21 = VAR2 ; VAR26 < 4 ; VAR26 ++ , VAR21 += VAR4 ) { VAR15 [ VAR26 ] = VAR21 [ -2 * VAR3 ] - VAR21 [ -3 * VAR3 ] ; VAR16 [ VAR26 ] = VAR21 [ 1 * VAR3 ] - VAR21 [ 2 * VAR3 ] ; VAR19 += VAR15 [ VAR26 ] ; VAR20 += VAR16 [ VAR26 ] ; } if ( VAR12 ) { VAR22 = VAR24 && ( FUN2 ( VAR19 ) < VAR10 ) ; VAR23 = VAR25 && ( FUN2 ( VAR20 ) < VAR10 ) ; } else { VAR22 = VAR23 = 0 ; } VAR27 = VAR24 + VAR25 + ( ( VAR6 + VAR7 ) >> 1 ) + 1 ; if ( VAR22 && VAR23 ) { for ( VAR26 = 0 ; VAR26 < 4 ; VAR26 ++ , VAR2 += VAR4 ) { int VAR28 , VAR29 , VAR30 , VAR31 , VAR32 ; int VAR33 = VAR2 [ 0 * VAR3 ] - VAR2 [ -1 * VAR3 ] ; if ( ! VAR33 ) continue ; VAR28 = ( VAR8 * FUN2 ( VAR33 ) ) >> 7 ; if ( VAR28 > 1 ) continue ; VAR29 = ( 25 * VAR2 [ -3 * VAR3 ] + 26 * VAR2 [ -2 * VAR3 ] + 26 * VAR2 [ -1 * VAR3 ] + 26 * VAR2 [ 0 * VAR3 ] + 25 * VAR2 [ 1 * VAR3 ] + VAR34 [ VAR5 + VAR26 ] ) >> 7 ; VAR30 = ( 25 * VAR2 [ -2 * VAR3 ] + 26 * VAR2 [ -1 * VAR3 ] + 26 * VAR2 [ 0 * VAR3 ] + 26 * VAR2 [ 1 * VAR3 ] + 25 * VAR2 [ 2 * VAR3 ] + VAR35 [ VAR5 + VAR26 ] ) >> 7 ; if ( VAR28 ) { VAR29 = FUN3 ( VAR29 , VAR2 [ -1 * VAR3 ] - VAR27 , VAR2 [ -1 * VAR3 ] + VAR27 ) ; VAR30 = FUN3 ( VAR30 , VAR2 [ 0 * VAR3 ] - VAR27 , VAR2 [ 0 * VAR3 ] + VAR27 ) ; } VAR31 = ( 25 * VAR2 [ -4 * VAR3 ] + 26 * VAR2 [ -3 * VAR3 ] + 26 * VAR2 [ -2 * VAR3 ] + 26 * VAR29 + 25 * VAR2 [ 0 * VAR3 ] + VAR34 [ VAR5 + VAR26 ] ) >> 7 ; VAR32 = ( 25 * VAR2 [ -1 * VAR3 ] + 26 * VAR30 + 26 * VAR2 [ 1 * VAR3 ] + 26 * VAR2 [ 2 * VAR3 ] + 25 * VAR2 [ 3 * VAR3 ] + VAR35 [ VAR5 + VAR26 ] ) >> 7 ; if ( VAR28 ) { VAR31 = FUN3 ( VAR31 , VAR2 [ -2 * VAR3 ] - VAR27 , VAR2 [ -2 * VAR3 ] + VAR27 ) ; VAR32 = FUN3 ( VAR32 , VAR2 [ 1 * VAR3 ] - VAR27 , VAR2 [ 1 * VAR3 ] + VAR27 ) ; } VAR2 [ -2 * VAR3 ] = VAR31 ; VAR2 [ -1 * VAR3 ] = VAR29 ; VAR2 [ 0 * VAR3 ] = VAR30 ; VAR2 [ 1 * VAR3 ] = VAR32 ; if ( ! VAR11 ) { VAR2 [ -3 * VAR3 ] = ( 25 * VAR2 [ -1 * VAR3 ] + 26 * VAR2 [ -2 * VAR3 ] + 51 * VAR2 [ -3 * VAR3 ] + 26 * VAR2 [ -4 * VAR3 ] + 64 ) >> 7 ; VAR2 [ 2 * VAR3 ] = ( 25 * VAR2 [ 0 * VAR3 ] + 26 * VAR2 [ 1 * VAR3 ] + 51 * VAR2 [ 2 * VAR3 ] + 26 * VAR2 [ 3 * VAR3 ] + 64 ) >> 7 ; } } } else if ( VAR24 && VAR25 ) { for ( VAR26 = 0 ; VAR26 < 4 ; VAR26 ++ , VAR2 += VAR4 ) FUN4 ( VAR2 , VAR3 , 1 , 1 , VAR8 , VAR9 , VAR27 , VAR6 , VAR7 , VAR13 [ VAR26 ] , VAR14 [ VAR26 ] , VAR15 [ VAR26 ] , VAR16 [ VAR26 ] ) ; } else { for ( VAR26 = 0 ; VAR26 < 4 ; VAR26 ++ , VAR2 += VAR4 ) FUN4 ( VAR2 , VAR3 , VAR24 , VAR25 , VAR8 , VAR9 , VAR27 >> 1 , VAR6 >> 1 , VAR7 >> 1 , VAR13 [ VAR26 ] , VAR14 [ VAR26 ] , VAR15 [ VAR26 ] , VAR16 [ VAR26 ] ) ; } } #1
238#238#"char * FUN1 ( void ) { char * VAR1 ; int VAR2 ; VAR1 = getenv ( ) ; #endif strcat(VAR1,VAR3);  return VAR1; } "#1
239#239#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 , VAR7 ; for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR8 / 2 ; VAR6 ++ ) { VAR7 = FUN2 ( & VAR4 -> VAR9 [ VAR6 ] , VAR2 ) ; VAR4 -> VAR10 [ VAR6 ] = FUN3 ( ) ; if ( ! VAR4 -> VAR10 [ VAR6 ] ) return FUN4 ( VAR11 ) ; VAR4 -> VAR10 [ VAR6 ] -> VAR12 = 512 ; if ( ( VAR7 = FUN5 ( VAR2 , VAR4 -> VAR10 [ VAR6 ] , 0 ) ) < 0 ) { return FUN4 ( VAR11 ) ; } } return VAR7 ; } #1
240#240#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , int VAR7 , int VAR8 ) { GetByteContext VAR9 ; GetBitContext VAR10 ; int VAR11 , VAR12 , VAR13 ; uint32_t VAR14 , VAR15 ; VAR5 * VAR16 ; int VAR17 ; VAR17 = FUN2 ( VAR2 , VAR6 , VAR7 , & VAR9 , & VAR11 , & VAR14 ) ; if ( VAR17 < 0 ) return VAR17 ; VAR13 = VAR2 -> VAR18 / VAR11 ; VAR2 -> VAR19 = VAR20 ; if ( ( VAR17 = FUN3 ( VAR2 , VAR4 , 0 ) ) < 0 ) return VAR17 ; VAR16 = VAR4 -> VAR21 [ 0 ] ; for ( VAR12 = 0 ; VAR12 < VAR11 ; VAR12 ++ ) { VAR15 = FUN4 ( & VAR9 ) ; VAR17 = FUN5 ( VAR2 , VAR6 , VAR7 , VAR15 , VAR14 ) ; if ( VAR17 < 0 ) return VAR17 ; FUN6 ( & VAR10 , VAR6 + VAR14 + 16 , ( VAR15 - 16 ) * 8 ) ; FUN7 ( & VAR10 , VAR2 -> VAR22 , VAR13 , VAR16 , VAR4 -> VAR23 [ 0 ] , VAR8 ) ; VAR16 += VAR4 -> VAR23 [ 0 ] * VAR13 ; VAR14 += VAR15 ; } return 0 ; } #0
241#241#VAR1 * FUN1 ( void ) { VAR1 * VAR2 ; VAR2 = ( VAR1 * ) FUN2 ( sizeof ( VAR1 ) ) ; if ( VAR2 ) memset ( VAR2 , 0 , sizeof ( VAR1 ) ) ; return VAR2 ; } #1
242#242#"static int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 = -1 ; unsigned long VAR7 , VAR8 , VAR9 , VAR10 ; VAR11 * VAR12 = NULL ; unsigned char * VAR13 , * VAR14 , * VAR15 ; FUN2 ( VAR11 ) * VAR16 = NULL ; VAR17 * VAR18 ; VAR19 * VAR20 = NULL ; int VAR21 = 1 ; VAR7 = FUN3 ( VAR2 , VAR22 , VAR23 , -1 , VAR2 -> VAR24 , & VAR5 ) ; if ( ! VAR5 ) return ( ( int ) VAR7 ) ; if ( VAR2 -> VAR25 -> VAR26 . VAR27 == VAR28 ) { VAR2 -> VAR25 -> VAR26 . VAR29 = 1 ; return ( 1 ) ; } if ( VAR2 -> VAR25 -> VAR26 . VAR27 != VAR30 ) { VAR3 = VAR31 ; FUN4 ( VAR32 , VAR33 ) ; goto VAR34 ; } VAR14 = VAR13 = ( unsigned char * ) VAR2 -> VAR35 -> VAR36 ; if ( ( VAR16 = FUN5 ( ) ) == NULL ) { FUN4 ( VAR32 , VAR37 ) ; goto VAR38 ; } FUN6 ( VAR13 , VAR9 ) ; if ( VAR9 + 3 != VAR7 ) { VAR3 = VAR39 ; FUN4 ( VAR32 , VAR40 ) ; goto VAR34 ; } for ( VAR8 = 0 ; VAR8 < VAR9 ; ) { FUN6 ( VAR13 , VAR10 ) ; if ( ( VAR10 + VAR8 + 3 ) > VAR9 ) { VAR3 = VAR39 ; FUN4 ( VAR32 , VAR41 ) ; goto VAR34 ; } VAR15 = VAR13 ; VAR12 = FUN7 ( NULL , & VAR15 , VAR10 ) ; if ( VAR12 == NULL ) { VAR3 = VAR42 ; FUN4 ( VAR32 , VAR43 ) ; goto VAR34 ; } if ( VAR15 != ( VAR13 + VAR10 ) ) { VAR3 = VAR39 ; FUN4 ( VAR32 , VAR41 ) ; goto VAR34 ; } if ( ! FUN8 ( VAR16 , VAR12 ) ) { FUN4 ( VAR32 , VAR37 ) ; goto VAR38 ; } VAR12 = NULL ; VAR8 += VAR10 + 3 ; VAR13 = VAR15 ; } VAR4 = FUN9 ( VAR2 , VAR16 ) ; if ( ( VAR2 -> VAR44 != VAR45 ) && ( ! VAR4 ) #ifndef VAR46 && ( VAR2 -> VAR25 -> VAR26 . VAR47 -> VAR48 & ( VAR49 | VAR50 ) ) != ( VAR51 | VAR52 ) #endif ) { VAR3 = FUN10 ( VAR2 -> VAR53 ) ; FUN4 ( VAR32 , VAR54 ) ; goto VAR34 ; } FUN11 ( ) ; VAR18 = FUN12 ( ) ; if ( VAR18 == NULL ) goto VAR38 ; if ( VAR2 -> VAR55 -> VAR56 ) FUN13 ( VAR2 -> VAR55 -> VAR56 ) ; VAR2 -> VAR55 -> VAR56 = VAR18 ; VAR18 -> VAR57 = VAR16 ; VAR12 = FUN14 ( VAR16 , 0 ) ; VAR16 = NULL ; VAR20 = FUN15 ( VAR12 ) ; VAR21 = ( ( VAR2 -> VAR25 -> VAR26 . VAR47 -> VAR48 & ( VAR49 | VAR50 ) ) == ( VAR51 | VAR52 ) ) ? 0 : 1 ; #ifdef VAR58 FUN16 ( , FUN17 ( VAR12 , VAR20 ) ) ; FUN16 ( "" "" , VAR2 -> VAR25 -> VAR26 . VAR47 -> VAR59 , VAR2 -> VAR25 -> VAR26 . VAR47 -> VAR48 , VAR21 ) ; #endif if ( VAR21 && ( ( VAR20 == NULL ) || FUN18 ( VAR20 ) ) ) { VAR12 = NULL ; VAR3 = VAR60 ; FUN4 ( VAR32 , VAR61 ) ; goto VAR34 ; } VAR4 = FUN17 ( VAR12 , VAR20 ) ; if ( VAR21 && VAR4 < 0 ) { VAR12 = NULL ; VAR3 = VAR60 ; FUN4 ( VAR32 , VAR62 ) ; goto VAR34 ; } if ( VAR21 ) { VAR18 -> VAR63 = VAR4 ; FUN19 ( & VAR12 -> VAR64 , 1 , VAR65 ) ; if ( VAR18 -> VAR66 [ VAR4 ] . VAR67 != NULL ) FUN20 ( VAR18 -> VAR66 [ VAR4 ] . VAR67 ) ; VAR18 -> VAR66 [ VAR4 ] . VAR67 = VAR12 ; VAR18 -> VAR68 = & ( VAR18 -> VAR66 [ VAR4 ] ) ; if ( VAR2 -> VAR55 -> VAR69 != NULL ) FUN20 ( VAR2 -> VAR55 -> VAR69 ) ; FUN19 ( & VAR12 -> VAR64 , 1 , VAR65 ) ; VAR2 -> VAR55 -> VAR69 = VAR12 ; } else { VAR18 -> VAR63 = VAR4 ; VAR18 -> VAR68 = NULL ; if ( VAR2 -> VAR55 -> VAR69 != NULL ) FUN20 ( VAR2 -> VAR55 -> VAR69 ) ; VAR2 -> VAR55 -> VAR69 = NULL ; } VAR2 -> VAR55 -> VAR53 = VAR2 -> VAR53 ; VAR12 = NULL ; VAR6 = 1 ; if ( 0 ) { VAR34 : FUN21 ( VAR2 , VAR60 , VAR3 ) ; } VAR38 : FUN22 ( VAR20 ) ; FUN20 ( VAR12 ) ; FUN23 ( VAR16 , VAR70 ) ; return ( VAR6 ) ; } "#0
243#243#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; if ( VAR6 -> VAR8 ) { unsigned int VAR9 ; if ( VAR6 -> VAR10 >= VAR6 -> VAR11 ) return VAR12 ; if ( VAR6 -> VAR13 == -1 ) { VAR6 -> VAR14 = FUN2 ( VAR2 -> VAR15 ) - 4 ; VAR6 -> VAR16 = FUN3 ( VAR2 -> VAR15 ) ; VAR6 -> VAR17 = ( VAR6 -> VAR16 & VAR18 ) ? 4 : 0 ; if ( VAR6 -> VAR17 ) FUN4 ( VAR2 -> VAR15 , VAR6 -> VAR19 , VAR6 -> VAR17 ) ; VAR6 -> VAR20 = ( VAR6 -> VAR16 & VAR21 ) ? FUN2 ( VAR2 -> VAR15 ) : 0 ; VAR6 -> VAR13 = ! ! ( VAR6 -> VAR16 & VAR21 ) ; } if ( ! VAR6 -> VAR13 ) { if ( VAR6 -> VAR14 < 2LL + VAR6 -> VAR20 + VAR6 -> VAR17 ) return VAR22 ; VAR9 = VAR6 -> VAR14 - VAR6 -> VAR20 - VAR6 -> VAR17 - 2 ; VAR9 = FUN5 ( VAR2 -> VAR15 , VAR9 ) ; if ( FUN6 ( VAR4 , VAR9 + VAR6 -> VAR17 + 2 ) < 0 ) return FUN7 ( VAR23 ) ; FUN8 ( VAR4 -> VAR24 , VAR6 -> VAR16 ) ; if ( VAR6 -> VAR17 ) memcpy ( VAR4 -> VAR24 + 2 , VAR6 -> VAR19 , VAR6 -> VAR17 ) ; if ( FUN4 ( VAR2 -> VAR15 , VAR4 -> VAR24 + 2 + VAR6 -> VAR17 , VAR9 ) != VAR9 ) { FUN9 ( VAR4 ) ; return VAR22 ; } VAR4 -> VAR25 = 0 ; VAR6 -> VAR13 = -1 ; } else { int VAR14 = FUN10 ( VAR2 -> VAR15 , VAR4 , VAR6 -> VAR20 - 4 ) ; if ( VAR14 < 0 ) return FUN7 ( VAR26 ) ; VAR4 -> VAR25 = 1 ; VAR4 -> VAR27 = VAR14 ; VAR6 -> VAR13 = 0 ; } if ( ! VAR6 -> VAR10 || VAR6 -> VAR13 ) VAR4 -> VAR16 |= VAR28 ; if ( VAR6 -> VAR13 == -1 ) VAR6 -> VAR10 ++ ; } else { int VAR14 = FUN10 ( VAR2 -> VAR15 , VAR4 , VAR6 -> VAR29 ) ; if ( ! VAR14 ) return VAR12 ; if ( VAR14 <= 0 ) return FUN7 ( VAR26 ) ; VAR4 -> VAR27 = VAR14 ; } return VAR4 -> VAR9 ; } #0
244#244#static void FUN1 ( VAR1 * VAR2 , VAR1 * * VAR3 , VAR1 * * VAR4 , VAR1 * * VAR5 ) { VAR1 * * VAR6 = VAR3 ? VAR3 : VAR5 ; VAR1 * VAR7 = * VAR6 ; if ( FUN2 ( VAR2 ) ) { FUN3 ( VAR2 -> VAR8 -> VAR9 , VAR2 , VAR10 ) ; } if ( VAR4 && * VAR4 == VAR2 ) * VAR4 = ( * VAR4 ) -> VAR11 ; if ( * VAR6 == VAR2 ) { * VAR6 = ( * VAR6 ) -> VAR11 ; return ; } while ( VAR7 -> VAR11 != VAR2 ) { if ( ! ( VAR7 = VAR7 -> VAR11 ) ) { return ; } } VAR7 -> VAR11 = VAR2 -> VAR11 ; } #0
245#245#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { const int VAR6 = VAR2 -> VAR7 << VAR2 -> VAR8 ; const int VAR9 = VAR2 -> VAR8 - VAR3 ; const int VAR10 = ( VAR4 + VAR5 * VAR6 ) << VAR9 ; int VAR11 = ( VAR4 + 1 ) << VAR9 ; const VAR12 * VAR13 = VAR4 ? & VAR2 -> VAR14 [ VAR10 - 1 ] : & VAR15 ; const VAR12 * VAR16 = VAR5 ? & VAR2 -> VAR14 [ VAR10 - VAR6 ] : & VAR15 ; const VAR12 * VAR17 = VAR5 && VAR4 ? & VAR2 -> VAR14 [ VAR10 - VAR6 - 1 ] : VAR13 ; const VAR12 * VAR18 = VAR5 && VAR11 < VAR6 && ( ( VAR4 & 1 ) == 0 || VAR3 == 0 ) ? & VAR2 -> VAR14 [ VAR10 - VAR6 + ( 1 << VAR9 ) ] : VAR17 ; int VAR19 = 2 * VAR13 -> VAR3 + 2 * VAR16 -> VAR3 + VAR17 -> VAR3 + VAR18 -> VAR3 ; int VAR20 ; if ( VAR2 -> VAR21 ) { FUN2 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR15 . VAR22 [ 0 ] , VAR15 . VAR22 [ 1 ] , VAR15 . VAR22 [ 2 ] , VAR15 . VAR23 , VAR15 . VAR24 , VAR15 . VAR25 , VAR26 ) ; return 0 ; } if ( VAR3 == VAR2 -> VAR8 || FUN3 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 4 + VAR19 ] ) ) { int VAR29 , VAR23 , VAR24 ; int VAR30 = VAR13 -> VAR22 [ 0 ] ; int VAR31 = VAR13 -> VAR22 [ 1 ] ; int VAR32 = VAR13 -> VAR22 [ 2 ] ; unsigned VAR25 = 0 ; int VAR33 = FUN4 ( 2 * VAR13 -> VAR25 ) + FUN4 ( 2 * VAR16 -> VAR25 ) ; int VAR34 = FUN4 ( 2 * FUN5 ( VAR13 -> VAR23 - VAR16 -> VAR23 ) ) + 0 * FUN4 ( 2 * FUN5 ( VAR18 -> VAR23 - VAR16 -> VAR23 ) ) ; int VAR35 = FUN4 ( 2 * FUN5 ( VAR13 -> VAR24 - VAR16 -> VAR24 ) ) + 0 * FUN4 ( 2 * FUN5 ( VAR18 -> VAR24 - VAR16 -> VAR24 ) ) ; VAR29 = FUN3 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 1 + VAR13 -> VAR29 + VAR16 -> VAR29 ] ) ? VAR26 : 0 ; if ( VAR29 ) { int VAR36 , VAR37 , VAR38 ; FUN6 ( VAR2 , & VAR23 , & VAR24 , 0 , VAR13 , VAR16 , VAR18 ) ; VAR36 = FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 32 ] , 1 ) ; if ( VAR36 < -255 || VAR36 > 255 ) { return VAR39 ; } VAR30 += VAR36 ; if ( VAR2 -> VAR40 > 2 ) { VAR37 = FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 64 ] , 1 ) ; VAR38 = FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 96 ] , 1 ) ; if ( VAR37 < -255 || VAR37 > 255 || VAR38 < -255 || VAR38 > 255 ) { return VAR39 ; } VAR31 += VAR37 ; VAR32 += VAR38 ; } } else { if ( VAR2 -> VAR41 > 1 ) VAR25 = FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 128 + 1024 + 32 * VAR33 ] , 0 ) ; if ( VAR25 >= VAR2 -> VAR41 ) { FUN8 ( VAR2 -> VAR42 , VAR43 , "" "" ) ; return VAR39 ; } FUN6 ( VAR2 , & VAR23 , & VAR24 , VAR25 , VAR13 , VAR16 , VAR18 ) ; VAR23 += FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 128 + 32 * ( VAR34 + 16 * ! ! VAR25 ) ] , 1 ) ; VAR24 += FUN7 ( & VAR2 -> VAR27 , & VAR2 -> VAR28 [ 128 + 32 * ( VAR35 + 16 * ! ! VAR25 ) ] , 1 ) ; } FUN2 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR30 , VAR31 , VAR32 , VAR23 , VAR24 , VAR25 , VAR29 ) ; } else { if ( ( VAR20 = FUN1 ( VAR2 , VAR3 + 1 , 2 * VAR4 + 0 , 2 * VAR5 + 0 ) ) < 0 || ( VAR20 = FUN1 ( VAR2 , VAR3 + 1 , 2 * VAR4 + 1 , 2 * VAR5 + 0 ) ) < 0 || ( VAR20 = FUN1 ( VAR2 , VAR3 + 1 , 2 * VAR4 + 0 , 2 * VAR5 + 1 ) ) < 0 || ( VAR20 = FUN1 ( VAR2 , VAR3 + 1 , 2 * VAR4 + 1 , 2 * VAR5 + 1 ) ) < 0 ) return VAR20 ; } return 0 ; } "#0
246#246#static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { ngx_int_t VAR6 ; VAR7 * VAR8 ; FUN2 ( & VAR3 -> VAR9 -> mutex ) ; VAR8 = VAR5 -> VAR10 ; if ( VAR8 == NULL ) { VAR8 = FUN3 ( VAR3 , VAR5 -> VAR11 ) ; } if ( VAR8 ) { FUN4 ( & VAR8 -> VAR12 ) ; if ( VAR5 -> VAR10 == NULL ) { VAR8 -> VAR13 ++ ; VAR8 -> VAR14 ++ ; } if ( VAR8 -> VAR15 ) { if ( VAR8 -> VAR16 < FUN5 ( ) ) { goto VAR17 ; } VAR6 = VAR18 ; goto VAR19 ; } if ( VAR8 -> VAR20 || VAR8 -> VAR13 >= VAR5 -> VAR21 ) { VAR5 -> VAR20 = VAR8 -> VAR20 ; if ( VAR8 -> VAR22 ) { VAR5 -> VAR22 = VAR8 -> VAR22 ; } VAR6 = VAR18 ; goto VAR19 ; } VAR6 = VAR23 ; goto VAR19 ; } VAR8 = FUN6 ( VAR3 -> VAR9 , sizeof ( VAR7 ) ) ; if ( VAR8 == NULL ) { FUN7 ( & VAR3 -> VAR9 -> mutex ) ; ( void ) FUN8 ( VAR3 ) ; FUN2 ( & VAR3 -> VAR9 -> mutex ) ; VAR8 = FUN6 ( VAR3 -> VAR9 , sizeof ( VAR7 ) ) ; if ( VAR8 == NULL ) { VAR6 = VAR24 ; goto VAR25 ; } } FUN9 ( ( VAR26 * ) & VAR8 -> VAR10 . VAR11 , VAR5 -> VAR11 , sizeof ( VAR27 ) ) ; FUN9 ( VAR8 -> VAR11 , & VAR5 -> VAR11 [ sizeof ( VAR27 ) ] , VAR28 - sizeof ( VAR27 ) ) ; FUN10 ( & VAR3 -> VAR29 -> VAR30 , & VAR8 -> VAR10 ) ; VAR8 -> VAR13 = 1 ; VAR8 -> VAR14 = 1 ; VAR17 : VAR6 = VAR31 ; VAR8 -> VAR32 = 0 ; VAR8 -> VAR15 = 0 ; VAR8 -> VAR20 = 0 ; VAR8 -> VAR16 = 0 ; VAR8 -> VAR33 = 0 ; VAR8 -> VAR22 = 0 ; VAR8 -> VAR34 = 0 ; VAR19 : VAR8 -> VAR35 = FUN5 ( ) + VAR3 -> VAR36 ; FUN11 ( & VAR3 -> VAR29 -> VAR12 , & VAR8 -> VAR12 ) ; VAR5 -> VAR33 = VAR8 -> VAR33 ; VAR5 -> VAR15 = VAR8 -> VAR15 ; VAR5 -> VAR10 = VAR8 ; VAR25 : FUN7 ( & VAR3 -> VAR9 -> mutex ) ; return VAR6 ; } #0
247#247#void FUN1 ( VAR1 * VAR2 , const unsigned char * VAR3 , int VAR4 ) { if ( VAR2 -> VAR5 -> VAR6 && ! ( VAR2 -> VAR5 -> VAR7 & VAR8 ) ) { FUN2 ( VAR2 -> VAR5 -> VAR6 , ( void * ) VAR3 , VAR4 ) ; } else { int VAR9 ; for ( VAR9 = 0 ; VAR9 < VAR10 ; VAR9 ++ ) { if ( VAR2 -> VAR5 -> VAR11 [ VAR9 ] != NULL ) EVP_DigestUpdate ( VAR2 -> VAR5 -> VAR11 [ VAR9 ] , VAR3 , VAR4 ) ; } } } #1
248#248#"static char * FUN1 ( const char * * VAR1 , void * VAR2 ) { const char * VAR3 = * VAR1 ; char * VAR4 ; ( * VAR1 ) ++ ; VAR4 = FUN2 ( VAR1 , % VAR6 % VAR6 "" "" "#1
249#249#"FUN1 ( VAR1 ) * FUN2 ( const VAR2 * VAR3 , FUN1 ( VAR1 ) * * VAR4 , FUN1 ( VAR1 ) * * VAR5 , const char * VAR6 , VAR7 * VAR8 ) { int VAR9 , VAR10 , VAR11 , VAR12 ; uint32_t VAR13 , VAR14 , VAR15 , VAR16 , VAR17 ; FUN1 ( VAR1 ) * VAR18 , * VAR19 ; const char * VAR20 ; VAR21 * VAR22 = NULL , * VAR23 = NULL , * VAR24 = NULL , * VAR25 ; const VAR1 * * VAR26 = NULL ; if ( VAR6 == NULL || VAR4 == NULL || VAR5 == NULL ) return NULL ; #ifndef OPENSSL_NO_EC if ( ! FUN3 ( VAR3 , VAR8 , & VAR6 ) ) return NULL ; #endif VAR13 = VAR27 ; VAR14 = VAR28 ; VAR15 = VAR29 ; VAR16 = VAR30 ; VAR17 = 0 ; VAR10 = VAR3 -> FUN4 ( ) ; VAR22 = FUN5 ( sizeof ( * VAR22 ) * VAR10 ) ; if ( VAR22 == NULL ) { FUN6 ( VAR31 , VAR32 ) ; return ( NULL ) ; } FUN7 ( VAR3 , VAR10 , VAR13 , VAR14 , VAR15 , VAR16 , VAR17 , VAR22 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , VAR33 , 0 , 0 , 0 , 0 , 0 , VAR34 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , VAR33 , 0 , 0 , 0 , 0 , 0 , VAR35 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , 0 , VAR36 , 0 , 0 , 0 , VAR34 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , VAR34 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , 0 , 0 , VAR37 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , VAR39 , 0 , 0 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , VAR40 , 0 , 0 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , VAR41 , 0 , 0 , 0 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , VAR42 , 0 , 0 , 0 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; FUN8 ( 0 , 0 , 0 , VAR43 , 0 , 0 , 0 , VAR38 , -1 , & VAR23 , & VAR24 ) ; if ( ! FUN9 ( & VAR23 , & VAR24 ) ) { FUN10 ( VAR22 ) ; return NULL ; } FUN8 ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , VAR35 , -1 , & VAR23 , & VAR24 ) ; VAR12 = FUN11 ( VAR44 ) ; VAR11 = VAR10 + VAR12 + 1 ; VAR26 = FUN5 ( sizeof ( * VAR26 ) * VAR11 ) ; if ( VAR26 == NULL ) { FUN10 ( VAR22 ) ; FUN6 ( VAR31 , VAR32 ) ; return ( NULL ) ; } FUN12 ( VAR26 , VAR12 , VAR13 , VAR14 , VAR15 , VAR16 , VAR17 , VAR23 ) ; VAR9 = 1 ; VAR20 = VAR6 ; if ( FUN13 ( VAR6 , , VAR25 -> VAR48 -> VAR53 ) ; #endif } } FUN10 ( VAR22 ) ; VAR19 = FUN19 ( VAR18 ) ; if ( VAR19 == NULL ) { FUN18 ( VAR18 ) ; return NULL ; } FUN18 ( * VAR4 ) ; * VAR4 = VAR18 ; if ( * VAR5 != NULL ) FUN18 ( * VAR5 ) ; * VAR5 = VAR19 ; ( void ) FUN20 ( * VAR5 , VAR54 ) ; FUN21 ( * VAR5 ) ; return ( VAR18 ) ; } "#1
250#250#static av_always_inline int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { int16_t VAR6 ; int VAR7 , VAR8 , VAR9 ; FUN2 ( VAR10 , VAR2 ) ; FUN3 ( VAR7 , VAR11 ) ; VAR6 = FUN4 ( VAR7 ) ; VAR4 [ 0 ] = VAR6 ; VAR4 += 64 ; VAR7 = 5 ; VAR9 = 0 ; for ( VAR8 = 1 ; VAR8 < VAR5 ; VAR8 ++ , VAR4 += 64 ) { FUN3 ( VAR7 , VAR12 [ FUN5 ( VAR7 , 6U ) ] ) ; if ( VAR7 ) VAR9 ^= - ( VAR7 & 1 ) ; else VAR9 = 0 ; VAR6 += ( ( ( VAR7 + 1 ) >> 1 ) ^ VAR9 ) - VAR9 ; VAR4 [ 0 ] = VAR6 ; } FUN6 ( VAR10 , VAR2 ) ; return 0 ; } #0
251#251#static void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 ) { int VAR5 , VAR6 , VAR7 , VAR8 , VAR9 ; for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR10 ; VAR5 ++ ) { int32_t VAR11 [ 512 ] ; int VAR12 = 0 ; const int VAR13 = VAR2 -> VAR14 [ VAR5 ] ; memcpy ( VAR11 , & VAR2 -> VAR15 [ VAR5 ] [ 0 ] , 512 * sizeof ( VAR3 ) ) ; for ( VAR6 = 0 ; VAR6 < VAR16 ; VAR6 ++ ) { int32_t VAR17 [ 64 ] ; int32_t VAR18 ; int VAR19 ; memset ( VAR17 , 0 , 64 * sizeof ( VAR3 ) ) ; for ( VAR8 = 0 , VAR7 = VAR12 , VAR9 = 0 ; VAR7 < 512 ; VAR8 = ( VAR8 + 1 ) & 63 , VAR7 ++ , VAR9 ++ ) VAR17 [ VAR8 ] += FUN2 ( VAR11 [ VAR7 ] , VAR2 -> VAR20 [ VAR9 ] ) ; for ( VAR7 = 0 ; VAR7 < VAR12 ; VAR8 = ( VAR8 + 1 ) & 63 , VAR7 ++ , VAR9 ++ ) VAR17 [ VAR8 ] += FUN2 ( VAR11 [ VAR7 ] , VAR2 -> VAR20 [ VAR9 ] ) ; for ( VAR8 = 16 ; VAR8 < 32 ; VAR8 ++ ) VAR17 [ VAR8 ] = VAR17 [ VAR8 ] - VAR17 [ 31 - VAR8 ] ; for ( VAR8 = 32 ; VAR8 < 48 ; VAR8 ++ ) VAR17 [ VAR8 ] = VAR17 [ VAR8 ] + VAR17 [ 95 - VAR8 ] ; for ( VAR19 = 0 ; VAR19 < 32 ; VAR19 ++ ) { VAR18 = 0 ; for ( VAR7 = 16 ; VAR7 < 48 ; VAR7 ++ ) { int VAR21 = ( 2 * VAR19 + 1 ) * ( 2 * ( VAR7 + 16 ) + 1 ) ; VAR18 += FUN2 ( VAR17 [ VAR7 ] , FUN3 ( VAR21 << 3 ) ) >> 3 ; } VAR2 -> VAR22 [ VAR5 ] [ VAR19 ] [ VAR6 ] = ( ( VAR19 + 1 ) & 2 ) ? - VAR18 : VAR18 ; } for ( VAR7 = 0 ; VAR7 < 32 ; VAR7 ++ ) VAR11 [ VAR7 + VAR12 ] = VAR4 [ ( VAR6 * 32 + VAR7 ) * VAR2 -> VAR23 + VAR13 ] ; VAR12 = ( VAR12 + 32 ) & 511 ; } } } #0
252#252#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 ) { int VAR7 , VAR8 ; int VAR9 = 0 ; int VAR10 = VAR2 -> VAR11 [ 0 ] ; VAR12 * VAR13 = VAR2 -> VAR14 -> VAR13 [ VAR10 ] ; int VAR15 = VAR2 -> VAR15 [ VAR10 ] ; int VAR16 = 0 ; VAR17 * VAR18 = VAR2 -> VAR19 [ VAR2 -> VAR20 [ 0 ] ] ; int VAR21 = 1 + ( VAR2 -> VAR22 > 8 ) ; FUN2 ( VAR3 >= 0 && VAR5 >= 0 && VAR6 >= 0 ) ; if ( VAR4 < VAR3 || VAR4 > 63 ) { FUN3 ( VAR2 -> VAR23 , VAR24 , , VAR8 , VAR7 ) ; return VAR25 ; } if ( VAR16 ) { VAR2 -> VAR42 . FUN7 ( VAR31 , VAR15 , * VAR35 ) ; if ( VAR2 -> VAR22 & 7 ) FUN8 ( VAR2 , VAR31 , VAR15 ) ; VAR31 += VAR21 * 8 >> VAR2 -> VAR23 -> VAR32 ; } if ( FUN9 ( VAR2 , 0 ) ) VAR9 = 0 ; } } return 0 ; } #1
253#253#int FUN1 ( const VAR1 * VAR2 , const VAR1 * VAR3 ) { int VAR4 ; int VAR5 , VAR6 ; BN_ULONG VAR7 , VAR8 ; if ( ( VAR2 == NULL ) || ( VAR3 == NULL ) ) { if ( VAR2 != NULL ) return ( -1 ) ; else if ( VAR3 != NULL ) return ( 1 ) ; else return ( 0 ) ; } FUN2 ( VAR2 ) ; FUN2 ( VAR3 ) ; if ( VAR2 -> VAR9 != VAR3 -> VAR9 ) { if ( VAR2 -> VAR9 ) return ( -1 ) ; else return ( 1 ) ; } if ( VAR2 -> VAR9 == 0 ) { VAR5 = 1 ; VAR6 = -1 ; } else { VAR5 = -1 ; VAR6 = 1 ; } if ( VAR2 -> VAR10 > VAR3 -> VAR10 ) return ( VAR5 ) ; if ( VAR2 -> VAR10 < VAR3 -> VAR10 ) return ( VAR6 ) ; for ( VAR4 = VAR2 -> VAR10 - 1 ; VAR4 >= 0 ; VAR4 -- ) { VAR7 = VAR2 -> VAR11 [ VAR4 ] ; VAR8 = VAR3 -> VAR11 [ VAR4 ] ; if ( VAR7 > VAR8 ) return ( VAR5 ) ; if ( VAR7 < VAR8 ) return ( VAR6 ) ; } return ( 0 ) ; } #1
254#254#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 ) { VAR3 * VAR7 = & VAR6 -> VAR8 ; const VAR9 * VAR10 = FUN2 ( VAR7 -> VAR11 ) ; int VAR12 ; int VAR13 = FUN3 ( VAR4 , VAR7 ) ; if ( VAR13 < 0 ) return VAR13 ; FUN4 ( & VAR4 -> VAR14 , "" "" , FUN5 ( VAR2 ) , 0 ) ; if ( ! VAR6 -> VAR15 ) return 0 ; for ( VAR12 = 0 ; VAR12 < VAR10 -> VAR16 ; VAR12 ++ ) { int VAR17 = ( VAR12 > 0 ) ? VAR10 -> VAR18 : 0 ; int VAR19 = ( VAR12 > 0 ) ? VAR10 -> VAR20 : 0 ; int VAR21 = ( ( VAR6 -> VAR22 >> VAR17 ) << VAR2 -> VAR23 ) + ( VAR6 -> VAR24 >> VAR19 ) * VAR4 -> VAR25 [ VAR12 ] ; VAR4 -> VAR26 [ VAR12 ] += VAR21 ; } return 0 ; } "#0
255#255#static VAR1 FUN1 ( VAR2 * VAR3 , int VAR4 ) { uint8_t VAR5 , VAR6 , VAR7 , VAR8 , VAR9 ; FUN2 ( & VAR3 -> VAR10 ) ; VAR5 = FUN2 ( & VAR3 -> VAR10 ) ; VAR6 = ( VAR5 >> 4 ) & 0x03 ; VAR7 = ( VAR5 >> 6 ) & 0x01 ; VAR8 = ( VAR4 - 4 ) / ( ( VAR7 + 1 ) * 2 + VAR6 ) ; for ( VAR9 = 0 ; VAR9 < VAR8 ; VAR9 ++ ) { switch ( VAR6 ) { case 0 : break ; case 1 : FUN2 ( & VAR3 -> VAR10 ) ; break ; case 2 : FUN3 ( & VAR3 -> VAR10 ) ; break ; case 3 : FUN4 ( & VAR3 -> VAR10 ) ; break ; } if ( VAR7 == 0 ) { FUN3 ( & VAR3 -> VAR10 ) ; } else { FUN4 ( & VAR3 -> VAR10 ) ; } } return 0 ; } #1
256#256#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; ThreadFrame VAR14 = { . VAR15 = VAR3 } ; VAR16 * VAR17 = VAR3 ; int VAR18 = 1 ; int VAR19 , VAR20 ; FUN2 ( VAR2 , , VAR2 -> VAR22 , VAR2 -> VAR23 , VAR12 -> VAR22 , VAR12 -> VAR23 ) ; VAR18 = 1 ; } if ( VAR2 -> VAR25 != VAR26 && VAR2 -> VAR25 != VAR12 -> VAR25 ) { FUN4 ( VAR2 , VAR24 , , VAR19 ) ; return VAR39 ; } * VAR4 = 1 ; return VAR6 -> VAR10 ; } #1
257#257#"VAR1 FUN1 ( VAR2 * VAR3 , VAR2 * VAR4 , size_t VAR5 , ngx_uint_t VAR6 ) { ngx_uint_t VAR7 , VAR8 ; VAR9 * VAR10 ; static u_char VAR11 [ ] = "" "" ; static uint32_t VAR12 [ ] = { 0xffffffff , 0x80000029 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR13 [ ] = { 0xffffffff , 0x80000829 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR14 [ ] = { 0xffffffff , 0x000000ad , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR15 [ ] = { 0xffffffff , 0x00000085 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR16 [ ] = { 0xffffffff , 0x00000021 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , } ; static VAR9 * VAR17 [ ] = { VAR12 , VAR13 , VAR14 , VAR15 , VAR16 , VAR16 } ; VAR10 = VAR17 [ VAR6 ] ; if ( VAR3 == NULL ) { VAR8 = 0 ; for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 ++ ) { if ( VAR10 [ * VAR4 >> 5 ] & ( 1 << ( * VAR4 & 0x1f ) ) ) { VAR8 ++ ; } VAR4 ++ ; } return ( VAR1 ) VAR8 ; } for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 ++ ) { if ( VAR10 [ * VAR4 >> 5 ] & ( 1 << ( * VAR4 & 0x1f ) ) ) { * VAR3 ++ = ' ' ; * VAR3 ++ = VAR11 [ * VAR4 >> 4 ] ; * VAR3 ++ = VAR11 [ * VAR4 & 0xf ] ; VAR4 ++ ; } else { * VAR3 ++ = * VAR4 ++ ; } } return ( VAR1 ) VAR3 ; } "#1
258#258#int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; VAR2 -> VAR4 = VAR2 -> VAR5 * VAR2 -> VAR6 ; FUN2 ( VAR2 -> VAR4 > 0 ) ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR4 ; VAR3 ++ ) { VAR1 * VAR7 = FUN3 ( sizeof ( * VAR7 ) ) ; int VAR8 = VAR3 % VAR2 -> VAR5 ; int VAR9 = VAR3 / VAR2 -> VAR5 ; int VAR10 = VAR2 -> VAR11 -> VAR12 * VAR8 / VAR2 -> VAR5 ; int VAR13 = VAR2 -> VAR11 -> VAR12 * ( VAR8 + 1 ) / VAR2 -> VAR5 ; int VAR14 = VAR2 -> VAR11 -> VAR15 * VAR9 / VAR2 -> VAR6 ; int VAR16 = VAR2 -> VAR11 -> VAR15 * ( VAR9 + 1 ) / VAR2 -> VAR6 ; if ( ! VAR7 ) return FUN4 ( VAR17 ) ; VAR2 -> VAR18 [ VAR3 ] = VAR7 ; memcpy ( VAR7 , VAR2 , sizeof ( * VAR7 ) ) ; memset ( VAR7 -> VAR19 , 0 , sizeof ( VAR7 -> VAR19 ) ) ; VAR7 -> VAR20 = VAR13 - VAR10 ; VAR7 -> VAR21 = VAR16 - VAR14 ; VAR7 -> VAR22 = VAR10 ; VAR7 -> VAR23 = VAR14 ; VAR7 -> VAR24 = FUN5 ( 3 * VAR25 * ( VAR7 -> VAR12 + 6 ) * sizeof ( * VAR7 -> VAR24 ) ) ; if ( ! VAR7 -> VAR24 ) return FUN4 ( VAR17 ) ; } return 0 ; } #0
259#259#"int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , const unsigned char * VAR5 , const unsigned char * VAR6 , size_t VAR7 , unsigned char * VAR8 ) { size_t VAR9 , VAR10 ; int VAR11 ; int VAR12 ; VAR13 * VAR14 = FUN2 ( VAR15 , NULL ) ; static const char VAR16 [ ] = "" "" ; unsigned char VAR17 [ VAR18 ] ; if ( VAR14 == NULL ) { FUN3 ( VAR2 , VAR19 , VAR20 , VAR21 ) ; return 0 ; } VAR11 = FUN4 ( VAR4 ) ; if ( ! FUN5 ( VAR11 >= 0 ) ) { FUN3 ( VAR2 , VAR19 , VAR20 , VAR21 ) ; return 0 ; } VAR9 = ( VAR22 ) VAR11 ; if ( VAR6 == NULL ) { VAR6 = VAR23 ; VAR7 = VAR9 ; } if ( VAR5 == NULL ) { VAR5 = VAR23 ; VAR10 = 0 ; } else { VAR24 * VAR25 = FUN6 ( ) ; unsigned char VAR26 [ VAR18 ] ; if ( VAR25 == NULL || EVP_DigestInit_ex ( VAR25 , VAR4 , NULL ) <= 0 || FUN7 ( VAR25 , VAR26 , NULL ) <= 0 ) { FUN3 ( VAR2 , VAR19 , VAR20 , VAR21 ) ; FUN8 ( VAR25 ) ; FUN9 ( VAR14 ) ; return 0 ; } FUN8 ( VAR25 ) ; if ( ! FUN10 ( VAR2 , VAR4 , VAR5 , ( unsigned char * ) VAR16 , sizeof ( VAR16 ) - 1 , VAR26 , VAR9 , VAR17 , VAR9 , 1 ) ) { FUN9 ( VAR14 ) ; return 0 ; } VAR5 = VAR17 ; VAR10 = VAR9 ; } VAR12 = FUN11 ( VAR14 ) <= 0 || FUN12 ( VAR14 , VAR27 ) <= 0 || FUN13 ( VAR14 , VAR4 ) <= 0 || FUN14 ( VAR14 , VAR6 , VAR7 ) <= 0 || FUN15 ( VAR14 , VAR5 , VAR10 ) <= 0 || FUN16 ( VAR14 , VAR8 , & VAR9 ) <= 0 ; if ( VAR12 != 0 ) FUN3 ( VAR2 , VAR19 , VAR20 , VAR21 ) ; FUN9 ( VAR14 ) ; if ( VAR5 == VAR17 ) FUN17 ( VAR17 , VAR9 ) ; return VAR12 == 0 ; } "#0
260#260#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; uint8_t VAR9 ; unsigned int VAR10 , VAR11 , VAR12 ; uint16_t VAR13 ; if ( VAR5 <= 4 ) return -1 ; VAR5 -= 4 ; VAR13 = FUN2 ( & VAR4 ) ; VAR4 ++ ; VAR9 = FUN3 ( & VAR4 ) ; if ( ! ( VAR9 & 0x80 ) ) { if ( VAR5 > VAR7 -> VAR14 [ VAR13 ] . VAR15 ) return -1 ; memcpy ( VAR7 -> VAR14 [ VAR13 ] . VAR16 + VAR7 -> VAR14 [ VAR13 ] . VAR17 , VAR4 , VAR5 ) ; VAR7 -> VAR14 [ VAR13 ] . VAR17 += VAR5 ; VAR7 -> VAR14 [ VAR13 ] . VAR15 -= VAR5 ; return 0 ; } if ( VAR5 <= 7 ) return -1 ; VAR5 -= 7 ; VAR10 = FUN4 ( & VAR4 ) - 2 * 2 ; VAR11 = FUN2 ( & VAR4 ) ; VAR12 = FUN2 ( & VAR4 ) ; if ( VAR2 -> VAR11 < VAR11 || VAR2 -> VAR12 < VAR12 ) { FUN5 ( VAR2 , VAR18 , ) ; return VAR19 ; } VAR7 -> VAR14 [ VAR13 ] . VAR20 = VAR11 ; VAR7 -> VAR14 [ VAR13 ] . VAR21 = VAR12 ; FUN6 ( & VAR7 -> VAR14 [ VAR13 ] . VAR16 , & VAR7 -> VAR14 [ VAR13 ] . VAR22 , VAR10 ) ; if ( ! VAR7 -> VAR14 [ VAR13 ] . VAR16 ) return -1 ; memcpy ( VAR7 -> VAR14 [ VAR13 ] . VAR16 , VAR4 , VAR5 ) ; VAR7 -> VAR14 [ VAR13 ] . VAR17 = VAR5 ; VAR7 -> VAR14 [ VAR13 ] . VAR15 = VAR10 - VAR5 ; return 0 ; } #0
261#261#static void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; const VAR3 * VAR9 = VAR4 + VAR5 ; int VAR10 , VAR11 ; VAR12 * VAR13 ; int VAR14 , VAR15 , VAR16 ; int VAR17 , VAR18 , VAR19 , VAR20 ; int VAR21 , VAR22 , VAR23 , VAR24 , VAR25 , VAR26 ; FUN2 ( VAR2 , , VAR4 [ VAR10 ] ) ; if ( VAR10 % 16 == 15 ) FUN2 ( VAR2 , ) ; VAR11 = * VAR4 ++ ; VAR4 += 1 ; VAR13 = FUN3 ( VAR7 , VAR11 ) ; if ( ! VAR13 ) { VAR13 = FUN4 ( sizeof ( VAR12 ) ) ; memcpy ( VAR13 , & VAR27 , sizeof ( VAR12 ) ) ; VAR13 -> VAR28 = VAR11 ; VAR13 -> VAR29 = VAR7 -> VAR30 ; VAR7 -> VAR30 = VAR13 ; } while ( VAR4 + 4 < VAR9 ) { VAR14 = * VAR4 ++ ; VAR15 = ( * VAR4 ) & 0xe0 ; if ( VAR15 == 0 ) { FUN5 ( VAR2 , VAR31 , , VAR14 , VAR21 , VAR22 , VAR23 , VAR20 ) ; if ( VAR15 & 0x80 ) VAR13 -> VAR32 [ VAR14 ] = FUN8 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; if ( VAR15 & 0x40 ) VAR13 -> VAR33 [ VAR14 ] = FUN8 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; if ( VAR15 & 0x20 ) VAR13 -> VAR34 [ VAR14 ] = FUN8 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; } } #1
262#262#int FUN1 ( const char * VAR1 , size_t VAR2 , const unsigned char * VAR3 , size_t VAR4 , uint64_t VAR5 , uint64_t VAR6 , uint64_t VAR7 , uint64_t VAR8 , unsigned char * VAR9 , size_t VAR10 ) { int VAR11 = 0 ; unsigned char * VAR12 ; VAR13 * VAR14 , * VAR15 , * VAR16 ; uint64_t VAR17 , VAR18 , VAR19 ; if ( VAR6 == 0 || VAR7 == 0 || VAR5 < 2 || ( VAR5 & ( VAR5 - 1 ) ) ) return 0 ; if ( VAR7 > VAR20 / VAR6 ) return 0 ; if ( 16 * VAR6 <= VAR21 ) { if ( VAR5 >= ( ( ( VAR22 ) 1 ) << ( 16 * VAR6 ) ) ) return 0 ; } VAR18 = VAR7 * 128 * VAR6 ; VAR17 = VAR23 / ( 32 * sizeof ( VAR13 ) ) ; if ( VAR5 + 2 > VAR17 / VAR6 ) return 0 ; VAR19 = 32 * VAR6 * ( VAR5 + 2 ) * sizeof ( VAR13 ) ; if ( VAR18 > VAR23 - VAR19 ) return 0 ; if ( VAR8 == 0 ) VAR8 = VAR24 ; if ( VAR8 > VAR25 ) VAR8 = VAR25 ; if ( VAR18 + VAR19 > VAR8 ) { FUN2 ( VAR26 , VAR27 ) ; return 0 ; } if ( VAR9 == NULL ) return 1 ; VAR12 = FUN3 ( VAR18 + VAR19 ) ; if ( VAR12 == NULL ) return 0 ; VAR14 = ( VAR13 * ) ( VAR12 + VAR18 ) ; VAR16 = VAR14 + 32 * VAR6 ; VAR15 = VAR16 + 32 * VAR6 ; if ( FUN4 ( VAR1 , VAR2 , VAR3 , VAR4 , 1 , FUN5 ( ) , VAR18 , VAR12 ) == 0 ) goto VAR28 ; for ( VAR17 = 0 ; VAR17 < VAR7 ; VAR17 ++ ) FUN6 ( VAR12 + 128 * VAR6 * VAR17 , VAR6 , VAR5 , VAR14 , VAR16 , VAR15 ) ; if ( FUN4 ( VAR1 , VAR2 , VAR12 , VAR18 , 1 , FUN5 ( ) , VAR10 , VAR9 ) == 0 ) goto VAR28 ; VAR11 = 1 ; VAR28 : FUN7 ( VAR12 , VAR18 + VAR19 ) ; return VAR11 ; } #1
263#263#static int FUN1 ( VAR1 * VAR2 , VAR1 * VAR3 [ 4 ] , const VAR4 * VAR5 ) { int VAR6 , VAR7 , VAR8 , VAR9 , VAR10 , VAR11 , VAR12 , VAR13 , VAR14 , VAR15 ; uint16_t VAR16 , VAR17 ; const VAR1 * VAR18 ; VAR1 * VAR19 , VAR20 ; VAR18 = FUN2 ( VAR2 , VAR21 ) ; if ( ! VAR18 ) return 0 ; VAR12 = VAR18 [ 1 ] & 0x3f ; VAR13 = ( VAR18 [ 4 ] >> 3 ) & 0x07 ; VAR14 = VAR18 [ 4 ] & 0x07 ; if ( VAR14 > 1 ) return -1 ; if ( VAR13 >= FUN3 ( VAR22 ) ) return VAR23 ; VAR6 = ( VAR5 -> VAR24 [ VAR13 ] + VAR12 ) * 4 ; VAR15 = VAR5 -> VAR25 / 2 ; VAR20 = ( VAR5 -> VAR26 == 720 && ! ( VAR2 [ 1 ] & 0x0C ) ) ? 2 : 0 ; for ( VAR7 = 0 ; VAR7 < VAR5 -> VAR27 ; VAR7 ++ ) { VAR19 = VAR3 [ VAR20 ++ ] ; if ( ! VAR19 ) break ; for ( VAR8 = 0 ; VAR8 < VAR5 -> VAR25 ; VAR8 ++ ) { VAR2 += 6 * 80 ; if ( VAR14 == 1 && VAR8 == VAR15 ) { VAR19 = VAR3 [ VAR20 ++ ] ; if ( ! VAR19 ) break ; } for ( VAR9 = 0 ; VAR9 < 9 ; VAR9 ++ ) { for ( VAR10 = 8 ; VAR10 < 80 ; VAR10 += 2 ) { if ( VAR14 == 0 ) { VAR11 = VAR5 -> VAR28 [ VAR8 ] [ VAR9 ] + ( VAR10 - 8 ) / 2 * VAR5 -> VAR29 ; if ( VAR11 * 2 >= VAR6 ) continue ; VAR19 [ VAR11 * 2 ] = VAR2 [ VAR10 + 1 ] ; VAR19 [ VAR11 * 2 + 1 ] = VAR2 [ VAR10 ] ; if ( VAR19 [ VAR11 * 2 + 1 ] == 0x80 && VAR19 [ VAR11 * 2 ] == 0x00 ) VAR19 [ VAR11 * 2 + 1 ] = 0 ; } else { VAR16 = ( ( VAR30 ) VAR2 [ VAR10 ] << 4 ) | ( ( VAR30 ) VAR2 [ VAR10 + 2 ] >> 4 ) ; VAR17 = ( ( VAR30 ) VAR2 [ VAR10 + 1 ] << 4 ) | ( ( VAR30 ) VAR2 [ VAR10 + 2 ] & 0x0f ) ; VAR16 = ( VAR16 == 0x800 ? 0 : FUN4 ( VAR16 ) ) ; VAR17 = ( VAR17 == 0x800 ? 0 : FUN4 ( VAR17 ) ) ; VAR11 = VAR5 -> VAR28 [ VAR8 % VAR15 ] [ VAR9 ] + ( VAR10 - 8 ) / 3 * VAR5 -> VAR29 ; if ( VAR11 * 2 >= VAR6 ) continue ; VAR19 [ VAR11 * 2 ] = VAR16 & 0xff ; VAR19 [ VAR11 * 2 + 1 ] = VAR16 >> 8 ; VAR11 = VAR5 -> VAR28 [ VAR8 % VAR15 + VAR15 ] [ VAR9 ] + ( VAR10 - 8 ) / 3 * VAR5 -> VAR29 ; VAR19 [ VAR11 * 2 ] = VAR17 & 0xff ; VAR19 [ VAR11 * 2 + 1 ] = VAR17 >> 8 ; ++ VAR10 ; } } VAR2 += 16 * 80 ; } } } return VAR6 ; } #0
264#264#void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , VAR3 * VAR6 , VAR3 * * VAR7 , FUN2 ( * VAR8 ) [ 4 ] , int VAR9 , int VAR10 , int VAR11 ) { VAR12 * const VAR13 = ( VAR12 * ) VAR2 ; VAR3 * VAR14 ; int VAR15 , VAR16 , VAR17 , VAR18 , VAR19 , VAR20 , VAR21 , VAR22 , VAR23 ; int VAR24 = 0 ; VAR15 = ( ( VAR10 & 1 ) << 1 ) | ( VAR9 & 1 ) ; VAR15 = 2 * VAR15 + VAR13 -> VAR25 ; VAR19 = VAR2 -> VAR26 * 16 + ( VAR9 >> 1 ) ; VAR20 = VAR2 -> VAR27 * 16 + ( VAR10 >> 1 ) ; VAR21 = VAR2 -> VAR21 ; VAR19 = FUN3 ( VAR19 , -16 , VAR2 -> VAR28 ) ; VAR20 = FUN3 ( VAR20 , -16 , VAR2 -> VAR29 ) ; if ( VAR19 <= -16 || VAR19 >= VAR2 -> VAR28 ) VAR15 &= ~ 3 ; if ( VAR20 <= -16 || VAR20 >= VAR2 -> VAR29 ) VAR15 &= ~ 4 ; VAR22 = VAR2 -> VAR22 ; VAR23 = VAR2 -> VAR23 ; VAR14 = VAR7 [ 0 ] + ( VAR20 * VAR22 ) + VAR19 ; if ( VAR19 < 1 || VAR20 < 1 || VAR19 + 17 >= VAR2 -> VAR30 || VAR20 + VAR11 + 1 >= VAR21 ) { VAR2 -> VAR31 . FUN4 ( VAR2 -> VAR32 , VAR14 - 1 - VAR2 -> VAR22 , VAR2 -> VAR22 , 19 , 19 , VAR19 - 1 , VAR20 - 1 , VAR2 -> VAR30 , VAR2 -> VAR21 ) ; VAR14 = VAR2 -> VAR32 + 1 + VAR2 -> VAR22 ; VAR24 = 1 ; } VAR2 -> VAR33 . VAR34 [ VAR15 ] ( VAR4 , VAR14 , VAR22 ) ; VAR2 -> VAR33 . VAR34 [ VAR15 ] ( VAR4 + 8 , VAR14 + 8 , VAR22 ) ; VAR2 -> VAR33 . VAR34 [ VAR15 ] ( VAR4 + 8 * VAR22 , VAR14 + 8 * VAR22 , VAR22 ) ; VAR2 -> VAR33 . VAR34 [ VAR15 ] ( VAR4 + 8 + 8 * VAR22 , VAR14 + 8 + 8 * VAR22 , VAR22 ) ; if ( VAR2 -> VAR35 & VAR36 ) return ; if ( VAR2 -> VAR37 == VAR38 ) { VAR15 = 0 ; if ( ( VAR9 & 3 ) != 0 ) VAR15 |= 1 ; if ( ( VAR10 & 3 ) != 0 ) VAR15 |= 2 ; VAR17 = VAR9 >> 2 ; VAR18 = VAR10 >> 2 ; } else { VAR17 = VAR9 / 2 ; VAR18 = VAR10 / 2 ; VAR15 = ( ( VAR18 & 1 ) << 1 ) | ( VAR17 & 1 ) ; VAR17 >>= 1 ; VAR18 >>= 1 ; } VAR19 = VAR2 -> VAR26 * 8 + VAR17 ; VAR20 = VAR2 -> VAR27 * 8 + VAR18 ; VAR19 = FUN3 ( VAR19 , -8 , VAR2 -> VAR28 >> 1 ) ; if ( VAR19 == ( VAR2 -> VAR28 >> 1 ) ) VAR15 &= ~ 1 ; VAR20 = FUN3 ( VAR20 , -8 , VAR2 -> VAR29 >> 1 ) ; if ( VAR20 == ( VAR2 -> VAR29 >> 1 ) ) VAR15 &= ~ 2 ; VAR16 = ( VAR20 * VAR23 ) + VAR19 ; VAR14 = VAR7 [ 1 ] + VAR16 ; if ( VAR24 ) { VAR2 -> VAR31 . FUN4 ( VAR2 -> VAR32 , VAR14 , VAR2 -> VAR23 , 9 , 9 , VAR19 , VAR20 , VAR2 -> VAR30 >> 1 , VAR2 -> VAR21 >> 1 ) ; VAR14 = VAR2 -> VAR32 ; } VAR8 [ 1 ] [ VAR15 ] ( VAR5 , VAR14 , VAR23 , VAR11 >> 1 ) ; VAR14 = VAR7 [ 2 ] + VAR16 ; if ( VAR24 ) { VAR2 -> VAR31 . FUN4 ( VAR2 -> VAR32 , VAR14 , VAR2 -> VAR23 , 9 , 9 , VAR19 , VAR20 , VAR2 -> VAR30 >> 1 , VAR2 -> VAR21 >> 1 ) ; VAR14 = VAR2 -> VAR32 ; } VAR8 [ 1 ] [ VAR15 ] ( VAR6 , VAR14 , VAR23 , VAR11 >> 1 ) ; } #1
265#265#"static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { #define PUL 8 #define PU 4 #define PUR 2 #define PL 1  int VAR6, VAR7; int VAR8 = VAR3;  int VAR9;   int VAR10, VAR11, VAR12, VAR13;   int VAR14, VAR15, VAR16, VAR17;   static const int VAR18[16][4] = { {  0,  0,  0,  0}, {  0,  0,  0,128},         {  0,  0,128,  0},         {  0,  0, 53, 75},         {  0,128,  0,  0},         {  0, 64,  0, 64},         {  0,128,  0,  0},         {  0,  0, 53, 75},         {128,  0,  0,  0},         {  0,  0,  0,128},         { 64,  0, 64,  0},         {  0,  0, 53, 75},         {  0,128,  0,  0},         {-104,116,  0,116},         { 24, 80, 24,  0},         {-104,116,  0,116}          };   static const unsigned char VAR19[8] = { 1,     0,     1,     1,     1,     2,     2,     1      }; int VAR20;   short VAR21[3];  int VAR22 = 0;  VAR11 = VAR12 = VAR13 = VAR10 = 0; VAR21[0] = VAR21[1] = VAR21[2] = 0;   for (VAR7 = 0; VAR7 < VAR5; VAR7++) {   for (VAR6 = 0; VAR6 < VAR4; VAR6++, VAR8++) {   if (VAR2->VAR23[VAR8].VAR24 != VAR25) {  VAR20 = VAR19[VAR2->VAR23[VAR8].VAR24];  VAR22= 0; if(VAR6){ VAR14= VAR8-1; VAR10 = FUN2(VAR14); if(FUN3(VAR14) && FUN4(VAR14)) VAR22 |= VAR26; } if(VAR7){ VAR16= VAR8-VAR4; VAR12 = FUN2(VAR16); if(FUN3(VAR16) && FUN4(VAR16)) VAR22 |= VAR27; if(VAR6){ VAR15= VAR8-VAR4-1; VAR11 = FUN2(VAR15); if(FUN3(VAR15) && FUN4(VAR15)) VAR22 |= VAR28; } if(VAR6 + 1 < VAR4){ VAR17= VAR8-VAR4+1; VAR13 = FUN2(VAR17); if(FUN3(VAR17) && FUN4(VAR17)) VAR22 |= VAR29; } }  if (VAR22 == 0) {   VAR9 = VAR21[VAR20]; } else {   VAR9 = (VAR18[VAR22][0] * VAR11) + (VAR18[VAR22][1] * VAR12) + (VAR18[VAR22][2] * VAR13) + (VAR18[VAR22][3] * VAR10);  VAR9 /= 128;   if ((VAR22 == 13) || (VAR22 == 15)) { if (FUN5(VAR9 - VAR12) > 128) VAR9 = VAR12; else if (FUN5(VAR9 - VAR10) > 128) VAR9 = VAR10; else if (FUN5(VAR9 - VAR11) > 128) VAR9 = VAR11; } }   if(VAR2->VAR30[VAR8].VAR31){ *VAR2->VAR32= VAR2->VAR30[VAR8]; VAR2->VAR30[VAR8].VAR31=0; VAR2->VAR30[VAR8].VAR33=0; VAR2->VAR30[VAR8].VAR34= VAR2->VAR32++; } VAR2->VAR30[VAR8].VAR33 += VAR9;  VAR21[VAR20] = FUN2(VAR8); if(FUN2(VAR8) && !(VAR2->VAR35[VAR8]&127)){ VAR2->VAR35[VAR8]= 129;  VAR2->VAR30[VAR8].VAR34= VAR2->VAR32; (VAR2->VAR32++)->VAR34=NULL; } } } } } "#1
266#266#"int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , VAR4 * VAR5 ) { int VAR6 , VAR7 ; int VAR8 = 0 ; VAR1 * VAR9 , * VAR10 ; FUN2 ( VAR3 ) ; VAR7 = VAR3 -> VAR11 ; if ( VAR7 <= 0 ) { VAR2 -> VAR11 = 0 ; VAR2 -> VAR12 = 0 ; return 1 ; } FUN3 ( VAR5 ) ; VAR10 = ( VAR3 != VAR2 ) ? VAR2 : FUN4 ( VAR5 ) ; VAR9 = FUN4 ( VAR5 ) ; if ( VAR10 == NULL || VAR9 == NULL ) goto VAR13 ; VAR6 = 2 * VAR7 ; if ( FUN5 ( VAR10 , VAR6 ) == NULL ) goto VAR13 ; if ( VAR7 == 4 ) { #ifndef BN_SQR_COMBA BN_ULONG VAR14 [ 8 ] ; FUN6 ( VAR10 -> VAR15 , VAR3 -> VAR15 , 4 , VAR14 ) ; #else FUN7 ( VAR10 -> VAR15 , VAR3 -> VAR15 ) ; #endif } else if ( VAR7 == 8 ) { #ifndef BN_SQR_COMBA BN_ULONG VAR14 [ 16 ] ; FUN6 ( VAR10 -> VAR15 , VAR3 -> VAR15 , 8 , VAR14 ) ; #else FUN8 ( VAR10 -> VAR15 , VAR3 -> VAR15 ) ; #endif } else { #if FUN9 ( VAR16 ) if ( VAR7 < VAR17 ) { BN_ULONG VAR14 [ VAR17 * 2 ] ; FUN6 ( VAR10 - > VAR15 , VAR3 - > VAR15 , VAR7 , VAR14 ) ; } else { int VAR18 , VAR19 ; VAR18 = FUN10 ( ( VAR20 ) VAR7 ) ; VAR18 = 1 << ( VAR18 - 1 ) ; VAR19 = VAR18 + VAR18 ; if ( VAR7 == VAR18 ) { if ( FUN5 ( VAR9 , VAR19 * 2 ) == NULL ) goto VAR13 ; FUN11 ( VAR10 -> VAR15 , VAR3 -> VAR15 , VAR7 , VAR9 -> VAR15 ) ; } else { if ( FUN5 ( VAR9 , VAR6 ) == NULL ) goto VAR13 ; FUN6 ( VAR10 -> VAR15 , VAR3 -> VAR15 , VAR7 , VAR9 -> VAR15 ) ; } } #else if (FUN5(VAR9, VAR6) == NULL) goto VAR13; FUN6(VAR10->VAR15, VAR3->VAR15, VAR7, VAR9->VAR15); #endif }  VAR10->VAR12 = 0; VAR10->VAR11 = VAR6; VAR10->VAR21 |= VAR22; if (VAR2 != VAR10 && FUN12(VAR2, VAR10) == NULL) goto VAR13;  VAR8 = 1; VAR13: FUN2(VAR10); FUN2(VAR9); FUN13(VAR5); return VAR8; } "#1
267#267#static inline int FUN1 ( VAR1 * VAR2 , int VAR3 ) { register int VAR4 ; FUN2 ( VAR5 , VAR2 ) ; FUN3 ( VAR3 > 0 && VAR3 <= 25 ) ; FUN4 ( VAR5 , VAR2 ) ; VAR4 = FUN5 ( VAR5 , VAR2 , VAR3 ) ; FUN6 ( VAR5 , VAR2 , VAR3 ) ; FUN7 ( VAR5 , VAR2 ) ; return VAR4 ; } #1
268#268#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; VAR9 * VAR10 = VAR3 ; VAR11 * VAR12 = VAR10 -> VAR12 ; VAR11 * VAR13 = VAR10 -> VAR13 ; int VAR14 ; for ( VAR14 = 0 ; VAR12 -> VAR15 [ VAR14 ] ; VAR14 ++ ) { int VAR16 = VAR14 == 1 || VAR14 == 2 ? VAR7 -> VAR16 : 0 ; int VAR17 = VAR14 == 1 || VAR14 == 2 ? VAR7 -> VAR17 : 0 ; int VAR18 = VAR7 -> VAR19 [ VAR14 ] ; int VAR20 = FUN2 ( VAR13 -> VAR21 , VAR17 ) ; int VAR22 = FUN2 ( VAR12 -> VAR23 , VAR16 ) ; int VAR24 = FUN2 ( VAR12 -> VAR21 , VAR17 ) ; int VAR25 = ( VAR24 * VAR4 ) / VAR5 ; int VAR26 = ( VAR24 * ( VAR4 + 1 ) ) / VAR5 ; VAR27 * VAR28 , * VAR29 ; int VAR30 , VAR31 ; int VAR32 , VAR33 ; VAR30 = VAR12 -> VAR34 [ VAR14 ] ; VAR28 = VAR12 -> VAR15 [ VAR14 ] + VAR25 * VAR30 ; VAR29 = VAR13 -> VAR15 [ VAR14 ] ; VAR31 = VAR13 -> VAR34 [ VAR14 ] ; if ( VAR7 -> VAR35 & 1 ) { VAR29 += VAR13 -> VAR34 [ VAR14 ] * ( VAR20 - 1 ) ; VAR31 *= -1 ; } if ( VAR7 -> VAR35 & 2 ) { VAR28 = VAR12 -> VAR15 [ VAR14 ] + VAR30 * ( VAR24 - VAR25 - 1 ) ; VAR30 *= -1 ; } for ( VAR33 = VAR25 ; VAR33 < VAR26 - 7 ; VAR33 += 8 ) { for ( VAR32 = 0 ; VAR32 < VAR22 - 7 ; VAR32 += 8 ) { VAR7 -> FUN3 ( VAR29 + VAR32 * VAR31 + VAR33 * VAR18 , VAR31 , VAR28 + ( VAR33 - VAR25 ) * VAR30 + VAR32 * VAR18 , VAR30 ) ; } if ( VAR22 - VAR32 > 0 && VAR26 - VAR33 > 0 ) VAR7 -> FUN4 ( VAR29 + VAR32 * VAR31 + VAR33 * VAR18 , VAR31 , VAR28 + ( VAR33 - VAR25 ) * VAR30 + VAR32 * VAR18 , VAR30 , VAR22 - VAR32 , VAR26 - VAR33 ) ; } if ( VAR26 - VAR33 > 0 ) VAR7 -> FUN4 ( VAR29 + 0 * VAR31 + VAR33 * VAR18 , VAR31 , VAR28 + ( VAR33 - VAR25 ) * VAR30 + 0 * VAR18 , VAR30 , VAR22 , VAR26 - VAR33 ) ; } return 0 ; } #1
269#269#"static int FUN1 ( int * VAR1 , int VAR2 , int * VAR3 , int VAR4 , int VAR5 , int * VAR6 ) { int VAR7 ; int * VAR8 = FUN2 ( VAR2 , sizeof ( * VAR8 ) ) ; if ( ! VAR8 ) return FUN3 ( VAR9 ) ; memcpy ( VAR8 , VAR1 , 4 * VAR2 ) ; for ( VAR7 = 0 ; VAR7 < VAR4 ; VAR7 ++ ) { int VAR10 = ( VAR7 + 1 ) * VAR5 , VAR11 , VAR12 ; double VAR13 = 0.0 , VAR14 = 0.0 ; #if 1 int * VAR15 = & ( VAR1 [ VAR10 ] ) ; int * VAR16 = & ( VAR8 [ 0 ] ) ; VAR12 = VAR2 - VAR10 ; for ( ; VAR12 > 0 ; VAR12 -- , VAR15 ++ , VAR16 ++ ) { double VAR17 = * VAR15 ; double VAR18 = * VAR16 ; VAR13 += VAR18 * VAR18 ; VAR14 += VAR17 * VAR18 ; } #else for (VAR12 = 0; VAR12 <= (VAR2 - VAR10); VAR12++); { double VAR19 = VAR1[VAR10+VAR12]; double VAR20 = VAR1[VAR12];   VAR13 += VAR20*VAR20; VAR14 += VAR19*VAR20; } #endif if (VAR13 == 0.0) VAR11 = 0; else VAR11 = (int)(FUN4(-VAR14/VAR13 * (double)VAR21 / (double)(VAR6[VAR7]) + 0.5));  if (VAR11 > (VAR21/VAR6[VAR7])) VAR11 = VAR21/VAR6[VAR7]; if (-VAR11 > (VAR21/VAR6[VAR7])) VAR11 = -(VAR21/VAR6[VAR7]);  VAR3[VAR7] = VAR11; VAR11 *= VAR6[VAR7];  #if 1 VAR15 = &(VAR1[VAR10]); VAR16 = &(VAR8[0]); VAR12 = VAR2 - VAR10; for (;VAR12>0;VAR12--,VAR15++,VAR16++) { int VAR17 = *VAR15; int VAR18 = *VAR16; *VAR15 = VAR17 + FUN5(VAR11*VAR18,VAR22); *VAR16 = VAR18 + FUN5(VAR11*VAR17, VAR22); } #else for (VAR12=0; VAR12 <= (VAR2 - VAR10); VAR12++) { int VAR19 = VAR1[VAR10+VAR12]; int VAR20=VAR8[VAR12]; VAR1[VAR10+VAR12] += FUN5(VAR11 * VAR20, VAR22); VAR8[VAR12] += FUN5(VAR11 * VAR19, VAR22); } #endif }  FUN6(VAR8); return 0; } "#0
270#270#"int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 ; FUN2 ( VAR2 -> VAR5 == 1 ) ; if ( VAR2 -> VAR6 > 65500 || VAR2 -> VAR7 > 65500 ) { FUN3 ( VAR2 , VAR8 , "" "" ) ; return FUN4 ( VAR9 ) ; } VAR4 = FUN5 ( sizeof ( VAR3 ) ) ; if ( ! VAR4 ) return FUN4 ( VAR10 ) ; VAR2 -> VAR11 = -1023 ; VAR2 -> VAR12 = 1023 ; FUN6 ( VAR4 -> VAR13 , VAR4 -> VAR14 , VAR15 , VAR16 ) ; FUN6 ( VAR4 -> VAR17 , VAR4 -> VAR18 , VAR19 , VAR16 ) ; FUN6 ( VAR4 -> VAR20 , VAR4 -> VAR21 , VAR22 , VAR23 ) ; FUN6 ( VAR4 -> VAR24 , VAR4 -> VAR25 , VAR26 , VAR27 ) ; FUN7 ( VAR4 -> VAR20 , VAR4 -> VAR28 ) ; FUN7 ( VAR4 -> VAR24 , VAR4 -> VAR29 ) ; VAR2 -> VAR30 = VAR2 -> VAR31 = VAR4 -> VAR28 ; VAR2 -> VAR32 = VAR2 -> VAR33 = VAR4 -> VAR29 ; VAR4 -> VAR34 = 0 ; VAR2 -> VAR35 = VAR4 ; if ( VAR2 -> VAR36 == VAR37 ) return FUN8 ( VAR2 ) ; return 0 ; } "#0
271#271#VAR1 * FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * VAR5 ; int VAR6 ; FUN2 ( VAR2 ) ; if ( VAR3 > VAR2 -> VAR7 ) { VAR4 * VAR8 = FUN3 ( VAR2 , VAR3 ) ; if ( ! VAR8 ) return NULL ; if ( VAR2 -> VAR9 ) FUN4 ( VAR2 -> VAR9 ) ; VAR2 -> VAR9 = VAR8 ; VAR2 -> VAR7 = VAR3 ; } if ( VAR2 -> VAR10 < VAR2 -> VAR7 ) { VAR5 = & ( VAR2 -> VAR9 [ VAR2 -> VAR10 ] ) ; for ( VAR6 = ( VAR2 -> VAR7 - VAR2 -> VAR10 ) >> 3 ; VAR6 > 0 ; VAR6 -- , VAR5 += 8 ) { VAR5 [ 0 ] = 0 ; VAR5 [ 1 ] = 0 ; VAR5 [ 2 ] = 0 ; VAR5 [ 3 ] = 0 ; VAR5 [ 4 ] = 0 ; VAR5 [ 5 ] = 0 ; VAR5 [ 6 ] = 0 ; VAR5 [ 7 ] = 0 ; } for ( VAR6 = ( VAR2 -> VAR7 - VAR2 -> VAR10 ) & 7 ; VAR6 > 0 ; VAR6 -- , VAR5 ++ ) VAR5 [ 0 ] = 0 ; assert ( VAR5 == & ( VAR2 -> VAR9 [ VAR2 -> VAR7 ] ) ) ; } FUN2 ( VAR2 ) ; return VAR2 ; } #1
272#272#"static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { if ( VAR3 > VAR2 -> VAR4 ) { FUN2 ( VAR2 -> VAR5 , VAR6 , "" "" ) ; return VAR7 ; } VAR2 -> VAR8 += VAR3 * VAR2 -> VAR9 ; VAR2 -> VAR4 -= VAR3 ; return 0 ; } "#0
273#273#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 ) { const VAR5 * VAR6 = VAR4 -> VAR6 ; int VAR7 = VAR4 -> VAR8 ; VAR9 * VAR10 = VAR2 -> VAR11 ; int * VAR12 = FUN2 ( VAR2 -> VAR13 . VAR14 + 1 , sizeof ( int ) ) ; int * VAR15 = FUN2 ( VAR2 -> VAR13 . VAR14 + 1 , sizeof ( int ) ) ; int64_t VAR16 ; int VAR17 , VAR18 = 0 ; int VAR19 , VAR20 , VAR21 = 0 ; if ( ! VAR12 || ! VAR15 ) { FUN3 ( VAR12 ) ; FUN3 ( VAR15 ) ; return FUN4 ( VAR22 ) ; } if ( VAR2 -> VAR13 . VAR23 + VAR2 -> VAR13 . VAR14 * VAR2 -> VAR24 . VAR25 -> VAR26 >= VAR2 -> VAR24 . VAR25 -> VAR26 * VAR2 -> VAR24 . VAR25 -> VAR27 ) { FUN5 ( VAR2 -> VAR28 , VAR29 , ) ; VAR21 = VAR30 ; goto VAR31 ; } VAR2 -> VAR13 . VAR8 [ VAR2 -> VAR13 . VAR14 - 1 ] = VAR7 - VAR16 ; VAR2 -> VAR13 . VAR16 [ VAR2 -> VAR13 . VAR14 - 1 ] = VAR16 ; } VAR2 -> VAR6 = VAR6 ; for ( VAR19 = 1 ; VAR19 < VAR2 -> VAR33 ; VAR19 ++ ) { VAR2 -> VAR32 [ VAR19 ] -> VAR11 -> VAR40 = 1 ; VAR2 -> VAR32 [ VAR19 ] -> VAR11 -> VAR41 = VAR2 -> VAR32 [ 0 ] -> VAR11 -> VAR41 ; memcpy ( VAR2 -> VAR32 [ VAR19 ] , VAR2 , sizeof ( VAR1 ) ) ; VAR2 -> VAR32 [ VAR19 ] -> VAR11 = VAR2 -> VAR34 [ VAR19 ] ; } FUN9 ( & VAR2 -> VAR42 , 0 ) ; FUN10 ( VAR2 -> VAR28 ) ; for ( VAR19 = 0 ; VAR19 <= VAR2 -> VAR13 . VAR14 ; VAR19 ++ ) { VAR15 [ VAR19 ] = VAR19 ; VAR12 [ VAR19 ] = 0 ; } if ( VAR2 -> VAR24 . VAR43 -> VAR44 ) VAR2 -> VAR28 -> FUN11 ( VAR2 -> VAR28 , VAR45 , VAR15 , VAR12 , VAR2 -> VAR13 . VAR14 + 1 ) ; for ( VAR19 = 0 ; VAR19 <= VAR2 -> VAR13 . VAR14 ; VAR19 ++ ) VAR21 += VAR12 [ VAR19 ] ; VAR31 : FUN3 ( VAR12 ) ; FUN3 ( VAR15 ) ; return VAR21 ; } #1
274#274#static void VAR1 FUN1 ( VAR2 * VAR3 , int VAR4 , int16_t VAR5 [ 4 ] , unsigned int VAR6 , VAR7 * VAR8 ) { const unsigned int VAR9 = VAR6 + VAR8 -> VAR10 ; const int VAR11 = VAR12 [ VAR9 ] ; const int VAR13 = VAR14 [ VAR6 + VAR8 -> VAR15 ] ; if ( VAR11 == 0 || VAR13 == 0 ) return ; if ( VAR5 [ 0 ] < 4 ) { int8_t VAR16 [ 4 ] ; VAR16 [ 0 ] = VAR17 [ VAR9 ] [ VAR5 [ 0 ] ] ; VAR16 [ 1 ] = VAR17 [ VAR9 ] [ VAR5 [ 1 ] ] ; VAR16 [ 2 ] = VAR17 [ VAR9 ] [ VAR5 [ 2 ] ] ; VAR16 [ 3 ] = VAR17 [ VAR9 ] [ VAR5 [ 3 ] ] ; VAR8 -> VAR18 . FUN2 ( VAR3 , VAR4 , VAR11 , VAR13 , VAR16 ) ; } else { VAR8 -> VAR18 . FUN3 ( VAR3 , VAR4 , VAR11 , VAR13 ) ; } } #1
275#275#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 ) { int VAR7 , VAR8 , VAR9 , VAR10 , VAR11 ; const int VAR12 = VAR13 [ VAR5 ] ; const VAR14 * VAR15 = VAR16 [ VAR5 ] ; int VAR17 , VAR18 ; unsigned VAR19 ; VAR7 = FUN2 ( VAR2 ) ; VAR8 = FUN2 ( VAR2 ) ; VAR9 = FUN3 ( VAR2 , 3 ) ; if ( VAR7 ) { VAR10 = FUN2 ( VAR2 ) ; VAR11 = FUN3 ( VAR2 , 3 ) ; for ( VAR17 = 0 ; VAR17 < VAR6 ; VAR17 ++ ) { VAR18 = -1 ; do { FUN4 ( VAR19 , VAR10 , VAR11 ) ; if ( VAR19 >= 0x10000 ) return VAR20 ; VAR18 += VAR19 + 1 ; if ( VAR18 >= VAR12 ) break ; FUN4 ( VAR19 , VAR8 , VAR9 ) ; VAR19 ++ ; if ( VAR19 >= 0x10000 ) return VAR20 ; VAR4 [ VAR15 [ VAR18 ] ] = VAR19 ; } while ( VAR18 < VAR12 - 1 ) ; VAR4 += VAR12 ; } } else { for ( VAR17 = 0 ; VAR17 < VAR6 ; VAR17 ++ ) { for ( VAR18 = 0 ; VAR18 < VAR12 ; VAR18 ++ ) { FUN4 ( VAR19 , VAR8 , VAR9 ) ; if ( VAR19 >= 0x10000 ) return VAR20 ; VAR4 [ VAR15 [ VAR18 ] ] = VAR19 ; } VAR4 += VAR12 ; } } return 0 ; } #0
276#276#static av_always_inline void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , VAR3 * VAR6 , int VAR7 , VAR3 * * VAR8 , FUN2 ( * VAR9 ) [ 4 ] , FUN3 ( * VAR10 ) [ 16 ] , int VAR11 ) { int VAR12 ; int VAR13 = VAR2 -> VAR13 ; FUN4 ( VAR2 , VAR8 , VAR7 ) ; if ( ! VAR11 && VAR2 -> VAR14 && VAR2 -> VAR15 != VAR16 ) { FUN5 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR8 , VAR9 ) ; return ; } switch ( VAR2 -> VAR17 ) { case VAR18 : if ( VAR2 -> VAR19 ) { if ( VAR2 -> VAR20 == 1 ) { FUN6 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR8 ) ; } else { FUN7 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR8 ) ; } } else if ( ! VAR11 && VAR2 -> VAR21 ) { FUN8 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , 0 , 0 , VAR8 , VAR9 , VAR10 , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 1 ] , 16 ) ; } else if ( ! VAR11 && ( VAR23 || VAR24 ) && VAR2 -> VAR25 && VAR2 -> VAR26 == VAR27 ) { FUN9 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 1 ] , 16 ) ; } else { FUN10 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 1 ] , 16 , VAR13 ) ; } break ; case VAR28 : if ( ! VAR11 ) FUN11 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR7 , VAR8 , VAR10 , VAR9 ) ; break ; case VAR29 : if ( VAR2 -> VAR30 == VAR31 ) { if ( ! VAR11 && VAR2 -> VAR21 ) { for ( VAR12 = 0 ; VAR12 < 2 ; VAR12 ++ ) FUN8 ( VAR2 , VAR4 , VAR5 , VAR6 , 1 , VAR12 , VAR2 -> VAR32 [ VAR7 ] [ VAR12 ] , VAR8 , VAR9 , VAR10 , VAR2 -> VAR22 [ VAR7 ] [ VAR12 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ VAR12 ] [ 1 ] , 8 ) ; } else { FUN12 ( VAR2 , VAR4 , VAR5 , VAR6 , 0 , VAR2 -> VAR32 [ VAR7 ] [ 0 ] , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 1 ] , 8 , VAR13 ) ; FUN12 ( VAR2 , VAR4 , VAR5 , VAR6 , 1 , VAR2 -> VAR32 [ VAR7 ] [ 1 ] , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 1 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 1 ] [ 1 ] , 8 , VAR13 ) ; } } else { if ( VAR2 -> VAR30 != VAR2 -> VAR32 [ VAR7 ] [ 0 ] + 1 && VAR2 -> VAR15 != VAR16 && ! VAR2 -> VAR33 ) { VAR8 = VAR2 -> VAR34 -> VAR35 -> VAR36 ; } FUN10 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR2 -> VAR32 [ VAR7 ] [ 0 ] , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 0 ] [ 1 ] , 16 , VAR13 >> 1 ) ; } break ; case VAR37 : for ( VAR12 = 0 ; VAR12 < 2 ; VAR12 ++ ) { VAR3 * * VAR38 ; if ( VAR2 -> VAR30 == VAR2 -> VAR32 [ VAR7 ] [ VAR12 ] + 1 || VAR2 -> VAR15 == VAR16 || VAR2 -> VAR33 ) { VAR38 = VAR8 ; } else { VAR38 = VAR2 -> VAR34 -> VAR35 -> VAR36 ; } FUN10 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR2 -> VAR32 [ VAR7 ] [ VAR12 ] , VAR38 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ VAR12 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ VAR12 ] [ 1 ] + 16 * VAR12 , 8 , VAR13 >> 1 ) ; VAR4 += 16 * VAR2 -> VAR39 ; VAR5 += ( 16 >> VAR2 -> VAR40 ) * VAR2 -> VAR41 ; VAR6 += ( 16 >> VAR2 -> VAR40 ) * VAR2 -> VAR41 ; } break ; case VAR42 : if ( VAR2 -> VAR30 == VAR31 ) { for ( VAR12 = 0 ; VAR12 < 2 ; VAR12 ++ ) { int VAR43 ; for ( VAR43 = 0 ; VAR43 < 2 ; VAR43 ++ ) FUN12 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR43 , VAR43 ^ VAR12 , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 2 * VAR12 + VAR43 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 2 * VAR12 + VAR43 ] [ 1 ] , 8 , VAR13 ) ; VAR9 = VAR2 -> VAR44 . VAR45 ; } } else { for ( VAR12 = 0 ; VAR12 < 2 ; VAR12 ++ ) { FUN10 ( VAR2 , VAR4 , VAR5 , VAR6 , VAR2 -> VAR30 != VAR12 + 1 , VAR8 , VAR9 , VAR2 -> VAR22 [ VAR7 ] [ 2 * VAR12 ] [ 0 ] , VAR2 -> VAR22 [ VAR7 ] [ 2 * VAR12 ] [ 1 ] , 16 , VAR13 >> 1 ) ; VAR9 = VAR2 -> VAR44 . VAR45 ; if ( ! VAR2 -> VAR33 ) { VAR8 = VAR2 -> VAR34 -> VAR35 -> VAR36 ; } } } break ; default : assert ( 0 ) ; } } #0
277#277#static av_cold int FUN1 ( VAR1 * VAR2 , enum ChannelPosition VAR3 , int VAR4 , int VAR5 , int * VAR6 ) { if ( * VAR6 >= VAR7 ) return VAR8 ; if ( VAR3 ) { if ( ! VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] ) { if ( ! ( VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] = FUN2 ( sizeof ( VAR10 ) ) ) ) return FUN3 ( VAR11 ) ; FUN4 ( VAR2 , & VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] -> VAR12 ) ; } if ( VAR4 != VAR13 ) { VAR2 -> VAR14 [ ( * VAR6 ) ++ ] = & VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] -> VAR15 [ 0 ] ; if ( VAR4 == VAR16 || ( VAR4 == VAR17 && VAR2 -> VAR18 [ 1 ] . VAR19 . VAR20 == 1 ) ) { VAR2 -> VAR14 [ ( * VAR6 ) ++ ] = & VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] -> VAR15 [ 1 ] ; } } } else { if ( VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] ) FUN5 ( & VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] -> VAR12 ) ; FUN6 ( & VAR2 -> VAR9 [ VAR4 ] [ VAR5 ] ) ; } return 0 ; } #1
278#278#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , VAR3 * * VAR6 , VAR7 * VAR8 , int VAR9 , int VAR10 ) { int VAR11 , VAR12 = 0 , VAR13 , VAR14 , VAR15 ; VAR3 * VAR16 ; VAR9 = FUN2 ( VAR9 ) ; VAR10 = FUN2 ( VAR10 ) ; VAR11 = ( ( VAR10 & 1 ) << 1 ) | ( VAR9 & 1 ) ; VAR9 >>= 1 ; VAR10 >>= 1 ; VAR13 = VAR2 -> VAR17 * 8 + VAR9 ; VAR14 = VAR2 -> VAR18 * 8 + VAR10 ; VAR13 = FUN3 ( VAR13 , -8 , ( VAR2 -> VAR19 >> 1 ) ) ; if ( VAR13 == ( VAR2 -> VAR19 >> 1 ) ) VAR11 &= ~ 1 ; VAR14 = FUN3 ( VAR14 , -8 , ( VAR2 -> VAR20 >> 1 ) ) ; if ( VAR14 == ( VAR2 -> VAR20 >> 1 ) ) VAR11 &= ~ 2 ; VAR15 = VAR14 * VAR2 -> VAR21 + VAR13 ; VAR16 = VAR6 [ 1 ] + VAR15 ; if ( VAR2 -> VAR22 & VAR23 ) { if ( ( unsigned ) VAR13 > FUN4 ( ( VAR2 -> VAR24 >> 1 ) - ( VAR11 & 1 ) - 8 , 0 ) || ( unsigned ) VAR14 > FUN4 ( ( VAR2 -> VAR25 >> 1 ) - ( VAR11 >> 1 ) - 8 , 0 ) ) { VAR2 -> VAR26 . FUN5 ( VAR2 -> VAR27 , VAR16 , VAR2 -> VAR21 , 9 , 9 , VAR13 , VAR14 , VAR2 -> VAR24 >> 1 , VAR2 -> VAR25 >> 1 ) ; VAR16 = VAR2 -> VAR27 ; VAR12 = 1 ; } } VAR8 [ VAR11 ] ( VAR4 , VAR16 , VAR2 -> VAR21 , 8 ) ; VAR16 = VAR6 [ 2 ] + VAR15 ; if ( VAR12 ) { VAR2 -> VAR26 . FUN5 ( VAR2 -> VAR27 , VAR16 , VAR2 -> VAR21 , 9 , 9 , VAR13 , VAR14 , VAR2 -> VAR24 >> 1 , VAR2 -> VAR25 >> 1 ) ; VAR16 = VAR2 -> VAR27 ; } VAR8 [ VAR11 ] ( VAR5 , VAR16 , VAR2 -> VAR21 , 8 ) ; } #1
279#279#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , int * VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR10 ; int VAR11 , VAR12 , VAR13 = -1 , VAR14 ; VAR15 * VAR16 ; VAR12 = FUN2 ( VAR2 -> VAR17 , VAR2 -> VAR18 , VAR2 -> VAR19 , 1 ) ; if ( ( VAR14 = FUN3 ( VAR4 , VAR12 + 45 ) ) < 0 ) { FUN4 ( VAR2 , VAR20 , , FUN6 ( VAR2 -> VAR17 ) ) ; return FUN7 ( VAR28 ) ; } VAR11 = VAR4 -> VAR21 [ 16 ] >> 3 ; VAR16 = VAR4 -> VAR21 + 18 ; #if FF_API_CODER_TYPE FF_DISABLE_DEPRECATION_WARNINGS if ( VAR2 -> VAR29 == VAR30 ) VAR9 -> VAR31 = 0 ; VAR32 #endif if ( VAR9 -> VAR31 ) VAR13 = FUN8 ( VAR16 , VAR12 , VAR6 , VAR11 , VAR2 -> VAR18 , VAR2 -> VAR19 ) ; if ( VAR13 >= 0 ) VAR4 -> VAR21 [ 2 ] |= 8 ; else VAR13 = FUN9 ( VAR16 , VAR6 , VAR11 , VAR2 -> VAR18 , VAR2 -> VAR19 ) ; VAR16 += VAR13 ; memcpy ( VAR16 , "" "" , 26 ) ; VAR4 -> VAR33 = VAR16 + 26 - VAR4 -> VAR21 ; VAR4 -> VAR34 |= VAR35 ; * VAR7 = 1 ; return 0 ; } "#0
280#280#"static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 ; apr_status_t VAR5 ; apr_size_t VAR6 ; unsigned char VAR7 [ VAR8 ] ; const char * VAR9 = VAR2 -> VAR10 ; FUN2 ( VAR11 , VAR12 , 0 , VAR13 , FUN3 ( 02334 ) "" "" , VAR9 ) ; if ( VAR9 ) { VAR5 = FUN4 ( & VAR4 , VAR9 , VAR14 | VAR15 | VAR16 , VAR17 , VAR2 -> VAR18 ) ; if ( FUN5 ( VAR5 ) ) { FUN6 ( VAR9 , VAR2 -> VAR18 ) ; VAR5 = FUN4 ( & VAR4 , VAR9 , VAR14 | VAR15 | VAR16 , VAR17 , VAR2 -> VAR18 ) ; } if ( VAR5 != VAR19 ) { return ; } if ( FUN7 ( VAR2 ) ) { FUN8 ( VAR2 ) ; } VAR6 = ( VAR2 -> VAR20 . VAR21 * VAR2 -> VAR20 . VAR22 ) + ( VAR2 -> VAR20 . VAR22 * sizeof ( char ) ) + VAR23 ; FUN9 ( VAR7 , VAR2 -> VAR24 , VAR6 ) ; VAR5 = FUN10 ( VAR4 , VAR2 -> VAR24 , VAR6 , NULL ) ; if ( VAR5 == VAR19 ) { VAR5 = FUN10 ( VAR4 , VAR7 , VAR8 , NULL ) ; } FUN11 ( VAR4 ) ; if ( VAR5 != VAR19 ) { FUN6 ( VAR9 , VAR2 -> VAR18 ) ; } } } "#1
281#281#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , VAR1 * VAR5 ) { int VAR6 , VAR7 , VAR8 , VAR9 , VAR10 , VAR11 ; VAR6 = VAR4 + ( VAR4 == VAR12 ) ; * VAR5 = ( VAR3 + ( VAR6 * 3 ) - 4 ) / ( 3 * VAR6 ) ; VAR7 = * VAR5 * 3 ; if ( VAR4 > VAR13 ) { VAR10 = 1 ; for ( VAR8 = 1 ; VAR8 <= VAR7 ; VAR8 ++ ) { VAR11 = VAR2 [ VAR10 ] ; assert ( VAR11 >= 0 && VAR11 <= 24 ) ; for ( VAR9 = 1 ; VAR9 < VAR6 ; VAR9 ++ ) { if ( VAR2 [ VAR10 + VAR9 ] < VAR11 ) VAR11 = VAR2 [ VAR10 + VAR9 ] ; } VAR2 [ VAR8 ] = VAR11 ; VAR10 += VAR6 ; } } if ( VAR2 [ 0 ] > 15 ) VAR2 [ 0 ] = 15 ; for ( VAR8 = 1 ; VAR8 <= VAR7 ; VAR8 ++ ) VAR2 [ VAR8 ] = FUN2 ( VAR2 [ VAR8 ] , VAR2 [ VAR8 - 1 ] + 2 ) ; for ( VAR8 = VAR7 - 1 ; VAR8 >= 0 ; VAR8 -- ) VAR2 [ VAR8 ] = FUN2 ( VAR2 [ VAR8 ] , VAR2 [ VAR8 + 1 ] + 2 ) ; if ( VAR4 > VAR13 ) { VAR10 = VAR7 * VAR6 ; for ( VAR8 = VAR7 ; VAR8 > 0 ; VAR8 -- ) { for ( VAR9 = 0 ; VAR9 < VAR6 ; VAR9 ++ ) VAR2 [ VAR10 - VAR9 ] = VAR2 [ VAR8 ] ; VAR10 -= VAR6 ; } } } #1
282#282#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , int VAR6 ) { VAR7 * VAR8 ; int VAR9 = 0 ; int VAR10 = 0 ; int VAR11 , VAR12 ; int VAR13 = VAR6 ; if ( VAR5 ) { if ( ( VAR12 = FUN2 ( VAR2 , VAR5 , VAR14 ) ) < 0 ) return VAR12 ; } for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR15 ; VAR11 ++ ) { if ( VAR2 -> VAR16 [ VAR11 ] -> VAR17 ) { ++ VAR9 ; } else if ( VAR2 -> VAR16 [ VAR11 ] -> VAR18 -> VAR19 != VAR20 && VAR2 -> VAR16 [ VAR11 ] -> VAR18 -> VAR21 != VAR22 && VAR2 -> VAR16 [ VAR11 ] -> VAR18 -> VAR21 != VAR23 ) { ++ VAR10 ; } } if ( VAR2 -> VAR24 -> VAR25 == VAR9 ) VAR6 = 1 ; if ( VAR2 -> VAR26 > 0 && VAR2 -> VAR24 -> VAR27 && ! VAR6 && VAR2 -> VAR24 -> VAR25 == VAR9 + VAR10 ) { VAR3 * VAR28 = & VAR2 -> VAR24 -> VAR27 -> VAR5 ; int64_t VAR29 = VAR30 ; int64_t VAR31 = FUN3 ( VAR28 -> VAR32 , VAR2 -> VAR16 [ VAR28 -> VAR33 ] -> VAR34 , VAR35 ) ; for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR15 ; VAR11 ++ ) { int64_t VAR36 ; const VAR7 * VAR37 = VAR2 -> VAR16 [ VAR11 ] -> VAR17 ; if ( ! VAR37 ) continue ; VAR36 = FUN3 ( VAR37 -> VAR5 . VAR32 , VAR2 -> VAR16 [ VAR11 ] -> VAR34 , VAR35 ) ; VAR29 = FUN4 ( VAR29 , VAR36 - VAR31 ) ; } if ( VAR29 > VAR2 -> VAR26 ) { FUN5 ( VAR2 , VAR38 , VAR39 , VAR29 , VAR2 -> VAR26 ) ; VAR6 = 1 ; } } if ( VAR2 -> VAR24 -> VAR27 && VAR13 && ( VAR2 -> VAR40 & VAR41 ) && VAR2 -> VAR24 -> VAR42 == VAR43 ) { VAR3 * VAR28 = & VAR2 -> VAR24 -> VAR27 -> VAR5 ; VAR2 -> VAR24 -> VAR42 = FUN3 ( VAR28 -> VAR32 , VAR2 -> VAR16 [ VAR28 -> VAR33 ] -> VAR34 , VAR35 ) ; } if ( VAR2 -> VAR24 -> VAR42 != VAR43 ) { while ( VAR2 -> VAR24 -> VAR27 ) { VAR3 * VAR28 = & VAR2 -> VAR24 -> VAR27 -> VAR5 ; VAR44 * VAR45 ; int64_t VAR31 = FUN3 ( VAR28 -> VAR32 , VAR2 -> VAR16 [ VAR28 -> VAR33 ] -> VAR34 , VAR35 ) ; if ( VAR2 -> VAR24 -> VAR42 + 1 >= VAR31 ) break ; VAR8 = VAR2 -> VAR24 -> VAR27 ; VAR45 = VAR2 -> VAR16 [ VAR8 -> VAR5 . VAR33 ] ; VAR2 -> VAR24 -> VAR27 = VAR8 -> VAR46 ; if ( ! VAR2 -> VAR24 -> VAR27 ) VAR2 -> VAR24 -> VAR47 = NULL ; if ( VAR45 -> VAR17 == VAR8 ) VAR45 -> VAR17 = NULL ; FUN6 ( & VAR8 -> VAR5 ) ; FUN7 ( & VAR8 ) ; VAR6 = 0 ; } } if ( VAR9 && VAR6 ) { VAR44 * VAR45 ; VAR8 = VAR2 -> VAR24 -> VAR27 ; * VAR4 = VAR8 -> VAR5 ; VAR45 = VAR2 -> VAR16 [ VAR4 -> VAR33 ] ; VAR2 -> VAR24 -> VAR27 = VAR8 -> VAR46 ; if ( ! VAR2 -> VAR24 -> VAR27 ) VAR2 -> VAR24 -> VAR47 = NULL ; if ( VAR45 -> VAR17 == VAR8 ) VAR45 -> VAR17 = NULL ; FUN7 ( & VAR8 ) ; return 1 ; } else { FUN8 ( VAR4 ) ; return 0 ; } } #1
283#283#VAR1 * FUN1 ( char * VAR2 ) { VAR1 * VAR3 = FUN2 ( sizeof ( * VAR3 ) ) ; if ( VAR3 != NULL ) VAR3 -> VAR2 = FUN3 ( VAR2 ) ; return VAR3 ; } #0
284#284#static av_cold int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 ; VAR7 * VAR8 = VAR2 -> VAR9 ; if ( VAR2 -> VAR10 != 46 ) { FUN2 ( VAR2 , VAR11 , , VAR8 -> VAR26 ) ; return -1 ; } VAR8 -> VAR27 = ! ! ( VAR4 & 0x40 ) ; VAR8 -> VAR28 = ( VAR4 >> 7 ) & 0xF ; VAR8 -> VAR29 = ! ! ( VAR4 & 0x2000 ) ; VAR8 -> VAR30 = ! ! ( VAR4 & 0x4000 ) ; VAR6 = VAR4 & 0x1000 ; if ( VAR6 ) { VAR8 -> VAR31 = 16 ; VAR8 -> VAR32 = 34 ; VAR8 -> VAR33 = 60 ; } else { VAR8 -> VAR31 = 10 ; VAR8 -> VAR32 = 24 ; VAR8 -> VAR33 = 48 ; } for ( VAR3 = 0 ; VAR3 < VAR8 -> VAR31 ; VAR3 ++ ) VAR8 -> VAR34 [ VAR3 ] = VAR35 * ( VAR3 + 1.0 ) / ( VAR8 -> VAR31 + 1.0 ) ; FUN8 ( & VAR8 -> VAR36 , VAR2 -> VAR12 + 22 , ( VAR2 -> VAR10 - 22 ) << 3 ) ; if ( FUN9 ( & VAR8 -> VAR36 , VAR8 -> VAR37 ) < 0 ) { FUN2 ( VAR2 , VAR11 , , VAR2 -> VAR39 , VAR47 , VAR48 ) ; return -1 ; } VAR8 -> VAR49 [ 0 ] = VAR8 -> VAR38 ; VAR8 -> VAR49 [ 1 ] = ( VAR5 * 25 ) >> 6 ; VAR8 -> VAR49 [ 2 ] = ( VAR5 * 44 ) >> 6 ; VAR8 -> VAR49 [ 3 ] = VAR8 -> VAR40 - 1 ; VAR8 -> VAR50 = ( VAR5 >> 3 ) & ~ 0xF ; VAR8 -> VAR51 = 1 + FUN4 ( VAR8 -> VAR50 ) ; VAR8 -> VAR52 = VAR8 -> VAR49 [ 2 ] + VAR8 -> VAR49 [ 3 ] + 1 + 2 * ( VAR8 -> VAR49 [ 1 ] - 2 * VAR8 -> VAR38 ) ; VAR8 -> VAR53 = FUN4 ( VAR8 -> VAR52 ) ; VAR2 -> VAR54 = VAR55 ; return 0 ; } #1
285#285#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { int VAR6 = 0 , VAR7 ; int VAR8 = 0 ; int VAR9 = 0 ; AVPacket VAR10 ; if ( ! VAR2 -> VAR11 ) { VAR2 -> VAR12 = VAR2 -> VAR13 -> VAR14 . VAR15 ? - VAR2 -> VAR16 -> VAR17 * VAR18 / FUN2 ( VAR2 -> VAR13 -> VAR14 ) : 0 ; VAR2 -> VAR19 = 0 ; if ( VAR4 && VAR4 -> VAR19 != VAR20 && ! VAR2 -> VAR21 ) { VAR2 -> VAR12 += FUN3 ( VAR4 -> VAR19 , VAR2 -> VAR13 -> VAR22 , VAR23 ) ; VAR2 -> VAR19 = VAR2 -> VAR12 ; } VAR2 -> VAR11 = 1 ; } if ( VAR2 -> VAR24 == VAR20 ) VAR2 -> VAR24 = VAR2 -> VAR12 ; if ( VAR2 -> VAR25 == VAR20 ) VAR2 -> VAR25 = VAR2 -> VAR19 ; if ( ! VAR4 ) { FUN4 ( & VAR10 ) ; VAR10 . VAR26 = NULL ; VAR10 . VAR27 = 0 ; } else { VAR10 = * VAR4 ; } if ( VAR4 && VAR4 -> VAR12 != VAR20 ) { VAR2 -> VAR24 = VAR2 -> VAR12 = FUN3 ( VAR4 -> VAR12 , VAR2 -> VAR13 -> VAR22 , VAR23 ) ; if ( VAR2 -> VAR16 -> VAR28 != VAR29 || ! VAR2 -> VAR21 ) VAR2 -> VAR25 = VAR2 -> VAR19 = VAR2 -> VAR12 ; } while ( VAR2 -> VAR21 ) { int VAR30 = 0 ; int VAR31 = 0 ; VAR2 -> VAR19 = VAR2 -> VAR25 ; VAR2 -> VAR12 = VAR2 -> VAR24 ; switch ( VAR2 -> VAR16 -> VAR28 ) { case VAR32 : VAR6 = FUN5 ( VAR2 , VAR8 ? NULL : & VAR10 , & VAR31 ) ; break ; case VAR29 : VAR6 = FUN6 ( VAR2 , VAR8 ? NULL : & VAR10 , & VAR31 , ! VAR4 ) ; if ( ! VAR8 || ! VAR4 || VAR31 ) { if ( VAR4 && VAR4 -> VAR30 ) { VAR30 = FUN3 ( VAR4 -> VAR30 , VAR2 -> VAR13 -> VAR22 , VAR23 ) ; } else if ( VAR2 -> VAR16 -> VAR33 . VAR15 != 0 && VAR2 -> VAR16 -> VAR33 . VAR34 != 0 ) { int VAR35 = FUN7 ( VAR2 -> VAR13 ) ? FUN7 ( VAR2 -> VAR13 ) -> VAR36 + 1 : VAR2 -> VAR16 -> VAR37 ; VAR30 = ( ( VAR38 ) VAR18 * VAR2 -> VAR16 -> VAR33 . VAR34 * VAR35 ) / VAR2 -> VAR16 -> VAR33 . VAR15 / VAR2 -> VAR16 -> VAR37 ; } if ( VAR2 -> VAR12 != VAR20 && VAR30 ) { VAR2 -> VAR24 += VAR30 ; } else VAR2 -> VAR24 = VAR20 ; } if ( VAR31 ) VAR2 -> VAR25 += VAR30 ; break ; case VAR39 : if ( VAR8 ) break ; VAR6 = FUN8 ( VAR2 , & VAR10 , & VAR31 ) ; if ( ! VAR4 && VAR6 >= 0 ) VAR6 = VAR40 ; break ; default : return -1 ; } if ( VAR6 == VAR40 ) { VAR9 = 1 ; break ; } if ( VAR6 < 0 ) { FUN9 ( NULL , VAR41 , ) ; FUN11 ( 1 ) ; } } if ( ! VAR2 -> VAR21 ) { VAR2 -> VAR12 = VAR2 -> VAR24 ; switch ( VAR2 -> VAR16 -> VAR28 ) { case VAR32 : VAR2 -> VAR24 += ( ( VAR38 ) VAR18 * VAR2 -> VAR16 -> VAR46 ) / VAR2 -> VAR16 -> VAR47 ; break ; case VAR29 : if ( VAR2 -> VAR33 . VAR15 ) { AVRational VAR48 = VAR23 ; int64_t VAR24 = FUN3 ( VAR2 -> VAR24 , VAR48 , FUN13 ( VAR2 -> VAR33 ) ) ; VAR2 -> VAR24 = FUN3 ( VAR24 + 1 , FUN13 ( VAR2 -> VAR33 ) , VAR48 ) ; } else if ( VAR4 -> VAR30 ) { VAR2 -> VAR24 += FUN3 ( VAR4 -> VAR30 , VAR2 -> VAR13 -> VAR22 , VAR23 ) ; } else if ( VAR2 -> VAR16 -> VAR33 . VAR15 != 0 ) { int VAR35 = FUN7 ( VAR2 -> VAR13 ) ? FUN7 ( VAR2 -> VAR13 ) -> VAR36 + 1 : VAR2 -> VAR16 -> VAR37 ; VAR2 -> VAR24 += ( ( VAR38 ) VAR18 * VAR2 -> VAR16 -> VAR33 . VAR34 * VAR35 ) / VAR2 -> VAR16 -> VAR33 . VAR15 / VAR2 -> VAR16 -> VAR37 ; } break ; } VAR2 -> VAR19 = VAR2 -> VAR12 ; VAR2 -> VAR25 = VAR2 -> VAR24 ; } for ( VAR7 = 0 ; VAR4 && VAR7 < VAR49 ; VAR7 ++ ) { VAR50 * VAR51 = VAR52 [ VAR7 ] ; if ( ! FUN14 ( VAR2 , VAR51 ) || VAR51 -> VAR53 ) continue ; FUN15 ( VAR2 , VAR51 , VAR4 ) ; } return ! VAR9 ; } #0
286#286#VAR1 * FUN1 ( OPENSSL_sk_compfunc VAR2 ) { VAR1 * VAR3 = FUN2 ( ) ; if ( VAR3 != NULL ) VAR3 -> VAR4 = VAR2 ; return VAR3 ; } #0
287#287#void FUN1 ( void * VAR1 , size_t VAR2 , size_t VAR3 , FUN2 ( * VAR4 ) ( const void * , const void * ) ) { VAR5 * VAR6 , * VAR7 , * VAR8 ; VAR8 = FUN3 ( VAR3 , VAR9 -> VAR10 ) ; if ( VAR8 == NULL ) { return ; } for ( VAR6 = ( VAR5 * ) VAR1 + VAR3 ; VAR6 < ( VAR5 * ) VAR1 + VAR2 * VAR3 ; VAR6 += VAR3 ) { FUN4 ( VAR8 , VAR6 , VAR3 ) ; for ( VAR7 = VAR6 ; VAR7 > ( VAR5 * ) VAR1 && FUN5 ( VAR7 - VAR3 , VAR8 ) > 0 ; VAR7 -= VAR3 ) { FUN4 ( VAR7 , VAR7 - VAR3 , VAR3 ) ; } FUN4 ( VAR7 , VAR8 , VAR3 ) ; } FUN6 ( VAR8 ) ; } #1
288#288#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { int VAR6 = VAR2 -> VAR7 [ 0 ] [ VAR5 ] . VAR3 ; int VAR8 = FUN2 ( VAR4 - VAR6 ) ; if ( VAR8 == 0 || VAR2 -> VAR7 [ 0 ] [ VAR5 ] . VAR9 -> VAR10 ) { return 256 ; } else { int VAR11 = FUN2 ( VAR3 - VAR6 ) ; int VAR12 = ( 16384 + ( FUN3 ( VAR8 ) >> 1 ) ) / VAR8 ; return FUN4 ( ( VAR11 * VAR12 + 32 ) >> 6 , 10 ) ; } } #1
289#289#"static int FUN1 ( VAR1 * VAR2 ) { char * VAR3 = NULL , * VAR4 = NULL , * VAR5 = NULL ; int VAR6 ; const char * VAR7 = "" "" ; const int VAR8 [ ] = { 257 , 0 } ; if ( ! FUN2 ( VAR2 , VAR7 , VAR8 , & VAR3 ) ) goto VAR9 ; for ( VAR6 = 0 ; VAR3 [ VAR6 ] ; ++ VAR6 ) { if ( VAR3 [ VAR6 ] == ' ' ) { if ( ! VAR4 ) { VAR4 = VAR3 + VAR6 + 1 ; continue ; } VAR5 = VAR3 + VAR6 ; break ; } } if ( ! VAR5 ) goto VAR9 ; if ( VAR5 > VAR3 && VAR5 [ -1 ] == ' ' ) { VAR5 [ -1 ] = ' ' ; } else * VAR5 = ' ' ; FUN3 ( VAR2 -> VAR10 , VAR4 , sizeof ( VAR2 -> VAR10 ) ) ; FUN4 ( VAR3 ) ; return 0 ; VAR9 : FUN4 ( VAR3 ) ; return FUN5 ( VAR11 ) ; } "#1
290#290#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , const VAR7 * VAR8 , int32_t VAR9 , int32_t VAR10 ) { Cell VAR11 ; uint32_t VAR12 ; VAR12 = FUN2 ( & VAR8 ) ; if ( VAR12 >= VAR9 / 2 ) return VAR13 ; VAR2 -> VAR14 = VAR12 ? VAR8 : 0 ; VAR8 += VAR12 * 2 ; VAR9 -= VAR12 * 2 ; FUN3 ( & VAR2 -> VAR15 , VAR8 , VAR9 << 3 ) ; VAR2 -> VAR16 = 0 ; VAR2 -> VAR17 = 0 ; VAR2 -> VAR18 = VAR8 + VAR9 - 1 ; VAR11 . VAR19 = VAR11 . VAR20 = 0 ; VAR11 . VAR21 = VAR6 -> VAR21 >> 2 ; VAR11 . VAR22 = VAR6 -> VAR22 >> 2 ; VAR11 . VAR23 = 0 ; VAR11 . VAR24 = 0 ; return FUN4 ( VAR2 , VAR4 , VAR6 , VAR25 , & VAR11 , VAR26 , VAR10 ) ; } #0
291#291#static int FUN1 ( VAR1 * * VAR2 , int VAR3 ) { VAR4 * VAR5 ; int VAR6 ; unsigned VAR7 = VAR3 ? VAR3 : 1024 ; if ( sizeof ( VAR4 ) + VAR7 < VAR7 ) return -1 ; VAR5 = FUN2 ( sizeof ( VAR4 ) + VAR7 ) ; if ( ! VAR5 ) return FUN3 ( VAR8 ) ; * VAR2 = FUN2 ( sizeof ( VAR1 ) ) ; if ( ! * VAR2 ) { FUN4 ( VAR5 ) ; return FUN3 ( VAR8 ) ; } VAR5 -> VAR7 = VAR7 ; VAR6 = FUN5 ( * VAR2 , VAR5 -> VAR9 , VAR7 , 1 , VAR5 , NULL , VAR3 ? VAR10 : VAR11 , VAR3 ? NULL : VAR12 ) ; if ( VAR6 == 0 ) { ( * VAR2 ) -> VAR3 = VAR3 ; } else { FUN4 ( VAR5 ) ; FUN6 ( VAR2 ) ; } return VAR6 ; } #1
292#292#static int FUN1 ( VAR1 * VAR2 ) { const unsigned char * VAR3 = VAR2 -> VAR4 ; int VAR5 , VAR6 , VAR7 = 0 ; if ( FUN2 ( VAR3 ) == 0xEFBBBF ) VAR3 += 3 ; while ( * VAR3 == ' ' || * VAR3 == ' ' ) VAR3 ++ ; for ( VAR5 = 0 ; VAR5 < 2 ; VAR5 ++ ) { if ( ( VAR7 == VAR5 || VAR7 + 1 == VAR5 ) && sscanf ( VAR3 , ) + 1 ; } return 0 ; } #1
293#293#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; if ( VAR4 -> VAR8 >= 24 ) VAR6 -> VAR9 += FUN2 ( VAR4 -> VAR10 + 20 ) ; FUN3 ( VAR2 -> VAR11 , VAR4 -> VAR10 , VAR4 -> VAR8 ) ; return 0 ; } #0
294#294#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , unsigned char * VAR5 ) { unsigned char VAR6 [ 128 ] ; int VAR7 ; gost_hash_ctx VAR8 ; VAR9 * VAR10 = FUN2 ( ) ; memset ( VAR6 , 0 , 128 ) ; VAR10 -> VAR11 = FUN3 ( VAR4 -> VAR12 . VAR13 -> VAR11 ) ; VAR10 -> VAR14 = FUN3 ( VAR4 -> VAR12 . VAR13 -> VAR14 ) ; VAR10 -> VAR2 = FUN3 ( VAR2 ) ; VAR7 = FUN4 ( VAR6 , ( ( VAR15 * ) ( FUN5 ( VAR4 ) ) ) -> VAR16 , VAR10 ) ; FUN6 ( VAR10 ) ; if ( ! VAR7 ) return 0 ; FUN7 ( & VAR8 , & VAR17 ) ; FUN8 ( & VAR8 ) ; FUN9 ( & VAR8 , VAR6 , 128 ) ; FUN10 ( & VAR8 , VAR5 ) ; FUN11 ( & VAR8 ) ; return 1 ; } #1
295#295#"VAR1 * FUN1 ( VAR2 * VAR3 ) { int VAR4 ; VAR5 * VAR6 ; VAR1 * VAR7 = FUN2 ( VAR3 ) ; VAR6 = FUN3 ( VAR7 -> VAR8 , VAR7 -> VAR9 -> VAR10 ) ; FUN4 ( VAR7 , VAR3 ) ; if ( ! FUN5 ( VAR7 , VAR6 ) || ! FUN6 ( VAR7 ) ) { FUN7 ( VAR6 ) ; switch ( VAR7 -> VAR11 ) { case VAR12 : case VAR13 : case VAR14 : case VAR15 : if ( VAR7 -> VAR11 == VAR12 ) { FUN8 ( VAR16 , VAR17 , 0 , VAR7 , FUN9 ( 00565 ) ) ; } VAR4 = VAR7 -> VAR11 ; goto VAR22 ; case VAR23 : FUN10 ( VAR3 -> VAR24 , VAR25 , NULL ) ; if ( ! VAR7 -> VAR9 -> VAR26 ) FUN11 ( VAR7 ) ; break ; } VAR3 -> VAR27 = VAR28 ; FUN12 ( VAR7 -> VAR8 ) ; goto VAR29 ; } FUN7 ( VAR6 ) ; FUN13 ( VAR7 ) ; if ( ! VAR7 -> VAR30 ) { const char * VAR31 ; FUN14 ( VAR7 , VAR6 ) ; FUN7 ( VAR6 ) ; if ( VAR7 -> VAR11 != VAR32 ) { FUN8 ( VAR16 , VAR21 , 0 , VAR7 , FUN9 ( 00567 ) ) ; if ( VAR31 ) { if ( ! FUN16 ( VAR7 -> VAR8 , VAR31 ) ) { FUN8 ( VAR16 , VAR21 , 0 , VAR7 , FUN9 ( 02539 ) , VAR31 , VAR7 -> VAR34 ) ; VAR4 = VAR13 ; goto VAR22 ; } FUN17 ( VAR7 -> VAR33 , "" "" ) ; } } FUN18 ( VAR35 , NULL , VAR7 , VAR7 -> VAR9 ) ; if ( ! FUN19 ( VAR7 ) ) { FUN13 ( VAR7 ) ; VAR4 = VAR7 -> VAR11 ; goto VAR36 ; } FUN13 ( VAR7 ) ; if ( ( VAR4 = FUN20 ( VAR7 ) ) ) { goto VAR37 ; } FUN21 ( ( VAR38 ) VAR7 , ( char * ) VAR7 -> VAR20 , ( char * ) VAR7 -> VAR34 , ( char * ) VAR7 -> VAR18 -> VAR39 , VAR7 -> VAR11 ) ; return VAR7 ; VAR22 : { VAR40 * VAR41 = VAR3 -> VAR42 ; while ( VAR41 ) { FUN22 ( VAR41 , VAR6 , NULL ) ; FUN7 ( VAR6 ) ; if ( VAR41 -> VAR43 == VAR44 ) { break ; } FUN23 ( VAR41 ) ; VAR41 = VAR41 -> VAR45 ; } VAR3 -> VAR42 = VAR7 -> VAR42 = VAR41 ; VAR3 -> VAR27 = VAR28 ; } VAR36 : VAR7 -> VAR11 = VAR32 ; VAR37 : FUN24 ( VAR4 , VAR7 ) ; { VAR5 * VAR46 ; VAR46 = FUN25 ( VAR3 ) ; FUN26 ( VAR46 , FUN27 ( VAR3 -> VAR10 , VAR7 ) ) ; FUN28 ( VAR3 -> VAR47 , VAR46 ) ; FUN29 ( VAR3 , VAR46 ) ; } VAR29 : VAR7 = NULL ; FUN30 ( ( VAR38 ) VAR7 ) ; return NULL ; } "#0
296#296#int FUN1 ( VAR1 * VAR2 , const char * VAR3 , int VAR4 ) { unsigned char VAR5 [ VAR6 ] ; unsigned int VAR7 ; const VAR8 * VAR9 ; if ( VAR2 -> VAR5 == NULL ) { FUN2 ( VAR10 , VAR11 ) ; return 0 ; } if ( ! FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 , & VAR7 , VAR12 ) ) { FUN2 ( VAR10 , VAR13 ) ; return 0 ; } FUN4 ( VAR2 -> VAR5 -> VAR14 , NULL , & VAR9 ) ; if ( VAR7 != ( unsigned int ) FUN5 ( VAR9 ) ) return 0 ; if ( FUN6 ( VAR5 , FUN7 ( VAR9 ) , VAR7 ) != 0 ) { if ( VAR3 == NULL ) return 0 ; if ( ! FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 , & VAR7 , VAR15 ) ) { FUN2 ( VAR10 , VAR13 ) ; return 0 ; } if ( ( VAR7 != ( unsigned int ) FUN5 ( VAR9 ) ) || FUN6 ( VAR5 , FUN7 ( VAR9 ) , VAR7 ) != 0 ) return 0 ; else VAR16 = VAR15 ; } return 1 ; } #0
297#297#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; int64_t VAR9 , VAR10 ; uint8_t VAR11 [ VAR12 ] ; int VAR13 ; if ( VAR7 -> VAR14 == VAR15 ) VAR10 = VAR4 / 264 * 41 / 506 * 512 ; else VAR10 = VAR4 / 240 * VAR7 -> VAR16 / 506 * 512 ; if ( VAR10 < 0 ) VAR10 = 0 ; VAR10 += VAR7 -> VAR17 ; VAR9 = FUN2 ( VAR2 -> VAR18 , VAR10 , VAR19 ) ; if ( VAR9 < 0 ) return VAR9 ; FUN3 ( VAR2 -> VAR18 , VAR11 , VAR12 ) ; VAR7 -> VAR20 = ! ! ( VAR11 [ 0 ] & 0x80 ) ; VAR13 = 2 * VAR11 [ 1 ] + 2 * VAR7 -> VAR20 ; if ( VAR13 < VAR12 ) return VAR21 ; if ( VAR13 == VAR12 ) { VAR7 -> VAR22 = 0 ; VAR13 = FUN4 ( VAR2 -> VAR18 , - VAR12 ) ; } else { VAR7 -> VAR22 = VAR23 - VAR13 ; VAR13 = FUN4 ( VAR2 -> VAR18 , VAR13 - VAR12 ) ; } VAR7 -> VAR24 = -1 ; return 0 ; } #1
298#298#"int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 ) { unsigned char * VAR4 ; if ( VAR3 == NULL || VAR3 -> VAR5 == NULL ) { FUN2 ( VAR6 , VAR7 ) ; return 0 ; } if ( VAR3 -> VAR5 -> VAR8 == NULL ) goto VAR9 ; if ( VAR3 -> VAR5 -> VAR10 == NULL ) { FUN2 ( VAR6 , VAR11 ) ; return 0 ; } FUN3 ( VAR2 ) ; if ( VAR2 -> VAR12 != NULL ) FUN4 ( VAR2 -> VAR12 ) ; * VAR2 = * VAR3 ; VAR2 -> VAR13 = NULL ; VAR2 -> VAR14 = NULL ; if ( VAR3 -> VAR12 != NULL ) FUN5 ( VAR3 -> VAR12 ) ; VAR2 -> VAR14 = VAR3 -> VAR5 -> FUN6 ( VAR3 -> VAR14 ) ; if ( VAR2 -> VAR14 == NULL ) { FUN2 ( VAR6 , VAR11 ) ; return 0 ; } FUN7 ( VAR2 , VAR15 ) ; #ifndef FIPS_MODE if ( VAR3 -> VAR13 != NULL ) { VAR2 -> VAR13 = FUN8 ( VAR3 -> VAR13 ) ; if ( VAR2 -> VAR13 == NULL ) { FUN2 ( VAR6 , VAR11 ) ; FUN3 ( VAR2 ) ; return 0 ; } } #endif return 1 ; VAR9 : #if ! FUN9 ( VAR16 ) && ! FUN9 ( VAR17 ) if ( VAR3 -> VAR18 && ! FUN10 ( VAR3 -> VAR18 ) ) { FUN2 ( VAR6 , VAR19 ) ; return 0 ; } #endif if (VAR2->VAR5 == VAR3->VAR5) { VAR4 = VAR2->VAR20; FUN11(VAR2, VAR21); } else VAR4 = NULL; FUN3(VAR2); memcpy(VAR2, VAR3, sizeof(*VAR2));   FUN7(VAR2, VAR15);   VAR2->VAR20 = NULL; VAR2->VAR13 = NULL;  if (VAR3->VAR20 && VAR2->VAR5->VAR22) { if (VAR4) VAR2->VAR20 = VAR4; else { VAR2->VAR20 = FUN12(VAR2->VAR5->VAR22); if (VAR2->VAR20 == NULL) { FUN2(VAR6, VAR23); return 0; } } memcpy(VAR2->VAR20, VAR3->VAR20, VAR2->VAR5->VAR22); }  VAR2->update = VAR3->update;  #ifndef FIPS_MODE  if (VAR3->VAR13) { VAR2->VAR13 = FUN8(VAR3->VAR13); if (!VAR2->VAR13) { FUN3(VAR2); return 0; } } #endif  if (VAR2->VAR5->copy) return VAR2->VAR5->copy(VAR2, VAR3);  return 1; } "#1
299#299#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = FUN2 ( sizeof ( * VAR8 ) , VAR5 ) ; int * VAR9 = FUN2 ( sizeof ( * VAR9 ) * 2 , VAR5 ) ; VAR1 * VAR10 = FUN2 ( sizeof ( * VAR10 ) * 2 , VAR5 ) ; VAR11 * VAR12 = FUN2 ( sizeof ( * VAR12 ) , VAR5 ) ; int VAR13 , VAR14 , VAR15 ; int VAR16 = 0 ; int VAR17 = 0 ; if ( ! VAR8 || ! VAR9 || ! VAR10 ) { VAR17 = FUN3 ( VAR18 ) ; goto VAR19 ; } for ( VAR14 = 0 ; VAR14 < VAR5 ; VAR14 ++ ) { VAR2 [ VAR14 ] = 255 ; if ( VAR4 [ VAR14 ] || ! VAR6 ) VAR12 [ VAR16 ++ ] = VAR14 ; } for ( VAR13 = 1 ; ; VAR13 <<= 1 ) { for ( VAR14 = 0 ; VAR14 < VAR16 ; VAR14 ++ ) { VAR8 [ VAR14 ] . VAR20 = VAR14 ; VAR8 [ VAR14 ] . VAR21 = ( VAR4 [ VAR12 [ VAR14 ] ] << 14 ) + VAR13 ; } for ( VAR14 = VAR16 / 2 - 1 ; VAR14 >= 0 ; VAR14 -- ) FUN4 ( VAR8 , VAR14 , VAR16 ) ; for ( VAR15 = VAR16 ; VAR15 < VAR16 * 2 - 1 ; VAR15 ++ ) { uint64_t VAR22 = VAR8 [ 0 ] . VAR21 ; VAR9 [ VAR8 [ 0 ] . VAR20 ] = VAR15 ; VAR8 [ 0 ] . VAR21 = VAR23 ; FUN4 ( VAR8 , 0 , VAR16 ) ; VAR9 [ VAR8 [ 0 ] . VAR20 ] = VAR15 ; VAR8 [ 0 ] . VAR20 = VAR15 ; VAR8 [ 0 ] . VAR21 += VAR22 ; FUN4 ( VAR8 , 0 , VAR16 ) ; } VAR10 [ 2 * VAR16 - 2 ] = 0 ; for ( VAR14 = 2 * VAR16 - 3 ; VAR14 >= VAR16 ; VAR14 -- ) VAR10 [ VAR14 ] = VAR10 [ VAR9 [ VAR14 ] ] + 1 ; for ( VAR14 = 0 ; VAR14 < VAR16 ; VAR14 ++ ) { VAR2 [ VAR12 [ VAR14 ] ] = VAR10 [ VAR9 [ VAR14 ] ] + 1 ; if ( VAR2 [ VAR12 [ VAR14 ] ] >= 32 ) break ; } if ( VAR14 == VAR16 ) break ; } VAR19 : FUN5 ( VAR8 ) ; FUN5 ( VAR9 ) ; FUN5 ( VAR10 ) ; FUN5 ( VAR12 ) ; return VAR17 ; } #1
300#300#"static void FUN1 ( void ) { char VAR1 [ 16384 ] ; int VAR2 ; VAR3 * * VAR4 = FUN2 ( sizeof ( * VAR4 ) * VAR5 ) ; if ( ! VAR4 ) FUN3 ( 1 ) ; for ( VAR2 = 0 ; VAR2 < VAR5 ; VAR2 ++ ) VAR4 [ VAR2 ] = VAR6 [ VAR2 ] -> VAR7 ; FUN4 ( VAR4 , VAR5 , VAR1 , sizeof ( VAR1 ) ) ; FUN5 ( "" "" , VAR1 ) ; FUN6 ( VAR8 ) ; FUN7 ( & VAR4 ) ; } "#1
301#301#long FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { long VAR5 , VAR6 , VAR7 , VAR8 , VAR9 , VAR10 = 0 ; char * VAR11 , * * VAR12 , * VAR13 ; VAR14 * VAR15 = NULL ; long VAR16 = -1 ; if ( ( VAR15 = FUN2 ( ) ) == NULL ) goto VAR17 ; VAR7 = FUN3 ( VAR4 -> VAR18 ) ; VAR8 = VAR4 -> VAR19 ; for ( VAR5 = 0 ; VAR5 < VAR7 ; VAR5 ++ ) { VAR12 = FUN4 ( VAR4 -> VAR18 , VAR5 ) ; VAR9 = 0 ; for ( VAR6 = 0 ; VAR6 < VAR8 ; VAR6 ++ ) { if ( VAR12 [ VAR6 ] != NULL ) VAR9 += strlen ( VAR12 [ VAR6 ] ) ; } if ( ! FUN5 ( VAR15 , ( int ) ( VAR9 * 2 + VAR8 ) ) ) goto VAR17 ; VAR11 = VAR15 -> VAR18 ; for ( VAR6 = 0 ; VAR6 < VAR8 ; VAR6 ++ ) { VAR13 = VAR12 [ VAR6 ] ; if ( VAR13 != NULL ) for ( ; ; ) { if ( * VAR13 == ' ' ) break ; if ( * VAR13 == ' ' ) * ( VAR11 ++ ) = ' ' ; * ( VAR11 ++ ) = * ( VAR13 ++ ) ; } * ( VAR11 ++ ) = ' ' ; } VAR11 [ -1 ] = ' ' ; VAR6 = VAR11 - VAR15 -> VAR18 ; if ( FUN6 ( VAR2 , VAR15 -> VAR18 , ( int ) VAR6 ) != VAR6 ) goto VAR17 ; VAR10 += VAR6 ; } VAR16 = VAR10 ; VAR17 : FUN7 ( VAR15 ) ; return VAR16 ; } #1
302#302#static void FUN1 ( VAR1 * VAR2 , int VAR3 , uint8_t VAR4 , uint8_t VAR5 , VAR6 * * VAR7 ) { int VAR8 , VAR9 , VAR10 ; char VAR11 [ 5 ] ; int64_t VAR12 , VAR13 = FUN2 ( VAR2 -> VAR14 ) + VAR3 ; int VAR15 ; const char * VAR16 = NULL ; AVIOContext VAR14 ; VAR17 * VAR18 ; unsigned char * VAR19 = NULL ; int VAR20 = 0 ; void ( * VAR21 ) ( VAR1 * , VAR17 * , int , char * , VAR6 * * ) = NULL ; switch ( VAR4 ) { case 2 : if ( VAR5 & 0x40 ) { VAR16 = ; goto VAR22 ; } VAR10 = VAR5 & 0x80 ; if ( VAR8 && VAR5 & 0x40 ) FUN3 ( VAR2 -> VAR14 , FUN4 ( VAR2 -> VAR14 , 4 ) ) ; while ( VAR3 >= VAR15 ) { unsigned int VAR23 = 0 ; int VAR24 = 0 ; if ( VAR8 ) { FUN5 ( VAR2 -> VAR14 , VAR11 , 4 ) ; VAR11 [ 4 ] = 0 ; if ( VAR4 == 3 ) { VAR9 = FUN6 ( VAR2 -> VAR14 ) ; } else VAR9 = FUN4 ( VAR2 -> VAR14 , 4 ) ; VAR23 = FUN7 ( VAR2 -> VAR14 ) ; VAR24 = VAR23 & VAR25 ; } else { FUN5 ( VAR2 -> VAR14 , VAR11 , 3 ) ; VAR11 [ 3 ] = 0 ; VAR9 = FUN8 ( VAR2 -> VAR14 ) ; } if ( VAR9 < 0 || VAR9 > VAR3 - VAR15 ) { FUN9 ( VAR2 , VAR26 , , VAR11 ) ; continue ; } if ( VAR23 & VAR28 ) { FUN6 ( VAR2 -> VAR14 ) ; VAR9 -= 4 ; } if ( VAR23 & ( VAR29 | VAR30 ) ) { FUN9 ( VAR2 , VAR26 , , VAR9 ) ; goto VAR34 ; } for ( VAR31 = 0 , VAR32 = 0 ; VAR31 < VAR9 ; VAR31 ++ , VAR32 ++ ) { VAR19 [ VAR32 ] = FUN12 ( VAR2 -> VAR14 ) ; if ( VAR32 > 0 && ! VAR19 [ VAR32 ] && VAR19 [ VAR32 - 1 ] == 0xff ) { VAR32 -- ; } } FUN13 ( & VAR14 , VAR19 , VAR32 , 0 , NULL , NULL , NULL , NULL ) ; VAR9 = VAR32 ; VAR18 = & VAR14 ; } else { VAR18 = VAR2 -> VAR14 ; } if ( VAR11 [ 0 ] == ' ' ) FUN14 ( VAR2 , VAR18 , VAR9 , VAR11 ) ; else FUN15 ( VAR2 , VAR18 , VAR9 , VAR11 , VAR7 ) ; } else if ( ! VAR11 [ 0 ] ) { if ( VAR11 [ 1 ] ) FUN9 ( VAR2 , VAR26 , , VAR4 , VAR16 ) ; FUN16 ( VAR2 -> VAR14 , VAR13 , VAR35 ) ; FUN17 ( VAR19 ) ; return ; } #0
303#303#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 = 0 ; int VAR6 ; FUN2 ( ! VAR2 -> VAR7 -> VAR8 -> VAR9 [ 0 ] ) ; if ( ! VAR4 ) VAR4 = VAR2 -> VAR7 -> VAR10 ; VAR2 -> VAR11 = 1 ; if ( VAR2 -> VAR7 -> VAR12 ) return VAR13 ; if ( VAR2 -> VAR14 == VAR15 ) { VAR6 = FUN3 ( VAR2 , VAR2 -> VAR7 -> VAR8 , & VAR5 , VAR4 ) ; if ( VAR6 >= 0 && ! ( VAR2 -> VAR16 & VAR17 ) ) VAR6 = VAR4 -> VAR18 ; } else if ( VAR2 -> VAR14 == VAR19 ) { VAR6 = FUN4 ( VAR2 , VAR2 -> VAR7 -> VAR8 , & VAR5 , VAR4 ) ; } else { VAR6 = FUN5 ( VAR20 ) ; } if ( VAR6 == FUN5 ( VAR21 ) ) VAR6 = VAR4 -> VAR18 ; if ( VAR2 -> VAR7 -> VAR22 && ! VAR5 ) VAR2 -> VAR7 -> VAR12 = 1 ; if ( VAR6 < 0 ) return VAR6 ; if ( VAR6 >= VAR4 -> VAR18 ) { FUN6 ( VAR2 -> VAR7 -> VAR10 ) ; } else { int VAR23 = VAR6 ; if ( VAR4 != VAR2 -> VAR7 -> VAR10 ) { FUN6 ( VAR2 -> VAR7 -> VAR10 ) ; if ( ( VAR6 = FUN7 ( VAR2 -> VAR7 -> VAR10 , VAR4 ) ) < 0 ) return VAR6 ; } VAR2 -> VAR7 -> VAR10 -> VAR24 += VAR23 ; VAR2 -> VAR7 -> VAR10 -> VAR18 -= VAR23 ; VAR2 -> VAR7 -> VAR10 -> VAR25 = VAR26 ; VAR2 -> VAR7 -> VAR10 -> VAR27 = VAR26 ; } if ( VAR5 ) FUN2 ( VAR2 -> VAR7 -> VAR8 -> VAR9 [ 0 ] ) ; return 0 ; } #0
304#304#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * cin = VAR2 -> VAR12 ; const VAR7 * VAR13 = VAR8 ; VAR14 * VAR15 = VAR3 ; int VAR16 ; VAR9 = FUN2 ( VAR9 , * VAR4 / 2 ) ; VAR16 = cin -> VAR16 ; if ( cin -> VAR17 ) { cin -> VAR17 = 0 ; VAR16 = ( VAR14 ) FUN3 ( VAR13 ) ; VAR13 += 2 ; * VAR15 ++ = VAR16 ; VAR9 -= 2 ; } while ( VAR9 > 0 ) { VAR16 += VAR18 [ * VAR13 ++ ] ; VAR16 = FUN4 ( VAR16 ) ; * VAR15 ++ = VAR16 ; -- VAR9 ; } cin -> VAR16 = VAR16 ; * VAR4 = ( VAR7 * ) VAR15 - ( VAR7 * ) VAR3 ; return VAR13 - VAR8 ; } #1
305#305#static void FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; VAR9 * VAR10 , * VAR11 , * VAR12 = & VAR7 -> VAR13 [ VAR5 ] ; int VAR14 = VAR12 -> VAR15 >> 16 ; int VAR16 , VAR17 = VAR14 * VAR7 -> VAR18 ; int VAR19 = VAR7 -> VAR19 ; VAR20 * VAR21 = VAR7 -> VAR21 , * VAR22 = VAR7 -> VAR22 ; VAR23 * VAR24 = & VAR7 -> VAR25 [ VAR14 & ( VAR7 -> VAR26 - 1 ) ] ; VAR27 * VAR28 ; VAR29 * VAR30 [ 3 ] = { VAR21 -> VAR31 . VAR32 -> VAR33 [ 0 ] + 16 * VAR14 * VAR7 -> VAR34 , VAR21 -> VAR31 . VAR32 -> VAR33 [ 1 ] + 8 * VAR14 * VAR7 -> VAR35 , VAR21 -> VAR31 . VAR32 -> VAR33 [ 2 ] + 8 * VAR14 * VAR7 -> VAR35 } ; if ( VAR14 == 0 ) VAR10 = VAR12 ; else VAR10 = & VAR7 -> VAR13 [ ( VAR4 + VAR19 - 1 ) % VAR19 ] ; if ( VAR14 == VAR7 -> VAR36 - 1 ) VAR11 = VAR12 ; else VAR11 = & VAR7 -> VAR13 [ ( VAR4 + 1 ) % VAR19 ] ; if ( VAR7 -> VAR37 == 1 ) VAR28 = VAR7 -> VAR38 + ( ( VAR7 -> VAR18 + 1 ) * ( VAR14 + 1 ) + 1 ) ; else { if ( VAR22 && VAR7 -> VAR39 . VAR40 && ! VAR7 -> VAR39 . VAR41 ) FUN2 ( & VAR22 -> VAR31 , VAR14 , 0 ) ; VAR28 = VAR7 -> VAR42 + ( VAR7 -> VAR36 - VAR14 - 1 ) * 2 ; memset ( VAR28 - 1 , 0 , sizeof ( * VAR28 ) ) ; FUN3 ( VAR7 -> VAR43 , VAR44 * 0x01010101 ) ; } memset ( VAR12 -> VAR45 , 0 , sizeof ( VAR12 -> VAR45 ) ) ; VAR7 -> VAR46 . VAR47 = - VAR48 ; VAR7 -> VAR49 . VAR47 = ( ( VAR7 -> VAR18 - 1 ) << 6 ) + VAR48 ; for ( VAR16 = 0 ; VAR16 < VAR7 -> VAR18 ; VAR16 ++ , VAR17 ++ , VAR28 ++ ) { if ( VAR10 != VAR12 ) { if ( VAR5 != 0 ) { FUN4 ( VAR12 , VAR10 , VAR16 + 1 , VAR14 - 1 ) ; } else { FUN4 ( VAR12 , VAR10 , ( VAR7 -> VAR18 + 3 ) + ( VAR16 + 1 ) , VAR14 - 1 ) ; } } VAR7 -> VAR50 . FUN5 ( VAR30 [ 0 ] + ( VAR16 & 3 ) * 4 * VAR7 -> VAR34 + 64 , VAR7 -> VAR34 , 4 ) ; VAR7 -> VAR50 . FUN5 ( VAR30 [ 1 ] + ( VAR16 & 7 ) * VAR7 -> VAR35 + 64 , VAR30 [ 2 ] - VAR30 [ 1 ] , 2 ) ; if ( ! VAR7 -> VAR37 ) FUN6 ( VAR7 , VAR28 , VAR16 , VAR14 , VAR21 -> VAR51 -> VAR33 + VAR17 , VAR22 && VAR22 -> VAR51 ? VAR22 -> VAR51 -> VAR33 + VAR17 : NULL , 0 ) ; FUN7 ( VAR7 , VAR28 , VAR16 , VAR14 , VAR17 , VAR52 ) ; if ( ! VAR28 -> VAR53 ) FUN8 ( VAR7 , VAR12 , VAR24 , VAR28 , VAR7 -> VAR54 [ VAR16 ] , VAR12 -> VAR45 ) ; if ( VAR28 -> VAR55 <= VAR56 ) FUN9 ( VAR7 , VAR12 , VAR30 , VAR28 , VAR16 , VAR14 ) ; else FUN10 ( VAR7 , VAR12 , VAR30 , VAR28 , VAR16 , VAR14 ) ; FUN7 ( VAR7 , VAR28 , VAR16 , VAR14 , VAR17 , VAR57 ) ; if ( ! VAR28 -> VAR53 ) { FUN11 ( VAR7 , VAR12 , VAR30 , VAR28 ) ; } else { FUN12 ( VAR12 -> VAR45 ) ; FUN13 ( VAR7 -> VAR54 [ VAR16 ] , 0 ) ; if ( VAR28 -> VAR55 != VAR56 && VAR28 -> VAR55 != VAR58 ) { VAR12 -> VAR45 [ 8 ] = 0 ; VAR7 -> VAR54 [ VAR16 ] [ 8 ] = 0 ; } } if ( VAR7 -> VAR59 ) FUN14 ( VAR7 , VAR28 , & VAR12 -> VAR60 [ VAR16 ] ) ; if ( VAR7 -> VAR59 && VAR19 != 1 && VAR5 == VAR19 - 1 ) { if ( VAR7 -> VAR61 . VAR62 ) FUN15 ( VAR7 -> VAR63 [ VAR16 + 1 ] , VAR30 [ 0 ] , NULL , NULL , VAR7 -> VAR34 , 0 , 1 ) ; else FUN15 ( VAR7 -> VAR63 [ VAR16 + 1 ] , VAR30 [ 0 ] , VAR30 [ 1 ] , VAR30 [ 2 ] , VAR7 -> VAR34 , VAR7 -> VAR35 , 0 ) ; } FUN7 ( VAR7 , VAR28 , VAR16 , VAR14 , VAR17 , VAR64 ) ; VAR30 [ 0 ] += 16 ; VAR30 [ 1 ] += 8 ; VAR30 [ 2 ] += 8 ; VAR7 -> VAR46 . VAR47 -= 64 ; VAR7 -> VAR49 . VAR47 -= 64 ; if ( VAR16 == VAR7 -> VAR18 + 1 ) { FUN16 ( VAR12 , VAR14 , VAR7 -> VAR18 + 3 ) ; } else { FUN16 ( VAR12 , VAR14 , VAR16 ) ; } } } #1
306#306#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 [ 0 ] ; int VAR10 ; int av_unused VAR11 ; int64_t VAR12 = FUN2 ( VAR2 -> VAR13 ) ; unsigned VAR14 ; int VAR15 ; VAR14 = FUN3 ( VAR2 -> VAR13 ) ; VAR10 = FUN3 ( VAR2 -> VAR13 ) ; FUN4 ( VAR2 , , VAR10 , VAR11 ) ; VAR10 = FUN6 ( VAR2 -> VAR13 ) ; FUN4 ( VAR2 , , VAR10 ) ; VAR10 = FUN6 ( VAR2 -> VAR13 ) ; FUN4 ( VAR2 , , VAR10 ) ; VAR10 = FUN3 ( VAR2 -> VAR13 ) ; FUN4 ( VAR2 , , VAR10 ) ; } VAR10 = VAR6 -> VAR16 - 8 - ( FUN2 ( VAR2 -> VAR13 ) - VAR12 ) ; if ( VAR10 < 0 ) return -1 ; VAR15 = FUN7 ( VAR2 -> VAR13 , VAR4 , VAR10 ) ; if ( VAR15 < 0 ) { FUN8 ( VAR2 , VAR17 , VAR25 "" "" , VAR4 -> VAR14 , VAR4 -> VAR21 ) ; return 0 ; } "#0
307#307#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , unsigned char * VAR5 , int VAR6 ) { unsigned char VAR7 [ 44 ] ; unsigned char VAR8 [ 32 ] ; gost_ctx VAR9 ; const struct VAR10 * VAR11 = NULL ; VAR1 * VAR12 = NULL ; VAR12 = FUN2 ( VAR4 -> VAR13 -> VAR14 ) ; VAR11 = FUN3 ( VAR4 -> VAR13 -> VAR15 ) ; FUN4 ( & VAR9 , VAR11 -> VAR16 ) ; FUN5 ( VAR4 -> VAR13 -> VAR17 -> VAR18 == 8 ) ; memcpy ( VAR7 , VAR4 -> VAR13 -> VAR17 -> VAR19 , 8 ) ; FUN5 ( VAR4 -> VAR20 -> VAR21 -> VAR18 == 32 ) ; memcpy ( VAR7 + 8 , VAR4 -> VAR20 -> VAR21 -> VAR19 , 32 ) ; FUN5 ( VAR4 -> VAR20 -> VAR22 -> VAR18 == 4 ) ; memcpy ( VAR7 + 40 , VAR4 -> VAR20 -> VAR22 -> VAR19 , 4 ) ; FUN6 ( VAR8 , 32 , FUN7 ( FUN8 ( VAR12 ) ) , FUN8 ( VAR2 ) , VAR7 ) ; if ( ! FUN9 ( & VAR9 , VAR8 , VAR7 , VAR5 ) ) { FUN10 ( VAR23 , VAR24 ) ; goto VAR25 ; } FUN11 ( VAR12 ) ; return 32 ; VAR25 : FUN11 ( VAR12 ) ; return -1 ; } #1
308#308#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR4 -> VAR8 ; int VAR9 ; FUN2 ( VAR4 ) ; FUN3 ( & VAR4 -> VAR10 ) ; for ( VAR9 = 0 ; VAR9 < VAR4 -> VAR11 ; VAR9 ++ ) { FUN3 ( & VAR4 -> VAR12 [ VAR9 ] ) ; } FUN3 ( & VAR4 -> VAR13 ) ; FUN3 ( & VAR4 -> VAR14 ) ; FUN3 ( & VAR4 -> VAR12 ) ; FUN3 ( & VAR4 -> VAR15 ) ; FUN4 ( & VAR4 -> VAR16 ) ; FUN4 ( & VAR4 -> VAR17 ) ; for ( VAR9 = 0 ; VAR9 < FUN5 ( VAR4 -> VAR18 ) ; VAR9 ++ ) { FUN6 ( VAR4 , & VAR4 -> VAR18 [ VAR9 ] , ~ 0 ) ; FUN4 ( & VAR4 -> VAR18 [ VAR9 ] . VAR19 ) ; } for ( VAR9 = 0 ; VAR9 < FUN5 ( VAR4 -> VAR20 ) ; VAR9 ++ ) FUN7 ( & VAR4 -> VAR20 [ VAR9 ] ) ; for ( VAR9 = 0 ; VAR9 < FUN5 ( VAR4 -> VAR21 ) ; VAR9 ++ ) FUN7 ( & VAR4 -> VAR21 [ VAR9 ] ) ; for ( VAR9 = 0 ; VAR9 < FUN5 ( VAR4 -> VAR22 ) ; VAR9 ++ ) FUN7 ( & VAR4 -> VAR22 [ VAR9 ] ) ; VAR4 -> VAR23 = NULL ; VAR4 -> VAR24 = NULL ; VAR4 -> VAR25 = NULL ; FUN7 ( & VAR4 -> VAR26 ) ; FUN3 ( & VAR4 -> VAR27 . VAR28 ) ; FUN3 ( & VAR4 -> VAR27 . VAR29 ) ; FUN3 ( & VAR4 -> VAR27 . VAR30 ) ; for ( VAR9 = 1 ; VAR9 < VAR4 -> VAR31 ; VAR9 ++ ) { VAR7 = VAR4 -> VAR32 [ VAR9 ] ; if ( VAR7 ) { FUN3 ( & VAR4 -> VAR32 [ VAR9 ] ) ; FUN3 ( & VAR4 -> VAR33 [ VAR9 ] ) ; } } if ( VAR4 -> VAR8 == VAR4 -> VAR32 [ 0 ] ) VAR4 -> VAR8 = NULL ; FUN3 ( & VAR4 -> VAR32 [ 0 ] ) ; for ( VAR9 = 0 ; VAR9 < VAR4 -> VAR11 ; VAR9 ++ ) FUN3 ( & VAR4 -> VAR34 [ VAR9 ] . VAR35 ) ; FUN3 ( & VAR4 -> VAR34 ) ; VAR4 -> VAR11 = 0 ; return 0 ; } #1
309#309#"static int FUN1 ( VAR1 ) ( VAR2 * VAR3 , void * VAR4 , const void * VAR5 , int VAR6 , int VAR7 ) { VAR8 * VAR9 = VAR4 ; const VAR8 * VAR10 = VAR5 ; int VAR11 ; int VAR12 = VAR3 -> VAR12 ; int VAR13 = VAR3 -> VAR13 ; int VAR14 = VAR12 >> VAR3 -> VAR15 ; #if VAR16 == 0 double VAR17 = 1.0 / VAR3 -> VAR18 ; #endif VAR12 &= VAR3->VAR19; for (VAR11 = 0; VAR11 < VAR6; VAR11++) { VAR20 *VAR21 = ((VAR20 *) VAR3->VAR22) + VAR3->VAR23 * VAR12; FELEM2 VAR24=0, VAR25 = 0;  int VAR26; for (VAR26 = 0; VAR26 < VAR3->VAR27; VAR26++) { VAR24 += VAR10[VAR14 + VAR26] * (VAR28)VAR21[VAR26]; VAR25  += VAR10[VAR14 + VAR26] * (VAR28)VAR21[VAR26 + VAR3->VAR23]; } #ifdef FELEML VAR24 += (VAR25 - VAR24) * (VAR29) VAR13 / VAR3->VAR18; #else #    if VAR16 == 0 VAR24 += (VAR25 - VAR24) * VAR17 * VAR13; #    else VAR24 += (VAR25 - VAR24) / VAR3->VAR18 * VAR13; #    endif #endif FUN2(VAR9[VAR11], VAR24);  VAR13 += VAR3->VAR30; VAR12 += VAR3->VAR31; if (VAR13 >= VAR3->VAR18) { VAR13 -= VAR3->VAR18; VAR12++; } VAR14 += VAR12 >> VAR3->VAR15; VAR12 &= VAR3->VAR19; }  if(VAR7){ VAR3->VAR13= VAR13; VAR3->VAR12= VAR12; }  return VAR14; } "#0
310#310#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { const VAR5 * VAR6 = VAR4 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 ; VAR5 * VAR11 , * VAR12 , * VAR13 = VAR9 -> VAR14 ; unsigned VAR15 , VAR16 ; int VAR17 , VAR18 , VAR19 ; int VAR20 , VAR21 ; int VAR22 ; VAR16 = FUN2 ( VAR6 + 8 ) ; VAR15 = FUN2 ( VAR6 + 4 ) ; if ( ( VAR22 = FUN3 ( VAR2 , VAR4 ) ) != 0 ) return VAR22 ; VAR19 = VAR4 -> VAR19 - 4 ; if ( VAR16 >= VAR4 -> VAR19 ) { FUN4 ( VAR2 , VAR23 , ) ; return VAR22 ; } VAR11 = VAR9 -> VAR26 ; VAR18 = * VAR13 ++ ; VAR11 [ 0 ] = VAR18 << 1 ; for ( VAR21 = 1 ; VAR21 < VAR2 -> VAR27 - 1 ; VAR21 += 2 ) { VAR17 = ( VAR18 + * VAR13 ++ ) & 0x1F ; VAR11 [ VAR21 ] = VAR18 + VAR17 ; VAR11 [ VAR21 + 1 ] = VAR17 << 1 ; VAR18 = VAR17 ; } VAR11 [ VAR21 ] = VAR18 << 1 ; VAR12 = VAR11 ; VAR11 += VAR2 -> VAR27 ; for ( VAR20 = 1 ; VAR20 < VAR2 -> VAR28 ; VAR20 ++ ) { VAR18 = ( ( VAR12 [ 0 ] >> 1 ) + * VAR13 ++ ) & 0x1F ; VAR11 [ 0 ] = VAR18 << 1 ; for ( VAR21 = 1 ; VAR21 < VAR2 -> VAR27 - 1 ; VAR21 += 2 ) { VAR17 = ( ( VAR12 [ VAR21 + 1 ] >> 1 ) + * VAR13 ++ ) & 0x1F ; VAR11 [ VAR21 ] = VAR18 + VAR17 ; VAR11 [ VAR21 + 1 ] = VAR17 << 1 ; VAR18 = VAR17 ; } VAR11 [ VAR21 ] = VAR18 << 1 ; VAR12 = VAR11 ; VAR11 += VAR2 -> VAR27 ; } if ( VAR16 ) { int VAR29 , VAR30 ; VAR29 = VAR4 -> VAR19 ; if ( VAR15 > VAR16 ) VAR29 = VAR15 ; VAR30 = FUN7 ( VAR9 -> VAR14 , VAR9 -> VAR24 , VAR4 -> VAR7 + 8 + VAR16 , VAR29 - VAR16 ) ; if ( VAR30 < 0 ) VAR30 = 0 ; for ( VAR20 = 0 ; VAR20 < VAR30 ; VAR20 ++ ) VAR9 -> VAR26 [ VAR20 * 2 + 1 ] = ( VAR9 -> VAR26 [ VAR20 * 2 + 1 ] + ( VAR9 -> VAR14 [ VAR20 ] << 1 ) ) & 0x3F ; } VAR13 = VAR9 -> VAR26 ; VAR11 = VAR9 -> VAR31 . VAR7 [ 0 ] ; for ( VAR21 = 0 ; VAR21 < VAR2 -> VAR28 ; VAR21 ++ ) { for ( VAR20 = 0 ; VAR20 < VAR2 -> VAR27 ; VAR20 ++ ) VAR11 [ VAR20 ] = ( VAR13 [ VAR20 ] << 2 ) | ( VAR13 [ VAR20 ] >> 3 ) ; VAR13 += VAR2 -> VAR27 ; VAR11 += VAR9 -> VAR31 . VAR32 [ 0 ] ; } return 0 ; } #1
311#311#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , const unsigned char * VAR5 , size_t VAR6 , const unsigned char * VAR7 , unsigned char * VAR8 , VAR9 * VAR10 , int VAR11 , int VAR12 ) { VAR13 * VAR14 = NULL ; VAR15 * VAR16 = NULL ; unsigned char VAR17 [ VAR18 ] , VAR19 [ VAR18 ] ; unsigned char VAR20 [ VAR18 ] , VAR21 [ VAR18 ] ; unsigned char * VAR22 ; const char VAR23 [ ] = ; const char * VAR25 ; size_t VAR26 , VAR27 , VAR28 = FUN2 ( VAR4 ) ; int VAR29 = -1 ; if ( VAR12 ) { VAR25 = VAR24 ; VAR27 = sizeof ( VAR24 ) - 1 ; } else { VAR25 = VAR23 ; VAR27 = sizeof ( VAR23 ) - 1 ; } if ( VAR2 -> VAR30 || ! VAR12 ) VAR22 = ( unsigned char * ) VAR2 -> VAR22 ; else VAR22 = ( unsigned char * ) VAR10 -> VAR22 ; if ( ! FUN3 ( VAR2 , VAR4 , NULL , VAR10 -> VAR31 , VAR10 -> VAR32 , VAR22 ) ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } VAR16 = FUN5 ( ) ; if ( VAR16 == NULL || EVP_DigestInit_ex ( VAR16 , VAR4 , NULL ) <= 0 || FUN6 ( VAR16 , VAR17 , NULL ) <= 0 ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( ! FUN7 ( VAR2 , VAR4 , VAR22 , ( unsigned char * ) VAR25 , VAR27 , VAR17 , VAR28 , VAR19 , VAR28 ) ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( ! FUN8 ( VAR2 , VAR4 , VAR19 , VAR20 , VAR28 ) ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( EVP_DigestInit_ex ( VAR16 , VAR4 , NULL ) <= 0 ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( VAR2 -> VAR36 ) { size_t VAR37 ; void * VAR38 ; VAR37 = FUN9 ( VAR2 -> VAR39 -> VAR40 , & VAR38 ) ; if ( VAR37 <= 0 ) { FUN4 ( VAR33 , VAR41 ) ; goto VAR35 ; } if ( VAR2 -> VAR30 ) { PACKET VAR42 , VAR43 ; if ( ! FUN10 ( & VAR42 , VAR38 , VAR37 ) || ! FUN11 ( & VAR42 , 1 ) || ! FUN12 ( & VAR42 , & VAR43 ) || ! FUN11 ( & VAR42 , 1 ) || ! FUN12 ( & VAR42 , & VAR43 ) ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } VAR37 -= FUN13 ( & VAR42 ) ; } if ( EVP_DigestUpdate ( VAR16 , VAR38 , VAR37 ) <= 0 ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } } if ( EVP_DigestUpdate ( VAR16 , VAR5 , VAR6 ) <= 0 || FUN6 ( VAR16 , VAR17 , NULL ) <= 0 ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } VAR14 = FUN14 ( VAR44 , NULL , VAR20 , VAR28 ) ; if ( VAR14 == NULL ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( ! VAR11 ) VAR8 = VAR21 ; VAR26 = VAR28 ; if ( FUN15 ( VAR16 , NULL , VAR4 , NULL , VAR14 ) <= 0 || FUN16 ( VAR16 , VAR17 , VAR28 ) <= 0 || FUN17 ( VAR16 , VAR8 , & VAR26 ) <= 0 || VAR26 != VAR28 ) { FUN4 ( VAR33 , VAR34 ) ; goto VAR35 ; } if ( VAR11 ) { VAR29 = 1 ; } else { VAR29 = ( FUN18 ( VAR7 , VAR8 , VAR28 ) == 0 ) ; } VAR35 : FUN19 ( VAR19 , sizeof ( VAR19 ) ) ; FUN19 ( VAR20 , sizeof ( VAR20 ) ) ; FUN20 ( VAR14 ) ; FUN21 ( VAR16 ) ; return VAR29 ; } #0
312#312#"static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { struct VAR4 * VAR4 = VAR2 -> VAR5 ; struct VAR6 * VAR7 = & VAR4 -> VAR8 [ VAR3 ] ; VAR9 * VAR10 = VAR2 -> VAR8 [ VAR3 ] ; struct VAR11 * VAR12 = VAR7 -> private ; VAR13 * VAR14 = VAR7 -> VAR15 + VAR7 -> VAR16 ; int VAR17 ; if ( ! VAR7 -> VAR18 ) return VAR19 ; if ( ( ! VAR7 -> VAR20 || VAR7 -> VAR20 == VAR21 ) && ! ( VAR7 -> VAR22 & VAR23 ) ) { int VAR24 , VAR25 ; int VAR26 ; VAR13 * VAR27 = VAR7 -> VAR15 + VAR7 -> VAR16 ; VAR13 * VAR28 = VAR27 ; VAR26 = 0 ; VAR24 = VAR7 -> VAR29 ; VAR25 = FUN2 ( VAR27 , VAR7 -> VAR18 ) ; if ( VAR25 < 0 ) { VAR7 -> VAR30 |= VAR31 ; return 0 ; } VAR26 += VAR25 ; VAR27 = VAR28 = VAR28 + VAR7 -> VAR18 ; for ( ; VAR24 < VAR7 -> VAR32 ; VAR24 ++ ) { if ( VAR7 -> VAR33 [ VAR24 ] < 255 ) { int VAR25 = FUN2 ( VAR27 , VAR7 -> VAR33 [ VAR24 ] ) ; if ( VAR25 < 0 ) { VAR26 = VAR7 -> VAR34 ; break ; } VAR26 += VAR25 ; VAR27 = VAR28 + VAR7 -> VAR33 [ VAR24 ] ; } VAR28 += VAR7 -> VAR33 [ VAR24 ] ; } VAR7 -> VAR20 = VAR7 -> VAR35 = VAR7 -> VAR34 - VAR26 ; } if ( ( VAR17 = FUN2 ( VAR14 , VAR7 -> VAR18 ) ) < 0 ) return VAR17 ; VAR7 -> VAR36 = VAR17 ; if ( VAR7 -> VAR20 != VAR21 ) { if ( VAR10 -> VAR37 == VAR21 ) VAR10 -> VAR37 = VAR7 -> VAR20 ; VAR12 -> VAR38 = VAR7 -> VAR35 = VAR7 -> VAR20 -= VAR12 -> VAR39 ; } VAR12 -> VAR38 += VAR7 -> VAR36 ; if ( ( VAR7 -> VAR22 & VAR23 ) ) { int64_t VAR40 = VAR12 -> VAR38 - VAR7 -> VAR34 + VAR12 -> VAR39 ; VAR40 = FUN3 ( VAR40 , VAR7 -> VAR36 ) ; if ( VAR40 > 0 ) { VAR7 -> VAR36 = VAR40 < VAR7 -> VAR36 ? VAR7 -> VAR36 - VAR40 : 1 ; VAR7 -> VAR41 = VAR40 ; FUN4 ( VAR2 , VAR42 , "" "" , VAR7 -> VAR36 ) ; } } return 0 ; } "#0
313#313#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 = ( VAR4 && VAR2 -> VAR5 -> VAR6 & VAR7 ) ? VAR2 -> VAR5 -> VAR8 : 1 ; int VAR9 , VAR10 ; FUN2 ( VAR2 -> VAR5 , VAR2 -> VAR11 . VAR12 ) ; FUN3 ( VAR2 -> VAR5 -> VAR13 , & VAR2 -> VAR14 , & VAR2 -> VAR15 ) ; if ( VAR2 -> VAR11 . VAR16 ) { int64_t VAR17 = VAR2 -> VAR11 . VAR18 ; if ( VAR2 -> VAR19 < 44U ) VAR17 *= 2 ; FUN4 ( & VAR2 -> VAR5 -> VAR20 . VAR17 , & VAR2 -> VAR5 -> VAR20 . VAR21 , VAR2 -> VAR11 . VAR22 , VAR17 , 1 << 30 ) ; } FUN5 ( VAR2 ) ; VAR2 -> VAR23 = 0 ; VAR2 -> VAR24 = 1 ; FUN6 ( VAR2 ) ; VAR10 = FUN7 ( VAR2 ) ; if ( VAR10 < 0 ) { FUN8 ( VAR2 -> VAR5 , VAR25 , , VAR2 -> VAR11 . VAR26 ) ; return VAR27 ; } VAR2 -> VAR5 -> VAR28 = VAR2 -> VAR11 . VAR26 ; VAR2 -> VAR29 = VAR2 -> VAR11 . VAR26 > 8 ; VAR2 -> VAR30 = VAR2 -> VAR11 . VAR30 ; VAR2 -> VAR26 = VAR2 -> VAR11 . VAR26 ; FUN9 ( & VAR2 -> VAR31 , VAR2 -> VAR11 . VAR26 , VAR2 -> VAR11 . VAR30 ) ; FUN10 ( & VAR2 -> VAR32 , VAR2 -> VAR11 . VAR33 ) ; FUN11 ( & VAR2 -> VAR34 , VAR2 -> VAR11 . VAR26 ) ; FUN12 ( & VAR2 -> VAR35 , VAR2 -> VAR5 -> VAR36 , VAR2 -> VAR11 . VAR26 , VAR2 -> VAR11 . VAR30 ) ; FUN13 ( & VAR2 -> VAR37 , VAR2 -> VAR11 . VAR26 ) ; if ( VAR3 > VAR38 || ( VAR3 > VAR2 -> VAR39 && VAR2 -> VAR39 ) ) { int VAR40 ; if ( VAR2 -> VAR39 ) VAR40 = FUN14 ( VAR38 , VAR2 -> VAR39 ) ; else VAR40 = VAR38 ; FUN8 ( VAR2 -> VAR5 , VAR41 , , VAR3 , VAR40 ) ; VAR3 = VAR40 ; } VAR2 -> VAR42 = VAR3 ; if ( ! VAR4 || ! ( VAR2 -> VAR5 -> VAR6 & VAR7 ) ) { VAR10 = FUN15 ( VAR2 , & VAR2 -> VAR43 [ 0 ] ) ; if ( VAR10 < 0 ) { FUN8 ( VAR2 -> VAR5 , VAR25 , ) ; return VAR10 ; } } } VAR2 -> VAR50 = 1 ; return 0 ; } #1
314#314#void FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 ; uint8_t VAR7 [ VAR8 ] = { 1 , 0 , } , VAR9 , VAR10 [ VAR8 ] ; float VAR11 [ VAR8 ] ; VAR3 = VAR2 -> VAR12 ; VAR9 = 0 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR13 ; VAR4 ++ ) { int VAR14 ; int VAR15 = VAR2 -> VAR16 [ VAR4 ] ; if ( VAR3 + VAR15 > VAR2 -> VAR17 ) { VAR10 [ VAR9 ++ ] = VAR3 - VAR2 -> VAR12 ; VAR3 = VAR2 -> VAR12 ; VAR7 [ VAR4 ] = 1 ; } for ( VAR6 = 0 ; VAR6 < VAR15 ; VAR6 += VAR14 ) { if ( VAR3 == VAR2 -> VAR17 ) { VAR10 [ VAR9 ++ ] = VAR3 - VAR2 -> VAR12 ; VAR3 = VAR2 -> VAR12 ; } VAR14 = FUN2 ( VAR15 - VAR6 , VAR2 -> VAR17 - VAR3 ) ; VAR3 += VAR14 ; } } VAR10 [ VAR9 ++ ] = VAR3 - VAR2 -> VAR12 ; for ( VAR5 = 1 ; VAR5 <= VAR2 -> VAR18 ; VAR5 ++ ) { if ( ! VAR2 -> VAR19 [ VAR5 ] ) continue ; VAR3 = VAR2 -> VAR17 ; for ( VAR6 = 0 ; VAR6 < VAR9 ; VAR6 ++ ) { memcpy ( & VAR2 -> VAR20 [ VAR5 ] [ VAR3 ] , & VAR2 -> VAR20 [ VAR5 ] [ VAR2 -> VAR12 ] , VAR10 [ VAR6 ] * sizeof ( float ) ) ; VAR3 += VAR10 [ VAR6 ] ; } VAR3 = VAR2 -> VAR17 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR13 ; VAR4 ++ ) { int VAR15 = VAR2 -> VAR16 [ VAR4 ] ; float VAR21 = 0.0f ; for ( VAR6 = 0 ; VAR6 < VAR15 ; VAR6 ++ ) { float VAR22 = VAR2 -> VAR20 [ VAR5 ] [ VAR3 ++ ] ; VAR21 += VAR22 * VAR22 ; } VAR11 [ VAR4 ] = FUN3 ( VAR21 / VAR15 ) ; } if ( VAR2 -> VAR23 [ VAR5 ] >= 0 ) { const float * VAR24 = VAR25 [ VAR2 -> VAR23 [ VAR5 ] ] ; VAR3 = VAR2 -> VAR17 - 2 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR13 ; VAR4 ++ ) { if ( VAR7 [ VAR4 ] ) { float * VAR26 = & VAR2 -> VAR20 [ VAR5 ] [ VAR3 ] ; VAR26 [ 0 ] *= VAR24 [ 0 ] ; VAR26 [ 1 ] *= VAR24 [ 1 ] ; VAR26 [ 2 ] *= VAR24 [ 2 ] ; VAR26 [ 3 ] *= VAR24 [ 1 ] ; VAR26 [ 4 ] *= VAR24 [ 0 ] ; } VAR3 += VAR2 -> VAR16 [ VAR4 ] ; } } VAR3 = VAR2 -> VAR17 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR13 ; VAR4 ++ ) { float VAR27 = VAR2 -> VAR28 [ VAR5 ] [ VAR4 ] * VAR11 [ VAR4 ] * ( 1.0f / VAR29 ) ; float VAR30 = VAR2 -> VAR31 [ VAR5 ] [ VAR4 ] ; for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR16 [ VAR4 ] ; VAR6 ++ ) { float VAR32 = VAR27 * ( VAR33 ) FUN4 ( & VAR2 -> VAR34 ) ; VAR2 -> VAR20 [ VAR5 ] [ VAR3 ] *= VAR30 ; VAR2 -> VAR20 [ VAR5 ] [ VAR3 ++ ] += VAR32 ; } } } } #1
315#315#"VAR1 * FUN1 ( const VAR1 * VAR2 , int VAR3 ) { VAR1 * VAR4 ; VAR4 = FUN2 ( sizeof ( * VAR2 ) ) ; if ( VAR4 == NULL ) { goto VAR5 ; } memcpy ( VAR4 , VAR2 , sizeof ( * VAR4 ) ) ; #ifndef OPENSSL_NO_PSK VAR4 -> VAR6 = NULL ; VAR4 -> VAR7 = NULL ; #endif VAR4 -> VAR8 . VAR9 = NULL ; #ifndef OPENSSL_NO_EC VAR4 -> VAR8 . VAR10 = NULL ; #endif VAR4 -> VAR8 . VAR11 = NULL ; VAR4 -> VAR8 . VAR12 = NULL ; #ifndef OPENSSL_NO_SRP VAR4 -> VAR13 = NULL ; #endif VAR4 -> VAR14 = NULL ; VAR4 -> VAR15 = NULL ; VAR4 -> VAR16 = NULL ; memset ( & VAR4 -> VAR17 , 0 , sizeof ( VAR4 -> VAR17 ) ) ; VAR4 -> VAR18 = NULL ; VAR4 -> VAR19 = NULL ; VAR4 -> VAR20 = 1 ; VAR4 -> VAR21 = FUN3 ( ) ; if ( VAR4 -> VAR21 == NULL ) goto VAR5 ; if ( ! FUN4 ( VAR22 , VAR4 , & VAR4 -> VAR17 ) ) goto VAR5 ; if ( VAR2 -> VAR15 != NULL ) { if ( ! FUN5 ( VAR2 -> VAR15 ) ) goto VAR5 ; VAR4 -> VAR15 = VAR2 -> VAR15 ; } if ( VAR2 -> VAR14 != NULL ) { VAR4 -> VAR14 = FUN6 ( VAR2 -> VAR14 ) ; if ( VAR4 -> VAR14 == NULL ) goto VAR5 ; } #ifndef OPENSSL_NO_PSK if ( VAR2 -> VAR6 ) { VAR4 -> VAR6 = FUN7 ( VAR2 -> VAR6 ) ; if ( VAR4 -> VAR6 == NULL ) { goto VAR5 ; } } if ( VAR2 -> VAR7 ) { VAR4 -> VAR7 = FUN7 ( VAR2 -> VAR7 ) ; if ( VAR4 -> VAR7 == NULL ) { goto VAR5 ; } } #endif if ( ! FUN8 ( VAR22 , & VAR4 -> VAR17 , & VAR2 -> VAR17 ) ) { goto VAR5 ; } if ( VAR2 -> VAR8 . VAR9 ) { VAR4 -> VAR8 . VAR9 = FUN7 ( VAR2 -> VAR8 . VAR9 ) ; if ( VAR4 -> VAR8 . VAR9 == NULL ) { goto VAR5 ; } } #ifndef OPENSSL_NO_EC if ( VAR2 -> VAR8 . VAR10 ) { VAR4 -> VAR8 . VAR10 = FUN9 ( VAR2 -> VAR8 . VAR10 , VAR2 -> VAR8 . VAR23 ) ; if ( VAR4 -> VAR8 . VAR10 == NULL ) goto VAR5 ; } #endif if ( VAR3 != 0 && VAR2 -> VAR8 . VAR11 != NULL ) { VAR4 -> VAR8 . VAR11 = FUN9 ( VAR2 -> VAR8 . VAR11 , VAR2 -> VAR8 . VAR24 ) ; if ( VAR4 -> VAR8 . VAR11 == NULL ) goto VAR5 ; } else { VAR4 -> VAR8 . VAR25 = 0 ; VAR4 -> VAR8 . VAR24 = 0 ; } if ( VAR2 -> VAR8 . VAR12 != NULL ) { VAR4 -> VAR8 . VAR12 = FUN9 ( VAR2 -> VAR8 . VAR12 , VAR2 -> VAR8 . VAR26 ) ; if ( VAR4 -> VAR8 . VAR12 == NULL ) goto VAR5 ; } #ifndef OPENSSL_NO_SRP if ( VAR2 -> VAR13 ) { VAR4 -> VAR13 = FUN7 ( VAR2 -> VAR13 ) ; if ( VAR4 -> VAR13 == NULL ) { goto VAR5 ; } } #endif if ( VAR2 -> VAR16 != NULL ) { VAR4 -> VAR16 = FUN9 ( VAR2 -> VAR16 , VAR2 -> VAR27 ) ; if ( VAR4 -> VAR16 == NULL ) goto VAR5 ; } return VAR4 ; VAR5 : FUN10 ( VAR28 , VAR29 ) ; FUN11 ( VAR4 ) ; return NULL ; } "#1
316#316#static VAR1 * FUN1 ( VAR2 * VAR3 , int VAR4 ) { VAR1 * VAR5 ; unsigned int VAR6 ; if ( VAR3 -> VAR7 == VAR3 -> VAR8 ) { VAR9 * VAR10 = FUN2 ( sizeof ( * VAR10 ) ) ; if ( VAR10 == NULL ) return NULL ; for ( VAR6 = 0 , VAR5 = VAR10 -> VAR11 ; VAR6 ++ < VAR12 ; VAR5 ++ ) { FUN3 ( VAR5 ) ; if ( ( VAR4 & VAR13 ) != 0 ) FUN4 ( VAR5 , VAR13 ) ; } VAR10 -> VAR14 = VAR3 -> VAR15 ; VAR10 -> VAR16 = NULL ; if ( VAR3 -> VAR17 == NULL ) VAR3 -> VAR17 = VAR3 -> VAR18 = VAR3 -> VAR15 = VAR10 ; else { VAR3 -> VAR15 -> VAR16 = VAR10 ; VAR3 -> VAR15 = VAR10 ; VAR3 -> VAR18 = VAR10 ; } VAR3 -> VAR8 += VAR12 ; VAR3 -> VAR7 ++ ; return VAR10 -> VAR11 ; } if ( ! VAR3 -> VAR7 ) VAR3 -> VAR18 = VAR3 -> VAR17 ; else if ( ( VAR3 -> VAR7 % VAR12 ) == 0 ) VAR3 -> VAR18 = VAR3 -> VAR18 -> VAR16 ; return VAR3 -> VAR18 -> VAR11 + ( ( VAR3 -> VAR7 ++ ) % VAR12 ) ; } #1
317#317#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; const VAR3 * VAR9 = VAR4 + VAR5 ; int VAR10 , VAR11 ; VAR12 * VAR13 ; int VAR14 , VAR15 , VAR16 ; int VAR17 , VAR18 , VAR19 , VAR20 ; int VAR21 , VAR22 , VAR23 , VAR24 , VAR25 , VAR26 ; FUN2 ( VAR2 , , VAR4 [ VAR10 ] ) ; if ( VAR10 % 16 == 15 ) FUN2 ( VAR2 , ) ; VAR11 = * VAR4 ++ ; VAR4 += 1 ; VAR13 = FUN3 ( VAR7 , VAR11 ) ; if ( ! VAR13 ) { VAR13 = FUN4 ( sizeof ( VAR12 ) ) ; if ( ! VAR13 ) return FUN5 ( VAR27 ) ; memcpy ( VAR13 , & VAR28 , sizeof ( VAR12 ) ) ; VAR13 -> VAR29 = VAR11 ; VAR13 -> VAR30 = VAR7 -> VAR31 ; VAR7 -> VAR31 = VAR13 ; } while ( VAR4 + 4 < VAR9 ) { VAR14 = * VAR4 ++ ; VAR15 = ( * VAR4 ) & 0xe0 ; if ( VAR15 == 0 ) { FUN6 ( VAR2 , VAR32 , , VAR14 , VAR21 , VAR22 , VAR23 , VAR20 ) ; if ( VAR15 & 0x80 ) VAR13 -> VAR34 [ VAR14 ] = FUN9 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; if ( VAR15 & 0x40 ) VAR13 -> VAR35 [ VAR14 ] = FUN9 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; if ( VAR15 & 0x20 ) VAR13 -> VAR36 [ VAR14 ] = FUN9 ( VAR21 , VAR22 , VAR23 , 255 - VAR20 ) ; } return 0 ; } #0
318#318#"static void FUN1 ( VAR1 * VAR2 , VAR1 * VAR3 , int VAR4 , int VAR5 , VAR6 * VAR7 , int VAR8 , int VAR9 ) { int VAR10 ; * VAR3 = * VAR2 ; if ( ! VAR8 ) { if ( VAR4 <= 1 ) return ; memcpy ( VAR3 + 1 , VAR2 + 1 , ( VAR4 - 1 ) * 4 ) ; return ; } if ( VAR8 == 0x1f ) { if ( VAR4 <= 1 ) return ; for ( VAR10 = 0 ; VAR10 < VAR4 - 1 ; VAR10 ++ ) { int32_t VAR11 ; int32_t VAR12 ; VAR11 = VAR3 [ VAR10 ] ; VAR12 = VAR2 [ VAR10 + 1 ] ; VAR3 [ VAR10 + 1 ] = FUN2 ( ( VAR11 + VAR12 ) , VAR5 ) ; } return ; } if ( VAR8 > 0 ) for ( VAR10 = 0 ; VAR10 < VAR8 ; VAR10 ++ ) { int32_t VAR13 ; VAR13 = VAR3 [ VAR10 ] + VAR2 [ VAR10 + 1 ] ; VAR13 = FUN2 ( VAR13 , VAR5 ) ; VAR3 [ VAR10 + 1 ] = VAR13 ; } #if 0 if ( VAR8 == 4 ) { return ; } if ( VAR7 == 8 ) { return ; } #endif if (VAR8 > 0) { for (VAR10 = VAR8 + 1; VAR10 < VAR4; VAR10++) { int VAR14; int VAR15 = 0; int VAR16; int VAR17 = VAR2[VAR10];  for (VAR14 = 0; VAR14 < VAR8; VAR14++) { VAR15 += (VAR3[VAR8-VAR14] - VAR3[0]) * VAR7[VAR14]; }  VAR16 = (1 << (VAR9-1)) + VAR15; VAR16 = VAR16 >> VAR9; VAR16 = VAR16 + VAR3[0] + VAR17; VAR16 = FUN2(VAR16, VAR5);  VAR3[VAR8+1] = VAR16;  if (VAR17 > 0) { int VAR18 = VAR8 - 1;  while (VAR18 >= 0 && VAR17 > 0) { int VAR13 = VAR3[0] - VAR3[VAR8 - VAR18]; int VAR19 = FUN3(VAR13);  VAR7[VAR18] -= VAR19;  VAR13 *= VAR19;   VAR17 -= ((VAR13 >> VAR9) * (VAR8 - VAR18));  VAR18--; } } else if (VAR17 < 0) { int VAR18 = VAR8 - 1;  while (VAR18 >= 0 && VAR17 < 0) { int VAR13 = VAR3[0] - VAR3[VAR8 - VAR18]; int VAR19 = - FUN3(VAR13);  VAR7[VAR18] -= VAR19;  VAR13 *= VAR19;   VAR17 -= ((VAR13 >> VAR9) * (VAR8 - VAR18));  VAR18--; } }  VAR3++; } } } "#1
319#319#static int FUN1 ( unsigned char * VAR1 , VAR2 * VAR3 , const unsigned char * VAR4 , size_t VAR5 , VAR6 * VAR7 ) { size_t VAR8 = FUN2 ( VAR7 ) ; size_t VAR9 ; int VAR10 ; VAR9 = ( VAR5 + 4 + VAR8 - 1 ) / VAR8 ; VAR9 *= VAR8 ; if ( VAR9 < 2 * VAR8 ) { return 0 ; } if ( VAR5 > 0xFF ) { return 0 ; } if ( VAR1 ) { VAR1 [ 0 ] = ( unsigned char ) VAR5 ; VAR1 [ 1 ] = VAR4 [ 0 ] ^ 0xFF ; VAR1 [ 2 ] = VAR4 [ 1 ] ^ 0xFF ; VAR1 [ 3 ] = VAR4 [ 2 ] ^ 0xFF ; memcpy ( VAR1 + 4 , VAR4 , VAR5 ) ; if ( VAR9 > VAR5 + 4 ) FUN3 ( VAR1 + 4 + VAR5 , VAR9 - 4 - VAR5 ) ; if ( ! FUN4 ( VAR7 , VAR1 , & VAR10 , VAR1 , VAR9 ) || ! FUN4 ( VAR7 , VAR1 , & VAR10 , VAR1 , VAR9 ) ) return 0 ; } * VAR3 = VAR9 ; return 1 ; } #1
320#320#static int FUN1 ( VAR1 * VAR2 ) { static const char VAR3 [ ] = ) ; return ( 0 ) ; } if ( VAR5 -> VAR12 != 0 ) { FUN4 ( VAR5 , VAR7 - 2 ) ; } else { VAR8 = sizeof ( VAR14 ) + 2 + VAR7 ; VAR10 = FUN5 ( VAR8 ) ; if ( VAR10 == 0 ) { FUN3 ( VAR2 -> VAR13 , VAR3 , ) ; return ( 0 ) ; } if ( VAR5 -> VAR16 [ VAR11 ] != 0 ) FUN7 ( VAR5 -> VAR16 [ VAR11 ] ) ; VAR5 -> VAR16 [ VAR11 ] = VAR10 ; } else { if ( ( VAR11 & 240 ) != 16 ) { FUN3 ( VAR2 -> VAR13 , VAR3 , ) ; return ( 0 ) ; } if ( VAR5 -> VAR17 [ VAR11 ] != 0 ) FUN7 ( VAR5 -> VAR17 [ VAR11 ] ) ; VAR5 -> VAR17 [ VAR11 ] = VAR10 ; } } return ( 1 ) ; } #1
321#321#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , tmsize_t VAR5 , uint16 VAR6 ) { VAR7 * VAR8 = FUN2 ( VAR2 ) ; VAR9 * VAR10 ; VAR9 * VAR11 ; tmsize_t VAR12 ; JDIMENSION VAR13 , VAR14 ; int VAR15 , VAR16 , VAR17 , VAR18 ; VAR19 * VAR20 ; int VAR21 = VAR8 -> VAR22 ; tmsize_t VAR23 ; ( void ) VAR6 ; assert ( VAR8 != NULL ) ; VAR23 = ( ( ( ( VAR24 ) VAR8 -> VAR25 . VAR26 . VAR27 + VAR8 -> VAR28 - 1 ) / VAR8 -> VAR28 ) * ( VAR8 -> VAR28 * VAR8 -> VAR29 + 2 ) * VAR8 -> VAR25 . VAR26 . VAR30 + 7 ) / 8 ; VAR12 = ( VAR5 / VAR23 ) * VAR8 -> VAR29 ; if ( VAR5 % VAR23 ) FUN3 ( VAR2 -> VAR31 , VAR2 -> VAR32 , "" "" ) ; VAR13 = VAR8 -> VAR25 . VAR26 . VAR33 [ 1 ] . VAR34 ; while ( VAR12 > 0 ) { VAR15 = 0 ; for ( VAR16 = 0 , VAR20 = VAR8 -> VAR25 . VAR26 . VAR33 ; VAR16 < VAR8 -> VAR25 . VAR26 . VAR35 ; VAR16 ++ , VAR20 ++ ) { int VAR36 = VAR20 -> VAR37 ; int VAR38 = VAR20 -> VAR39 ; int VAR40 = ( int ) ( VAR20 -> VAR41 * VAR42 - VAR13 * VAR36 ) ; for ( VAR18 = 0 ; VAR18 < VAR38 ; VAR18 ++ ) { VAR10 = ( ( VAR9 * ) VAR4 ) + VAR15 ; VAR11 = VAR8 -> VAR43 [ VAR16 ] [ VAR8 -> VAR44 * VAR38 + VAR18 ] ; if ( VAR36 == 1 ) { for ( VAR14 = VAR13 ; VAR14 -- > 0 ; ) { * VAR11 ++ = VAR10 [ 0 ] ; VAR10 += VAR21 ; } } else { for ( VAR14 = VAR13 ; VAR14 -- > 0 ; ) { for ( VAR17 = 0 ; VAR17 < VAR36 ; VAR17 ++ ) * VAR11 ++ = VAR10 [ VAR17 ] ; VAR10 += VAR21 ; } } for ( VAR17 = 0 ; VAR17 < VAR40 ; VAR17 ++ ) { * VAR11 = VAR11 [ -1 ] ; VAR11 ++ ; } VAR15 += VAR36 ; } } VAR8 -> VAR44 ++ ; if ( VAR8 -> VAR44 >= VAR42 ) { int VAR45 = VAR8 -> VAR25 . VAR26 . VAR46 * VAR42 ; if ( FUN4 ( VAR8 , VAR8 -> VAR43 , VAR45 ) != VAR45 ) return ( 0 ) ; VAR8 -> VAR44 = 0 ; } VAR2 -> VAR47 += VAR8 -> VAR29 ; VAR4 += VAR23 ; VAR12 -= VAR8 -> VAR29 ; } return ( 1 ) ; } "#0
322#322#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 ) { int VAR9 , VAR10 , VAR11 ; int VAR12 , VAR13 , VAR14 ; VAR1 * VAR15 ; int VAR16 , VAR17 ; const int VAR18 = ~ ( VAR8 ? 3 : 1 ) ; const int VAR19 = VAR4 << 1 ; for ( VAR11 = 0 ; VAR11 < VAR7 ; VAR11 ++ ) { VAR16 = ( ( VAR11 * VAR6 ) / VAR7 ) & VAR18 ; VAR17 = ( ( ( ( VAR11 + 1 ) * VAR6 ) / VAR7 ) & VAR18 ) - VAR16 ; VAR17 >>= 1 ; if ( ! VAR17 ) continue ; VAR15 = VAR2 + VAR16 * VAR4 ; VAR15 [ 0 ] += 0x80 ; VAR12 = VAR15 [ 0 ] ; for ( VAR9 = VAR3 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR15 [ VAR9 ] += VAR12 ; VAR12 = VAR15 [ VAR9 ] ; } for ( VAR9 = 0 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR15 [ VAR4 + VAR9 ] += VAR12 ; VAR12 = VAR15 [ VAR4 + VAR9 ] ; } VAR15 += VAR19 ; if ( VAR17 == 1 ) continue ; VAR14 = VAR15 [ - VAR19 ] ; VAR15 [ 0 ] += VAR14 ; VAR12 = VAR15 [ 0 ] ; for ( VAR9 = VAR3 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR13 = VAR15 [ VAR9 - VAR19 ] ; VAR15 [ VAR9 ] += FUN2 ( VAR12 , VAR13 , ( VAR1 ) ( VAR12 + VAR13 - VAR14 ) ) ; VAR14 = VAR13 ; VAR12 = VAR15 [ VAR9 ] ; } for ( VAR9 = 0 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR13 = VAR15 [ VAR9 - VAR4 ] ; VAR15 [ VAR4 + VAR9 ] += FUN2 ( VAR12 , VAR13 , ( VAR1 ) ( VAR12 + VAR13 - VAR14 ) ) ; VAR14 = VAR13 ; VAR12 = VAR15 [ VAR4 + VAR9 ] ; } VAR15 += VAR19 ; for ( VAR10 = 2 ; VAR10 < VAR17 ; VAR10 ++ ) { for ( VAR9 = 0 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR13 = VAR15 [ VAR9 - VAR19 ] ; VAR15 [ VAR9 ] += FUN2 ( VAR12 , VAR13 , ( VAR1 ) ( VAR12 + VAR13 - VAR14 ) ) ; VAR14 = VAR13 ; VAR12 = VAR15 [ VAR9 ] ; } for ( VAR9 = 0 ; VAR9 < VAR5 * VAR3 ; VAR9 += VAR3 ) { VAR13 = VAR15 [ VAR9 - VAR4 ] ; VAR15 [ VAR9 + VAR4 ] += FUN2 ( VAR12 , VAR13 , ( VAR1 ) ( VAR12 + VAR13 - VAR14 ) ) ; VAR14 = VAR13 ; VAR12 = VAR15 [ VAR9 + VAR4 ] ; } VAR15 += VAR19 ; } } } #0
323#323#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int * VAR4 ) { unsigned char * VAR5 ; int VAR6 ; for ( VAR5 = VAR2 + 8 * VAR3 ; VAR2 != VAR5 ; VAR2 += VAR3 ) { VAR6 = ( VAR2 [ -2 ] - VAR2 [ 1 ] ) + 3 * ( VAR2 [ 0 ] - VAR2 [ -1 ] ) ; VAR6 = VAR4 [ ( VAR6 + 4 ) >> 3 ] ; VAR2 [ -1 ] = FUN2 ( VAR2 [ -1 ] + VAR6 ) ; VAR2 [ 0 ] = FUN2 ( VAR2 [ 0 ] - VAR6 ) ; } } #0
324#324#VAR1 FUN1 ( VAR2 * VAR3 , size_t VAR4 ) { char * VAR5 ; size_t VAR6 ; if ( VAR3 -> VAR7 >= VAR4 ) { VAR3 -> VAR7 = VAR4 ; return ( VAR4 ) ; } if ( VAR3 -> VAR8 >= VAR4 ) { if ( VAR3 -> VAR9 != NULL ) memset ( & VAR3 -> VAR9 [ VAR3 -> VAR7 ] , 0 , VAR4 - VAR3 -> VAR7 ) ; VAR3 -> VAR7 = VAR4 ; return ( VAR4 ) ; } if ( VAR4 > VAR10 ) { FUN2 ( VAR11 , VAR12 ) ; return 0 ; } VAR6 = ( VAR4 + 3 ) / 3 * 4 ; if ( ( VAR3 -> VAR13 & VAR14 ) ) VAR5 = FUN3 ( VAR3 , VAR6 ) ; else VAR5 = FUN4 ( VAR3 -> VAR9 , VAR6 ) ; if ( VAR5 == NULL ) { FUN2 ( VAR11 , VAR12 ) ; VAR4 = 0 ; } else { VAR3 -> VAR9 = VAR5 ; VAR3 -> VAR8 = VAR6 ; memset ( & VAR3 -> VAR9 [ VAR3 -> VAR7 ] , 0 , VAR4 - VAR3 -> VAR7 ) ; VAR3 -> VAR7 = VAR4 ; } return ( VAR4 ) ; } #1
325#325#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 ; fd_set VAR10 ; int VAR11 , VAR12 ; struct timeval VAR13 ; VAR1 * VAR14 ; int VAR15 ; VAR12 = FUN2 ( VAR6 -> VAR16 ) ; while ( 1 ) { FUN3 ( & VAR10 ) ; FUN4 ( VAR12 , & VAR10 ) ; VAR13 . VAR17 = 0 ; VAR13 . VAR18 = 0 ; VAR11 = FUN5 ( VAR12 + 1 , & VAR10 , NULL , NULL , & VAR13 ) ; if ( VAR11 <= 0 ) break ; if ( FUN6 ( VAR12 , & VAR10 ) ) { RTSPMessageHeader VAR19 ; VAR15 = FUN7 ( VAR2 , & VAR19 , NULL , 1 , NULL ) ; if ( VAR15 < 0 ) return FUN8 ( VAR20 ) ; if ( VAR15 == 1 ) FUN9 ( VAR2 ) ; if ( VAR6 -> VAR21 != VAR22 ) return FUN8 ( VAR20 ) ; } } if ( VAR4 -> VAR23 < 0 || VAR4 -> VAR23 > = VAR6 -> VAR24 ) return VAR25 ; VAR9 = VAR6 -> VAR26 [ VAR4 -> VAR23 ] ; VAR14 = VAR9 -> VAR27 ; VAR15 = FUN10 ( VAR14 , 0 , VAR4 , VAR2 ) ; if ( ! VAR15 && VAR6 -> VAR28 == VAR29 ) VAR15 = FUN11 ( VAR2 , VAR9 ) ; return VAR15 ; } #1
326#326#static inline void FUN1 ( VAR1 * VAR2 , const int VAR3 , const int VAR4 , const int VAR5 , const int VAR6 , const int VAR7 , const int VAR8 , const int VAR9 , const int VAR10 , const int VAR11 , const int VAR12 , const int VAR13 , const int VAR14 ) { VAR1 * VAR15 = VAR16 + VAR17 ; int VAR18 , VAR19 , VAR20 ; VAR18 = VAR2 [ 0 * VAR3 ] - VAR2 [ -1 * VAR3 ] ; if ( ! VAR18 ) return ; VAR19 = ( VAR6 * FUN2 ( VAR18 ) ) >> 7 ; if ( VAR19 > 3 - ( VAR4 && VAR5 ) ) return ; VAR18 <<= 2 ; if ( VAR4 && VAR5 ) VAR18 += VAR2 [ -2 * VAR3 ] - VAR2 [ 1 * VAR3 ] ; VAR20 = FUN3 ( ( VAR18 + 4 ) >> 3 , VAR8 ) ; VAR2 [ -1 * VAR3 ] = VAR15 [ VAR2 [ -1 * VAR3 ] + VAR20 ] ; VAR2 [ 0 * VAR3 ] = VAR15 [ VAR2 [ 0 * VAR3 ] - VAR20 ] ; if ( FUN2 ( VAR13 ) <= VAR7 && VAR4 ) { VAR18 = ( VAR11 + VAR13 - VAR20 ) >> 1 ; VAR2 [ -2 * VAR3 ] = VAR15 [ VAR2 [ -2 * VAR3 ] - FUN3 ( VAR18 , VAR10 ) ] ; } if ( FUN2 ( VAR14 ) <= VAR7 && VAR5 ) { VAR18 = ( VAR12 + VAR14 + VAR20 ) >> 1 ; VAR2 [ 1 * VAR3 ] = VAR15 [ VAR2 [ 1 * VAR3 ] - FUN3 ( VAR18 , VAR9 ) ] ; } } #1
327#327#static av_always_inline int FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; VAR10 * VAR11 = & VAR8 -> VAR12 [ VAR4 ] ; VAR10 * VAR13 = NULL , * VAR14 = NULL ; VAR15 * VAR16 = VAR8 -> VAR16 ; int VAR17 , VAR18 = VAR8 -> VAR18 ; VAR11 -> VAR19 = VAR5 ; for ( VAR17 = VAR4 ; VAR17 < VAR8 -> VAR20 ; VAR17 += VAR18 ) { if ( VAR17 >= VAR8 -> VAR20 ) break ; VAR11 -> VAR21 = VAR17 << 16 ; FUN2 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR6 ) ; if ( VAR8 -> VAR22 ) FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR6 ) ; FUN4 ( VAR11 , VAR17 , VAR23 & 0xFFFF ) ; VAR8 -> VAR24 . VAR25 -= 64 ; VAR8 -> VAR26 . VAR25 -= 64 ; if ( VAR2 -> VAR27 == VAR28 ) FUN5 ( & VAR16 -> VAR29 , VAR17 , 0 ) ; } return 0 ; } #0
328#328#int FUN1 ( VAR1 * * VAR2 , VAR3 * VAR4 , const char * VAR5 , const char * VAR6 , void * VAR7 , VAR8 * VAR9 ) { int VAR10 ; * VAR2 = FUN2 ( VAR9 , VAR4 , VAR5 ) ; if ( ! * VAR2 ) return FUN3 ( VAR11 ) ; VAR10 = FUN4 ( * VAR2 , VAR6 ) ; if ( VAR10 < 0 ) goto VAR12 ; return 0 ; VAR12 : if ( * VAR2 ) FUN5 ( * VAR2 ) ; * VAR2 = NULL ; return VAR10 ; } #0
329#329#int FUN1 ( const VAR1 * VAR2 ) { int VAR3 , VAR4 = 0 ; int VAR5 = VAR2 -> VAR6 + VAR2 -> VAR7 ; int VAR8 [ 4 ] = { 0 } ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR9 ; VAR3 ++ ) { const VAR10 * VAR11 = & VAR2 -> VAR11 [ VAR3 ] ; int VAR12 = VAR3 == 1 || VAR3 == 2 ? 0 : VAR5 ; VAR8 [ VAR11 -> VAR13 ] = ( VAR11 -> VAR14 + 1 ) << VAR12 ; } for ( VAR3 = 0 ; VAR3 < 4 ; VAR3 ++ ) VAR4 += VAR8 [ VAR3 ] ; if ( ! ( VAR2 -> VAR15 & VAR16 ) ) VAR4 *= 8 ; return VAR4 >> VAR5 ; } #1
330#330#static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 = 0 ; while ( -- VAR3 >= 0 ) { VAR4 <<= 1 ; if ( VAR2 -> VAR5 == 0 ) { VAR2 -> VAR5 = 7 + ( FUN2 ( & VAR2 -> VAR6 ) != 0xFFu ) ; } VAR2 -> VAR5 -- ; VAR4 |= ( FUN3 ( & VAR2 -> VAR6 ) >> VAR2 -> VAR5 ) & 1 ; } return VAR4 ; } #1
331#331#VAR1 * FUN1 ( VAR1 * VAR2 , int VAR3 ) { if ( VAR3 > VAR2 -> VAR4 ) { VAR5 * VAR6 = FUN2 ( VAR2 , VAR3 ) ; if ( ! VAR6 ) return NULL ; if ( VAR2 -> VAR7 ) { FUN3 ( VAR2 -> VAR7 , VAR2 -> VAR4 * sizeof ( VAR2 -> VAR7 [ 0 ] ) ) ; FUN4 ( VAR2 ) ; } VAR2 -> VAR7 = VAR6 ; VAR2 -> VAR4 = VAR3 ; } return VAR2 ; } #1
332#332#"int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , VAR5 * VAR6 ) { int VAR7 = 0 ; VAR3 * VAR8 , * VAR9 ; FUN2 ( VAR6 ) ; if ( ( VAR8 = FUN3 ( VAR6 ) ) == NULL ) goto VAR10 ; VAR9 = & ( VAR2 -> VAR11 ) ; FUN4 ( & ( VAR2 -> VAR12 ) , VAR4 ) ; VAR2 -> VAR12 . VAR13 = 0 ; #ifdef VAR14 { BIGNUM VAR15 ; BN_ULONG VAR16 [ 2 ] ; VAR2 -> VAR17 = ( FUN5 ( VAR4 ) + ( VAR18 - 1 ) ) / VAR18 * VAR18 ; FUN6 ( VAR9 ) ; if ( ! ( FUN7 ( VAR9 , VAR18 ) ) ) goto VAR10 ; VAR16 [ 0 ] = VAR4 -> VAR19 [ 0 ] ; VAR16 [ 1 ] = 0 ; VAR15 . VAR19 = VAR16 ; VAR15 . VAR20 = 1 ; VAR15 . VAR21 = 2 ; VAR15 . VAR13 = 0 ; if ( ( FUN8 ( VAR8 , VAR9 , & VAR15 , VAR6 ) ) == NULL ) goto VAR10 ; if ( ! FUN9 ( VAR8 , VAR8 , VAR18 ) ) goto VAR10 ; if ( ! FUN10 ( VAR8 ) ) { if ( ! FUN11 ( VAR8 , 1 ) ) goto VAR10 ; } else { if ( ! FUN12 ( VAR8 , VAR22 ) ) goto VAR10 ; } if ( ! FUN13 ( VAR8 , NULL , VAR8 , & VAR15 , VAR6 ) ) goto VAR10 ; VAR2 -> VAR23 = ( VAR8 -> VAR20 > 0 ) ? VAR8 -> VAR19 [ 0 ] : 0 ; } #else { VAR2 -> VAR17 = FUN5 ( & VAR2 -> VAR12 ) ; FUN6 ( VAR9 ) ; if ( ! FUN7 ( VAR9 , VAR2 -> VAR17 ) ) goto VAR10 ; if ( ( FUN8 ( VAR8 , VAR9 , & VAR2 -> VAR12 , VAR6 ) ) == NULL ) goto VAR10 ; if ( ! FUN9 ( VAR8 , VAR8 , VAR2 -> VAR17 ) ) goto VAR10 ; if ( ! FUN11 ( VAR8 , 1 ) ) goto VAR10 ; if ( ! FUN13 ( & ( VAR2 -> VAR24 ) , NULL , VAR8 , & VAR2 -> VAR12 , VAR6 ) ) goto VAR10 ; } #endif FUN6 ( & ( VAR2 -> VAR11 ) ) ; if ( ! FUN7 ( & ( VAR2 -> VAR11 ) , VAR2 -> VAR17 * 2 ) ) goto VAR10 ; if ( ! FUN14 ( & ( VAR2 -> VAR11 ) , & ( VAR2 -> VAR11 ) , & ( VAR2 -> VAR12 ) , VAR6 ) ) goto VAR10 ; VAR7 = 1 ; VAR10 : FUN15 ( VAR6 ) ; return VAR7 ; } "#0
333#333#static int FUN1 ( VAR1 * VAR2 , int VAR3 , unsigned VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR6 ; VAR7 * VAR8 = VAR2 -> VAR9 [ 0 ] -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; int VAR14 ; uint64_t VAR15 ; int VAR16 ; unsigned int VAR17 ; if ( VAR3 & 1 ) VAR3 ++ ; VAR8 -> VAR18 = VAR19 ; VAR8 -> VAR20 = FUN2 ( VAR6 ) ; VAR17 = FUN3 ( VAR6 ) ; VAR8 -> VAR21 = FUN2 ( VAR6 ) ; VAR14 = FUN2 ( VAR6 ) - 16383 - 63 ; VAR15 = FUN4 ( VAR6 ) ; if ( VAR14 < -63 || VAR14 > 63 ) { FUN5 ( VAR2 , VAR22 , , VAR30 ) ; } VAR3 -= 4 ; } if ( VAR4 != VAR25 || VAR8 -> VAR27 == VAR31 ) { VAR8 -> VAR27 = FUN10 ( VAR8 -> VAR21 ) ; VAR8 -> VAR21 = FUN11 ( VAR8 -> VAR27 ) ; VAR12 -> VAR32 = 1 ; } else { switch ( VAR8 -> VAR27 ) { case VAR33 : case VAR34 : case VAR35 : case VAR36 : case VAR37 : VAR12 -> VAR32 = 1 ; break ; case VAR38 : VAR8 -> VAR39 = 34 * VAR8 -> VAR20 ; break ; case VAR40 : VAR8 -> VAR39 = 2 * VAR8 -> VAR20 ; break ; case VAR41 : VAR8 -> VAR21 = 5 ; case VAR42 : case VAR43 : case VAR44 : case VAR45 : VAR8 -> VAR39 = 1 * VAR8 -> VAR20 ; break ; case VAR46 : VAR8 -> VAR39 = 33 ; break ; default : VAR12 -> VAR32 = 1 ; break ; } if ( VAR8 -> VAR39 > 0 ) VAR12 -> VAR32 = FUN12 ( VAR8 , VAR8 -> VAR39 ) ; } if ( ! VAR8 -> VAR39 ) VAR8 -> VAR39 = ( FUN11 ( VAR8 -> VAR27 ) * VAR8 -> VAR20 ) >> 3 ; if ( VAR12 -> VAR32 ) { VAR8 -> VAR47 = VAR8 -> VAR16 * ( VAR8 -> VAR39 << 3 ) / VAR12 -> VAR32 ; } if ( VAR3 ) FUN13 ( VAR6 , VAR3 ) ; return VAR17 ; } #1
334#334#static VAR1 * FUN1 ( const VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 ) { unsigned char VAR5 [ VAR6 ] ; unsigned char * VAR7 = NULL ; int VAR8 = FUN2 ( VAR4 ) ; VAR1 * VAR9 = NULL ; if ( VAR2 != VAR4 && FUN3 ( VAR2 , VAR4 ) >= 0 ) return NULL ; if ( VAR3 != VAR4 && FUN3 ( VAR3 , VAR4 ) >= 0 ) return NULL ; if ( ( VAR7 = FUN4 ( VAR8 * 2 ) ) == NULL ) goto VAR10 ; if ( FUN5 ( VAR2 , VAR7 , VAR8 ) < 0 || FUN5 ( VAR3 , VAR7 + VAR8 , VAR8 ) < 0 || ! FUN6 ( VAR7 , VAR8 * 2 , VAR5 , NULL , FUN7 ( ) , NULL ) ) goto VAR10 ; VAR9 = FUN8 ( VAR5 , sizeof ( VAR5 ) , NULL ) ; VAR10 : FUN9 ( VAR7 ) ; return VAR9 ; } #0
335#335#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = & VAR2 -> VAR5 -> VAR4 ; int VAR6 , VAR7 , VAR8 , VAR9 ; FUN2 ( VAR4 ) ; VAR6 = FUN3 ( VAR4 ) ; if ( VAR6 == 0 ) { VAR7 = FUN4 ( VAR4 , 7 ) ; VAR8 = FUN3 ( VAR4 ) ; VAR9 = FUN4 ( VAR4 , 6 ) ; FUN5 ( VAR4 , 6 ) ; if ( VAR8 == 0 && VAR7 != 5 ) FUN5 ( VAR4 , 16 ) ; FUN5 ( VAR4 , 8 ) ; FUN6 ( VAR4 ) ; } FUN6 ( VAR4 ) ; VAR2 -> VAR10 = ( VAR6 == 0 ) ; VAR2 -> VAR11 = VAR7 ; VAR2 -> VAR12 = VAR9 ; VAR2 -> VAR13 = VAR8 ; } #1
336#336#static int FUN1 ( const char * * VAR1 , VAR2 * * VAR3 , VAR2 * * VAR4 , VAR5 * VAR6 ) { int VAR7 = 0 ; while ( * * VAR1 == ' ' ) { char * VAR8 = FUN2 ( VAR1 , VAR6 ) ; VAR2 * VAR9 ; if ( ! VAR8 ) return FUN3 ( VAR10 ) ; VAR9 = FUN4 ( VAR8 , VAR4 ) ; if ( VAR9 ) { FUN5 ( VAR8 ) ; } else { VAR9 = FUN6 ( sizeof ( VAR2 ) ) ; VAR9 -> VAR8 = VAR8 ; VAR9 -> VAR11 = VAR7 ; } FUN7 ( VAR3 , VAR9 ) ; * VAR1 += strspn ( * VAR1 , VAR12 ) ; VAR7 ++ ; } return VAR7 ; } #1
337#337#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; const VAR10 * VAR11 = VAR6 -> VAR3 ; const VAR10 * VAR12 = VAR6 -> VAR3 + VAR6 -> VAR13 ; const VAR10 * VAR14 ; uint32_t VAR15 , VAR16 ; VAR10 * VAR17 ; int VAR18 ; int VAR19 , VAR20 ; if ( VAR8 -> VAR21 . VAR3 [ 0 ] ) VAR2 -> FUN2 ( VAR2 , & VAR8 -> VAR21 ) ; if ( ( VAR18 = VAR2 -> FUN3 ( VAR2 , & VAR8 -> VAR21 ) ) ) { FUN4 ( VAR2 , VAR22 , , VAR16 ) ; return -1 ; } if ( ! VAR15 ) break ; if ( VAR15 == 1 ) { VAR20 = FUN6 ( VAR16 / 3 , 256 ) ; VAR14 = VAR11 ; for ( VAR19 = 0 ; VAR19 < VAR20 ; VAR19 ++ ) { VAR8 -> VAR23 [ VAR19 ] = FUN7 ( & VAR14 ) << 2 ; VAR8 -> VAR23 [ VAR19 ] |= ( VAR8 -> VAR23 [ VAR19 ] >> 6 ) & 0x333 ; } VAR8 -> VAR21 . VAR24 = 1 ; } else if ( VAR15 <= 9 ) { if ( VAR25 [ VAR15 - 2 ] ( VAR8 -> VAR26 , VAR2 -> VAR27 , VAR2 -> VAR28 , VAR11 , VAR11 + VAR16 ) ) { FUN4 ( VAR2 , VAR22 , , VAR15 ) ; } VAR11 += VAR16 ; } VAR11 = VAR8 -> VAR26 ; VAR17 = VAR8 -> VAR21 . VAR3 [ 0 ] ; for ( VAR19 = 0 ; VAR19 < VAR2 -> VAR28 ; VAR19 ++ ) { memcpy ( VAR17 , VAR11 , VAR2 -> VAR27 ) ; VAR17 += VAR8 -> VAR21 . VAR31 [ 0 ] ; VAR11 += VAR2 -> VAR27 ; } memcpy ( VAR8 -> VAR21 . VAR3 [ 1 ] , VAR8 -> VAR23 , sizeof ( VAR8 -> VAR23 ) ) ; * VAR4 = sizeof ( VAR32 ) ; * ( VAR32 * ) VAR3 = VAR8 -> VAR21 ; return VAR6 -> VAR13 ; } #1
338#338#VAR1 FUN1 ( void * VAR2 , const char * VAR3 , const VAR4 * * VAR5 ) { int64_t VAR6 = 1 ; double VAR7 = 1 ; int VAR8 = 1 ; FUN2 ( VAR2 , VAR3 , VAR5 , & VAR7 , & VAR8 , & VAR6 ) ; return VAR7 * VAR6 / VAR8 ; } #1
339#339#static void FUN1 ( VAR1 * VAR2 , unsigned int * VAR3 , VAR4 * VAR5 ) { VAR6 * VAR7 = & VAR2 -> VAR7 ; VAR8 * VAR9 = & VAR2 -> VAR9 ; unsigned int * VAR10 = VAR3 ; unsigned int VAR11 ; if ( VAR7 -> VAR12 ) { unsigned int VAR13 = 1 << ( VAR7 -> VAR12 + 2 ) ; * VAR5 = FUN2 ( VAR9 , VAR13 ) ; * VAR5 <<= ( 32 - VAR13 ) ; } VAR2 -> VAR14 = 0 ; FUN3 ( * VAR5 , 0 , 0 , & VAR10 , & VAR2 -> VAR14 ) ; for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR14 ; VAR11 ++ ) VAR3 [ VAR11 ] = VAR2 -> VAR7 . VAR15 >> VAR3 [ VAR11 ] ; if ( VAR2 -> VAR16 != VAR2 -> VAR7 . VAR15 ) { unsigned int VAR17 = VAR2 -> VAR16 ; for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR14 ; VAR11 ++ ) { if ( VAR17 <= VAR3 [ VAR11 ] ) { VAR3 [ VAR11 ] = VAR17 ; VAR2 -> VAR14 = VAR11 + 1 ; break ; } VAR17 -= VAR3 [ VAR11 ] ; } } } #1
340#340#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR2 -> VAR7 ; uint32_t VAR8 ; uint32_t VAR9 ; uint16_t VAR10 ; int VAR11 ; VAR2 -> VAR12 |= VAR13 ; FUN2 ( VAR7 , 4 ) ; VAR9 = FUN3 ( VAR7 ) ; FUN2 ( VAR7 , 4 ) ; FUN2 ( VAR7 , 4 ) ; VAR8 = FUN3 ( VAR7 ) ; if ( ( VAR8 != 4 ) && ( VAR8 != 2 ) ) FUN4 ( VAR2 , , VAR8 ) ; VAR4 -> VAR15 = FUN3 ( VAR7 ) ; VAR4 -> VAR16 = FUN3 ( VAR7 ) ; VAR4 -> VAR17 = FUN3 ( VAR7 ) ; VAR4 -> VAR18 = FUN5 ( VAR7 ) ; FUN2 ( VAR7 , 2 ) ; VAR4 -> VAR19 = FUN6 ( VAR4 -> VAR18 , sizeof ( VAR20 ) ) ; if ( ! VAR4 -> VAR19 ) { VAR11 = FUN7 ( VAR21 ) ; goto VAR22 ; } for ( VAR10 = 0 ; VAR10 < VAR4 -> VAR18 ; VAR10 ++ ) { VAR20 * VAR23 = & VAR4 -> VAR19 [ VAR10 ] ; VAR23 -> VAR24 = FUN5 ( VAR7 ) ; VAR23 -> VAR25 = FUN5 ( VAR7 ) ; VAR23 -> VAR26 = FUN3 ( VAR7 ) ; VAR23 -> VAR27 = FUN5 ( VAR7 ) ; VAR23 -> VAR28 = FUN5 ( VAR7 ) ; VAR23 -> VAR29 = VAR23 -> VAR27 * VAR23 -> VAR26 * VAR23 -> VAR25 ; VAR23 -> VAR30 = VAR31 * VAR23 -> VAR25 ; VAR23 -> VAR32 = 64 ; VAR23 -> VAR33 = FUN8 ( VAR23 -> VAR24 , VAR23 -> VAR27 ) ; VAR23 -> VAR34 = -1 ; VAR23 -> VAR35 = 0 ; VAR23 -> VAR36 = 0 ; if ( VAR23 -> VAR28 & VAR37 ) FUN9 ( VAR2 , VAR38 , , VAR23 -> VAR28 ) ; if ( ! VAR23 -> VAR25 || ! VAR23 -> VAR26 || VAR23 -> VAR25 >= VAR39 / VAR31 ) { FUN9 ( VAR2 , VAR40 , , VAR10 ) ; VAR11 = VAR42 ; goto VAR22 ; } } VAR4 -> VAR43 = FUN10 ( VAR7 ) ; VAR4 -> VAR44 = VAR9 - VAR4 -> VAR43 ; VAR4 -> VAR45 = VAR4 -> VAR18 + 1 ; return 0 ; VAR22 : FUN11 ( VAR2 ) ; return VAR11 ; } #1
341#341#"static VAR1 FUN1 ( VAR2 * * new , const char * VAR3 , VAR4 * VAR5 , unsigned int * VAR6 , VAR7 * VAR8 ) { char * VAR9 ; VAR2 * VAR10 ; VAR2 * VAR11 = VAR12 ; sharedslotdesc_t VAR13 ; const char * VAR14 ; VAR15 * VAR16 ; apr_status_t VAR17 ; if ( VAR18 == NULL ) { return VAR19 ; } if ( ! FUN2 ( VAR8 , VAR3 , & VAR14 , NULL ) ) { return VAR19 ; } FUN3 ( VAR20 , VAR21 , 0 , VAR22 , FUN4 ( 02301 ) VAR25VAR25 "" "" , VAR14 , * VAR5 , * VAR6 ) ; return VAR26 ; } "#1
342#342#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 = 14 - FUN2 ( VAR2 , VAR2 -> VAR4 , VAR5 ) ; FUN3 ( VAR2 -> VAR4 , VAR5 , VAR3 ) ; return VAR3 - 9 ; } #1
343#343#int FUN1 ( const VAR1 * VAR2 , unsigned char * VAR3 , int VAR4 ) { int VAR5 ; BN_ULONG VAR6 ; FUN2 ( VAR2 ) ; VAR5 = FUN3 ( VAR2 ) ; if ( VAR4 < VAR5 ) return -1 ; if ( VAR4 > VAR5 ) memset ( VAR3 + VAR5 , 0 , VAR4 - VAR5 ) ; VAR3 += VAR5 ; while ( VAR5 -- ) { VAR6 = VAR2 -> VAR7 [ VAR5 / VAR8 ] ; VAR3 -- ; * VAR3 = ( unsigned char ) ( VAR6 >> ( 8 * ( VAR5 % VAR8 ) ) ) & 0xff ; } return VAR4 ; } #1
344#344#"void FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 , int * VAR6 ) { int64_t VAR7 = VAR8 ; int VAR9 = 0 ; #ifdef VAR10 FUN2 ( VAR2 ) ; #endif if ( VAR2 -> VAR11 ) { if ( VAR2 -> VAR11 -> VAR5 != VAR8 ) VAR7 = VAR2 -> VAR11 -> VAR5 - VAR2 -> VAR12 ; } else { if ( VAR2 -> VAR13 != VAR8 ) VAR7 = VAR2 -> VAR13 - VAR2 -> VAR12 ; } if ( VAR5 ) { if ( VAR7 != VAR8 ) * VAR5 = FUN3 ( VAR2 -> VAR14 , VAR7 ) ; else * VAR5 = VAR8 ; } if ( VAR2 -> VAR12 >= VAR3 ) { VAR9 += VAR3 ; VAR2 -> VAR12 -= VAR3 ; } while ( VAR9 < VAR3 && VAR2 -> VAR11 ) { VAR9 += VAR2 -> VAR11 -> VAR6 ; FUN4 ( VAR2 ) ; } VAR2 -> VAR15 -= VAR9 ; if ( VAR9 < VAR3 && VAR2 -> VAR15 > 0 ) { int VAR16 = FUN5 ( VAR2 -> VAR15 , VAR3 - VAR9 ) ; VAR9 += VAR16 ; VAR2 -> VAR15 -= VAR16 ; } if ( VAR9 > VAR3 ) FUN6 ( VAR2 -> VAR14 , VAR17 , "" "" ) ; if ( VAR6 ) * VAR6 = FUN3 ( VAR2 -> VAR14 , VAR9 ) ; } "#1
345#345#unsigned char * FUN1 ( const char * VAR1 , int VAR2 , unsigned char * * VAR3 , int * VAR4 ) { int VAR5 , VAR6 ; unsigned char * VAR7 ; if ( VAR2 == -1 ) VAR2 = strlen ( VAR1 ) ; VAR5 = VAR2 * 2 + 2 ; if ( ( VAR7 = FUN2 ( VAR5 ) ) == NULL ) return NULL ; for ( VAR6 = 0 ; VAR6 < VAR5 - 2 ; VAR6 += 2 ) { VAR7 [ VAR6 ] = 0 ; VAR7 [ VAR6 + 1 ] = VAR1 [ VAR6 >> 1 ] ; } VAR7 [ VAR5 - 2 ] = 0 ; VAR7 [ VAR5 - 1 ] = 0 ; if ( VAR4 ) * VAR4 = VAR5 ; if ( VAR3 ) * VAR3 = VAR7 ; return VAR7 ; } #1
346#346#static int FUN1 ( VAR1 * VAR2 ) { const VAR3 * VAR4 = VAR2 -> VAR5 . VAR4 ; int VAR6 = ( VAR7 && VAR2 -> VAR8 -> VAR9 & VAR10 ) ? VAR2 -> VAR8 -> VAR11 : 1 ; int VAR12 , VAR13 ; FUN2 ( VAR2 -> VAR8 , VAR4 -> VAR14 ) ; FUN3 ( VAR2 -> VAR8 -> VAR15 , & VAR2 -> VAR16 , & VAR2 -> VAR17 ) ; if ( VAR4 -> VAR18 ) { int64_t VAR19 = VAR4 -> VAR20 ; if ( VAR2 -> VAR21 < 44U ) VAR19 *= 2 ; FUN4 ( & VAR2 -> VAR8 -> VAR22 . VAR19 , & VAR2 -> VAR8 -> VAR22 . VAR23 , VAR4 -> VAR24 , VAR19 , 1 << 30 ) ; } FUN5 ( VAR2 ) ; VAR2 -> VAR25 = 0 ; VAR2 -> VAR26 = 1 ; FUN6 ( VAR2 ) ; VAR13 = FUN7 ( VAR2 ) ; if ( VAR13 < 0 ) { FUN8 ( VAR2 -> VAR8 , VAR27 , , VAR4 -> VAR28 ) ; return VAR29 ; } VAR2 -> VAR8 -> VAR30 = VAR4 -> VAR28 ; VAR2 -> VAR31 = VAR4 -> VAR28 > 8 ; VAR2 -> VAR32 = VAR4 -> VAR32 ; VAR2 -> VAR28 = VAR4 -> VAR28 ; FUN9 ( & VAR2 -> VAR33 , VAR4 -> VAR28 , VAR4 -> VAR32 ) ; FUN10 ( & VAR2 -> VAR34 , VAR4 -> VAR35 ) ; FUN11 ( & VAR2 -> VAR36 , VAR4 -> VAR28 ) ; FUN12 ( & VAR2 -> VAR37 , VAR2 -> VAR8 -> VAR38 , VAR4 -> VAR28 , VAR4 -> VAR32 ) ; FUN13 ( & VAR2 -> VAR39 , VAR4 -> VAR28 ) ; if ( VAR6 > VAR40 || ( VAR6 > VAR2 -> VAR41 && VAR2 -> VAR41 ) ) { int VAR42 ; if ( VAR2 -> VAR41 ) VAR42 = FUN14 ( VAR40 , VAR2 -> VAR41 ) ; else VAR42 = VAR40 ; FUN8 ( VAR2 -> VAR8 , VAR43 , , VAR6 , VAR42 ) ; VAR6 = VAR42 ; } VAR2 -> VAR44 = VAR6 ; if ( ! VAR7 || ! ( VAR2 -> VAR8 -> VAR9 & VAR10 ) ) { VAR13 = FUN15 ( VAR2 , & VAR2 -> VAR45 [ 0 ] ) ; if ( VAR13 < 0 ) { FUN8 ( VAR2 -> VAR8 , VAR27 , ) ; return VAR13 ; } } } VAR2 -> VAR52 = 1 ; return 0 ; } #0
347#347#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 ; FUN2 ( VAR4 ) ; FUN3 ( & VAR4 -> VAR7 ) ; for ( VAR6 = 0 ; VAR6 < VAR4 -> VAR8 ; VAR6 ++ ) { FUN3 ( & VAR4 -> VAR9 [ VAR6 ] ) ; } FUN3 ( & VAR4 -> VAR10 ) ; FUN3 ( & VAR4 -> VAR11 ) ; FUN3 ( & VAR4 -> VAR9 ) ; FUN3 ( & VAR4 -> VAR12 ) ; FUN4 ( & VAR4 -> VAR13 ) ; FUN4 ( & VAR4 -> VAR14 ) ; for ( VAR6 = 0 ; VAR6 < FUN5 ( VAR4 -> VAR15 ) ; VAR6 ++ ) { FUN6 ( VAR4 , & VAR4 -> VAR15 [ VAR6 ] , ~ 0 ) ; FUN4 ( & VAR4 -> VAR15 [ VAR6 ] . VAR16 ) ; } for ( VAR6 = 0 ; VAR6 < FUN5 ( VAR4 -> VAR17 ) ; VAR6 ++ ) FUN7 ( & VAR4 -> VAR17 [ VAR6 ] ) ; for ( VAR6 = 0 ; VAR6 < FUN5 ( VAR4 -> VAR18 ) ; VAR6 ++ ) FUN7 ( & VAR4 -> VAR18 [ VAR6 ] ) ; for ( VAR6 = 0 ; VAR6 < FUN5 ( VAR4 -> VAR19 ) ; VAR6 ++ ) FUN7 ( & VAR4 -> VAR19 [ VAR6 ] ) ; VAR4 -> VAR20 = NULL ; VAR4 -> VAR21 = NULL ; VAR4 -> VAR22 = NULL ; FUN7 ( & VAR4 -> VAR23 ) ; FUN3 ( & VAR4 -> VAR24 . VAR25 ) ; FUN3 ( & VAR4 -> VAR24 . VAR26 ) ; FUN3 ( & VAR4 -> VAR24 . VAR27 ) ; for ( VAR6 = 1 ; VAR6 < VAR4 -> VAR28 ; VAR6 ++ ) { VAR29 * VAR30 = VAR4 -> VAR31 [ VAR6 ] ; if ( VAR30 ) { FUN3 ( & VAR4 -> VAR31 [ VAR6 ] ) ; FUN3 ( & VAR4 -> VAR32 [ VAR6 ] ) ; } } if ( VAR4 -> VAR33 == VAR4 -> VAR31 [ 0 ] ) VAR4 -> VAR33 = NULL ; FUN3 ( & VAR4 -> VAR31 [ 0 ] ) ; for ( VAR6 = 0 ; VAR6 < VAR4 -> VAR8 ; VAR6 ++ ) FUN3 ( & VAR4 -> VAR34 [ VAR6 ] . VAR35 ) ; FUN3 ( & VAR4 -> VAR34 ) ; VAR4 -> VAR8 = 0 ; return 0 ; } #0
348#348#int FUN1 ( const VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { int VAR6 , VAR7 , VAR8 ; int64_t VAR9 ; VAR6 = - 1 ; VAR7 = VAR3 ; if ( VAR7 && VAR2 [ VAR7 - 1 ] . VAR9 < VAR4 ) VAR6 = VAR7 - 1 ; while ( VAR7 - VAR6 > 1 ) { VAR8 = ( VAR6 + VAR7 ) >> 1 ; VAR9 = VAR2 [ VAR8 ] . VAR9 ; if ( VAR9 >= VAR4 ) VAR7 = VAR8 ; if ( VAR9 <= VAR4 ) VAR6 = VAR8 ; } VAR8 = ( VAR5 & VAR10 ) ? VAR6 : VAR7 ; if ( ! ( VAR5 & VAR11 ) ) { while ( VAR8 >= 0 && VAR8 < VAR3 && ! ( VAR2 [ VAR8 ] . VAR5 & VAR12 ) ) { VAR8 += ( VAR5 & VAR10 ) ? -1 : 1 ; } } if ( VAR8 == VAR3 ) return -1 ; return VAR8 ; } #1
349#349#void FUN1 ( VAR1 * VAR2 ) { const int VAR3 = VAR2 -> VAR4 . VAR5 . VAR3 [ 0 ] ; const int VAR6 = VAR2 -> VAR4 . VAR5 . VAR3 [ 1 ] ; const int VAR7 = 4 - VAR2 -> VAR8 -> VAR9 ; VAR2 -> VAR10 [ 0 ] = VAR2 -> VAR11 * ( VAR2 -> VAR12 * 2 ) - 2 + VAR2 -> VAR13 * 2 ; VAR2 -> VAR10 [ 1 ] = VAR2 -> VAR11 * ( VAR2 -> VAR12 * 2 ) - 1 + VAR2 -> VAR13 * 2 ; VAR2 -> VAR10 [ 2 ] = VAR2 -> VAR11 * ( VAR2 -> VAR12 * 2 + 1 ) - 2 + VAR2 -> VAR13 * 2 ; VAR2 -> VAR10 [ 3 ] = VAR2 -> VAR11 * ( VAR2 -> VAR12 * 2 + 1 ) - 1 + VAR2 -> VAR13 * 2 ; VAR2 -> VAR10 [ 4 ] = VAR2 -> VAR14 * ( VAR2 -> VAR12 + 1 ) + VAR2 -> VAR11 * VAR2 -> VAR15 * 2 + VAR2 -> VAR13 - 1 ; VAR2 -> VAR10 [ 5 ] = VAR2 -> VAR14 * ( VAR2 -> VAR12 + VAR2 -> VAR15 + 2 ) + VAR2 -> VAR11 * VAR2 -> VAR15 * 2 + VAR2 -> VAR13 - 1 ; VAR2 -> VAR16 [ 0 ] = VAR2 -> VAR4 . VAR5 . VAR17 [ 0 ] + ( ( VAR2 -> VAR13 - 1 ) << VAR7 ) ; VAR2 -> VAR16 [ 1 ] = VAR2 -> VAR4 . VAR5 . VAR17 [ 1 ] + ( ( VAR2 -> VAR13 - 1 ) << ( VAR7 - VAR2 -> VAR18 ) ) ; VAR2 -> VAR16 [ 2 ] = VAR2 -> VAR4 . VAR5 . VAR17 [ 2 ] + ( ( VAR2 -> VAR13 - 1 ) << ( VAR7 - VAR2 -> VAR18 ) ) ; if ( ! ( VAR2 -> VAR19 == VAR20 && VAR2 -> VAR8 -> VAR21 && VAR2 -> VAR22 == VAR23 ) ) { if ( VAR2 -> VAR22 == VAR23 ) { VAR2 -> VAR16 [ 0 ] += VAR2 -> VAR12 * VAR3 << VAR7 ; VAR2 -> VAR16 [ 1 ] += VAR2 -> VAR12 * VAR6 << ( VAR7 - VAR2 -> VAR24 ) ; VAR2 -> VAR16 [ 2 ] += VAR2 -> VAR12 * VAR6 << ( VAR7 - VAR2 -> VAR24 ) ; } else { VAR2 -> VAR16 [ 0 ] += ( VAR2 -> VAR12 >> 1 ) * VAR3 << VAR7 ; VAR2 -> VAR16 [ 1 ] += ( VAR2 -> VAR12 >> 1 ) * VAR6 << ( VAR7 - VAR2 -> VAR24 ) ; VAR2 -> VAR16 [ 2 ] += ( VAR2 -> VAR12 >> 1 ) * VAR6 << ( VAR7 - VAR2 -> VAR24 ) ; FUN2 ( ( VAR2 -> VAR12 & 1 ) == ( VAR2 -> VAR22 == VAR25 ) ) ; } } } #1
350#350#"VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 , off_t VAR6 , VAR7 * VAR8 ) { VAR9 * VAR10 ; size_t VAR11 ; ssize_t VAR12 , VAR13 ; ngx_array_t VAR14 ; struct VAR15 * VAR16 , VAR17 [ VAR18 ] ; if ( VAR5 -> VAR19 == NULL ) { return FUN2 ( VAR3 , VAR5 -> VAR20 -> VAR21 , ( VAR22 ) ( VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ) , VAR6 ) ; } VAR12 = 0 ; VAR14 . VAR24 = VAR17 ; VAR14 . VAR11 = sizeof ( struct VAR15 ) ; VAR14 . VAR25 = VAR18 ; VAR14 . VAR8 = VAR8 ; do { VAR10 = NULL ; VAR16 = NULL ; VAR11 = 0 ; VAR14 . VAR26 = 0 ; while ( VAR5 && VAR14 . VAR26 < VAR27 ) { if ( VAR10 == VAR5 -> VAR20 -> VAR21 ) { VAR16 -> VAR28 += VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; } else { VAR16 = FUN3 ( & VAR14 ) ; if ( VAR16 == NULL ) { return VAR29 ; } VAR16 -> VAR30 = ( void * ) VAR5 -> VAR20 -> VAR21 ; VAR16 -> VAR28 = VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; } VAR11 += VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; VAR10 = VAR5 -> VAR20 -> VAR23 ; VAR5 = VAR5 -> VAR19 ; } if ( VAR14 . VAR26 == 1 ) { VAR16 = VAR14 . VAR24 ; VAR13 = FUN2 ( VAR3 , ( VAR9 * ) VAR16 [ 0 ] . VAR30 , VAR16 [ 0 ] . VAR28 , VAR6 ) ; if ( VAR13 == VAR29 ) { return VAR13 ; } return VAR12 + VAR13 ; } if ( VAR3 -> VAR31 != VAR6 ) { if ( FUN4 ( VAR3 -> VAR32 , VAR6 , VAR33 ) == -1 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , VAR36 , , VAR3 -> VAR38 . VAR39 ) ; return VAR29 ; } VAR3 -> VAR31 = VAR6 ; } VAR13 = FUN6 ( VAR3 -> VAR32 , VAR14 . VAR24 , VAR14 . VAR26 ) ; if ( VAR13 == -1 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , VAR36 , , VAR3 -> VAR38 . VAR39 ) ; return VAR29 ; } if ( ( VAR22 ) VAR13 != VAR11 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , 0 , , VAR3 -> VAR38 . VAR39 , VAR13 , VAR11 ) ; return VAR29 ; } FUN7 ( VAR40 , VAR3 -> VAR35 , 0 , "" "" , VAR3 -> VAR32 , VAR13 ) ; VAR3 -> VAR31 += VAR13 ; VAR3 -> VAR6 += VAR13 ; VAR6 += VAR13 ; VAR12 += VAR13 ; } while ( VAR5 ) ; return VAR12 ; } "#0
351#351#static unsigned int FUN1 ( VAR1 * VAR2 , struct VAR3 * VAR4 , VAR5 * * VAR6 ) { int VAR7 , VAR8 , VAR9 , VAR10 ; unsigned char * VAR11 ; VAR9 = VAR4 -> VAR9 [ 0 ] + VAR4 -> VAR9 [ 1 ] + VAR4 -> VAR9 [ 2 ] ; VAR10 = VAR9 + VAR9 / 255 + 64 ; VAR11 = * VAR6 = FUN2 ( NULL , VAR10 ) ; memset ( * VAR6 , ' ' , VAR10 ) ; VAR11 [ 0 ] = 2 ; VAR8 = 1 ; VAR8 += FUN3 ( & VAR11 [ VAR8 ] , VAR4 -> VAR9 [ 0 ] ) ; VAR8 += FUN3 ( & VAR11 [ VAR8 ] , VAR4 -> VAR9 [ 1 ] ) ; for ( VAR7 = 0 ; VAR7 < 3 ; VAR7 ++ ) { memcpy ( & VAR11 [ VAR8 ] , VAR4 -> VAR12 [ VAR7 ] , VAR4 -> VAR9 [ VAR7 ] ) ; VAR8 += VAR4 -> VAR9 [ VAR7 ] ; FUN4 ( & VAR4 -> VAR12 [ VAR7 ] ) ; } * VAR6 = FUN2 ( * VAR6 , VAR8 + VAR13 ) ; return VAR8 ; } #1
352#352#static inline void FUN1 ( VAR1 * VAR2 ) { const int VAR3 = 8 >> VAR2 -> VAR4 -> VAR5 ; VAR2 -> VAR6 [ 0 ] += 2 ; VAR2 -> VAR6 [ 1 ] += 2 ; VAR2 -> VAR6 [ 2 ] += 2 ; VAR2 -> VAR6 [ 3 ] += 2 ; VAR2 -> VAR6 [ 4 ] ++ ; VAR2 -> VAR6 [ 5 ] ++ ; VAR2 -> VAR7 [ 0 ] += 2 * VAR3 ; VAR2 -> VAR7 [ 1 ] += VAR3 ; VAR2 -> VAR7 [ 2 ] += VAR3 ; } #1
353#353#static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { VAR6 * VAR7 = FUN2 ( VAR5 -> VAR8 -> VAR9 , & VAR10 ) ; VAR11 * VAR12 = VAR3 -> VAR13 ; VAR14 * VAR15 = ( VAR14 * ) VAR12 -> VAR16 ; apr_status_t VAR17 ; if ( VAR18 ) { apr_status_t VAR19 = FUN3 ( VAR18 ) ; if ( VAR19 != VAR20 ) { FUN4 ( VAR21 , VAR22 , VAR19 , VAR5 , FUN5 ( 02384 ) , VAR12 -> VAR23 ) ; FUN6 ( VAR15 -> VAR24 ) ; VAR15 -> VAR24 = NULL ; return VAR19 ; } } if ( VAR17 != VAR20 ) { FUN4 ( VAR21 , VAR32 , VAR17 , VAR5 , FUN5 ( 02386 ) , VAR15 -> VAR35 , ( VAR36 ) FUN9 ( VAR15 -> VAR28 - VAR5 -> VAR37 ) ) ; FUN6 ( VAR15 -> VAR24 ) ; VAR15 -> VAR24 = NULL ; return VAR20 ; VAR33 : if ( VAR18 ) { apr_status_t VAR19 = FUN3 ( VAR18 ) ; if ( VAR19 != VAR20 ) { FUN4 ( VAR21 , VAR22 , VAR19 , VAR5 , FUN5 ( 02388 ) , VAR12 -> VAR23 ) ; } } FUN6 ( VAR15 -> VAR24 ) ; VAR15 -> VAR24 = NULL ; return VAR17 ; } #0
354#354#int FUN1 ( const VAR1 * VAR2 , const VAR1 * VAR3 ) { int VAR4 ; if ( ! VAR2 -> VAR5 || VAR2 -> VAR6 ) { VAR4 = FUN2 ( ( VAR1 * ) VAR2 , NULL ) ; if ( VAR4 < 0 ) return -2 ; } if ( ! VAR3 -> VAR5 || VAR3 -> VAR6 ) { VAR4 = FUN2 ( ( VAR1 * ) VAR3 , NULL ) ; if ( VAR4 < 0 ) return -2 ; } VAR4 = VAR2 -> VAR7 - VAR3 -> VAR7 ; if ( VAR4 != 0 || VAR2 -> VAR7 == 0 ) return VAR4 ; return memcmp ( VAR2 -> VAR5 , VAR3 -> VAR5 , VAR2 -> VAR7 ) ; } #1
355#355#"static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 ; if ( VAR2 -> VAR7 <= 8 ) { VAR2 -> VAR8 = VAR9 ; } else if ( VAR2 -> VAR7 <= 32 ) { VAR2 -> VAR8 = VAR10 ; } else { return VAR11 ; } VAR4 -> VAR12 = VAR2 -> VAR13 >> 3 ; VAR4 -> VAR14 = FUN2 ( VAR4 -> VAR12 + VAR15 ) ; if ( ! VAR4 -> VAR14 ) return FUN3 ( VAR16 ) ; VAR4 -> VAR17 . VAR18 = 1 ; if ( ( VAR6 = VAR2 -> FUN4 ( VAR2 , & VAR4 -> VAR17 ) < 0 ) ) { FUN5 ( VAR2 , VAR19 , "" "" ) ; return VAR6 ; } return VAR2 -> VAR7 <= 8 ? FUN6 ( VAR2 , ( VAR20 * ) VAR4 -> VAR17 . VAR21 [ 1 ] ) : 0 ; } "#0
356#356#int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , int VAR4 ) { int VAR5 , VAR6 ; VAR6 = VAR4 ; while ( VAR4 > 0 ) { VAR5 = VAR2 -> VAR7 - VAR2 -> VAR8 ; if ( VAR5 > VAR4 ) VAR5 = VAR4 ; if ( VAR5 == 0 || VAR2 -> VAR9 ) { if ( ( VAR2 -> VAR10 || VAR4 > VAR2 -> VAR11 ) && ! VAR2 -> VAR12 ) { if ( VAR2 -> VAR13 ) VAR5 = VAR2 -> FUN2 ( VAR2 -> VAR14 , VAR3 , VAR4 ) ; if ( VAR5 <= 0 ) { VAR2 -> VAR15 = 1 ; if ( VAR5 < 0 ) VAR2 -> VAR16 = VAR5 ; break ; } else { VAR2 -> VAR17 += VAR5 ; VAR2 -> VAR18 += VAR5 ; VAR4 -= VAR5 ; VAR3 += VAR5 ; VAR2 -> VAR8 = VAR2 -> VAR19 ; VAR2 -> VAR7 = VAR2 -> VAR19 ; } } else { FUN3 ( VAR2 ) ; VAR5 = VAR2 -> VAR7 - VAR2 -> VAR8 ; if ( VAR5 == 0 ) break ; } } else { memcpy ( VAR3 , VAR2 -> VAR8 , VAR5 ) ; VAR3 += VAR5 ; VAR2 -> VAR8 += VAR5 ; VAR4 -= VAR5 ; } } if ( VAR6 == VAR4 ) { if ( VAR2 -> VAR16 ) return VAR2 -> VAR16 ; if ( FUN4 ( VAR2 ) ) return VAR20 ; } return VAR6 - VAR4 ; } #1
357#357#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 -> VAR8 ; const int VAR9 = VAR4 -> VAR10 -> VAR11 ; int VAR12 = FUN2 ( VAR9 * VAR6 -> VAR13 * 2 , 1 ) ; VAR1 * const VAR14 = VAR2 -> VAR7 -> VAR15 [ 0 ] ; VAR3 * VAR16 = FUN3 ( VAR14 , VAR17 , VAR12 ) ; int VAR18 ; if ( ! VAR16 ) return FUN4 ( VAR19 ) ; FUN5 ( VAR16 , VAR4 ) ; VAR16 -> VAR20 = VAR14 -> VAR20 ; VAR16 -> VAR10 -> VAR21 = VAR14 -> VAR21 ; VAR16 -> VAR10 -> VAR22 = VAR14 -> VAR22 ; if ( VAR4 -> VAR23 != VAR24 ) { int64_t VAR25 = FUN6 ( VAR4 -> VAR23 , VAR2 -> VAR26 . VAR27 * ( VAR28 ) VAR14 -> VAR22 * VAR2 -> VAR22 , VAR2 -> VAR26 . VAR29 ) ; int64_t VAR30 = FUN7 ( VAR6 -> VAR31 , VAR25 ) ; VAR6 -> VAR32 = VAR16 -> VAR23 = ( VAR30 + VAR2 -> VAR22 / 2 ) / VAR2 -> VAR22 ; } else { VAR16 -> VAR23 = VAR24 ; } VAR12 = FUN8 ( VAR6 -> VAR31 , VAR16 -> VAR33 , VAR12 , ( void * ) VAR4 -> VAR33 , VAR9 ) ; if ( VAR12 <= 0 ) { FUN9 ( VAR16 ) ; FUN9 ( VAR4 ) ; return 0 ; } VAR16 -> VAR10 -> VAR11 = VAR12 ; VAR18 = FUN10 ( VAR14 , VAR16 ) ; VAR6 -> VAR34 = 1 ; FUN9 ( VAR4 ) ; return VAR18 ; } #1
358#358#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { int VAR6 ; int VAR7 = 0 ; int VAR8 = VAR2 -> VAR9 . VAR10 [ 0 ] ; unsigned char VAR11 , VAR12 ; unsigned char * VAR13 = VAR2 -> VAR9 . VAR14 [ 0 ] ; int VAR15 = VAR2 -> VAR9 . VAR10 [ 0 ] * VAR2 -> VAR16 -> VAR17 ; int VAR18 ; while ( VAR5 ) { FUN2 ( 2 ) ; VAR18 = VAR2 -> VAR19 [ VAR3 ++ ] ; VAR6 = ( signed char ) VAR2 -> VAR19 [ VAR3 ++ ] ; if ( VAR6 == 0 ) break ; if ( VAR18 & 0x80 ) { VAR5 -- ; VAR4 += VAR8 ; VAR7 = VAR4 + 2 * ( VAR18 & 0x7f ) ; } else VAR7 += 2 * VAR18 ; FUN3 ( 0 ) ; if ( VAR6 < 0 ) { VAR6 = - VAR6 ; FUN2 ( 2 ) ; VAR11 = VAR2 -> VAR19 [ VAR3 ++ ] ; VAR12 = VAR2 -> VAR19 [ VAR3 ++ ] ; FUN3 ( VAR6 * 2 ) ; while ( VAR6 -- ) { VAR13 [ VAR7 ++ ] = VAR11 ; VAR13 [ VAR7 ++ ] = VAR12 ; } } else { VAR6 *= 2 ; FUN2 ( VAR6 ) ; FUN3 ( VAR6 ) ; while ( VAR6 -- ) VAR13 [ VAR7 ++ ] = VAR2 -> VAR19 [ VAR3 ++ ] ; } } } #1
359#359#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; int VAR14 ; unsigned char * VAR15 = ( unsigned char * ) VAR3 ; if ( VAR9 < 16 ) { FUN2 ( VAR2 , VAR16 , , VAR14 ) ; return FUN3 ( VAR20 ) ; } VAR8 += 16 ; VAR9 -= 16 ; if ( VAR14 == VAR17 ) { * VAR4 = FUN4 ( VAR12 , VAR15 , VAR8 , 0 , VAR9 ) ; } else if ( VAR14 == VAR21 ) { uint32_t VAR22 = FUN5 ( VAR8 ) ; int VAR23 = FUN6 ( VAR22 ) ; VAR8 += 4 ; VAR9 -= 4 ; if ( * VAR4 < ( VAR12 -> VAR24 * VAR23 + VAR9 ) * 2 ) return -1 ; * VAR4 = FUN4 ( VAR12 , VAR15 , VAR8 , VAR23 , VAR9 ) ; } else if ( VAR14 == VAR18 ) { * VAR4 = FUN4 ( VAR12 , VAR15 , VAR8 , 1 , 0 ) ; } return VAR6 -> VAR10 ; } #1
360#360#"static int FUN1 ( VAR1 * VAR2 , const char * VAR3 , int VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 , VAR9 ; FUN2 ( VAR3 , "" "" , & VAR3 ) ; VAR6 -> VAR10 . VAR11 = VAR12 ; FUN3 ( VAR6 -> VAR10 . VAR13 , VAR3 , sizeof ( VAR6 -> VAR10 . VAR13 ) ) ; if ( ( VAR8 = FUN4 ( VAR12 , VAR6 -> VAR14 , 0 ) ) < 0 ) return FUN5 ( ) ; if ( VAR6 -> VAR15 ) { VAR9 = FUN6 ( VAR8 , ( struct VAR16 * ) & VAR6 -> VAR10 , sizeof ( VAR6 -> VAR10 ) , VAR6 -> VAR17 , VAR2 ) ; if ( VAR9 < 0 ) goto VAR18 ; VAR8 = VAR9 ; } else { VAR9 = FUN7 ( VAR8 , ( struct VAR16 * ) & VAR6 -> VAR10 , sizeof ( VAR6 -> VAR10 ) , VAR6 -> VAR17 , VAR2 , 0 ) ; if ( VAR9 < 0 ) goto VAR18 ; } VAR6 -> VAR8 = VAR8 ; return 0 ; VAR18 : if ( VAR6 -> VAR15 && FUN8 ( VAR9 ) != VAR19 ) unlink ( VAR6 -> VAR10 . VAR13 ) ; if ( VAR8 >= 0 ) FUN9 ( VAR8 ) ; return VAR9 ; } "#0
361#361#VAR1 FUN1 ( char * VAR2 , const char * VAR3 , size_t VAR4 ) { size_t VAR5 = 0 ; for ( ; VAR4 > 0 && * VAR2 ; VAR4 -- , VAR2 ++ ) VAR5 ++ ; return VAR5 + FUN2 ( VAR2 , VAR3 , VAR4 ) ; } #1
362#362#int FUN1 ( int argc , char * * argv ) { VAR1 * VAR2 = NULL , * VAR3 = NULL ; VAR4 * VAR5 = NULL ; int VAR6 = 0 , VAR7 = 0 , VAR8 = 1 ; OPTION_CHOICE VAR9 ; char * VAR10 = NULL , * VAR11 = NULL , * VAR12 ; VAR12 = FUN2 ( argc , argv , VAR13 ) ; while ( ( VAR9 = FUN3 ( ) ) != VAR14 ) { switch ( VAR9 ) { case VAR14 : case VAR15 : FUN4 ( VAR16 , ) ; FUN13 ( VAR16 ) ; goto VAR17 ; } if ( ! VAR7 ) FUN14 ( VAR3 , VAR5 ) ; if ( VAR6 ) FUN15 ( VAR3 , VAR5 , 0 , NULL ) ; VAR8 = 0 ; VAR17 : FUN16 ( VAR5 ) ; FUN17 ( VAR3 ) ; FUN18 ( VAR2 ) ; return VAR8 ; } #0
363#363#static int FUN1 ( VAR1 * VAR2 ) { int64_t VAR3 ; uint32_t VAR4 ; int VAR5 = 0 ; VAR3 = 0 ; for ( ; ; ) { if ( ( VAR3 + 8 ) > ( unsigned int ) VAR2 -> VAR6 ) return VAR5 ; VAR4 = FUN2 ( VAR2 -> VAR7 + VAR3 + 4 ) ; switch ( VAR4 ) { case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : return VAR8 ; case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : return VAR8 - 5 ; case FUN3 ( 0x82 , 0x82 , 0x7f , 0x7d ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : case FUN3 ( ' ' , ' ' , ' ' , ' ' ) : VAR3 = FUN4 ( VAR2 -> VAR7 + VAR3 ) + VAR3 ; VAR5 = VAR8 - 50 ; break ; default : return VAR5 ; } } } #0
364#364#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 ) { int VAR6 , VAR7 = 0 ; VAR8 * VAR9 , VAR10 [ 82 ] ; AVBPrint VAR11 ; VAR12 * VAR13 ; while ( ( VAR10 [ VAR7 ++ ] = FUN2 ( & VAR2 -> VAR14 ) ) && VAR7 < 81 ) ; if ( VAR7 > 80 ) { FUN3 ( VAR2 -> VAR15 , VAR16 , ) ; return VAR17 ; } VAR3 = FUN4 ( VAR3 - 1 , 0 ) ; if ( ( VAR6 = FUN5 ( & VAR11 , VAR2 -> VAR14 . VAR18 , VAR2 -> VAR14 . VAR18 + VAR3 ) ) < 0 ) return VAR6 ; FUN6 ( & VAR11 , ( char * * ) & VAR9 ) ; if ( ! VAR9 ) return FUN7 ( VAR19 ) ; VAR13 = FUN8 ( VAR5 , VAR20 , VAR11 . VAR21 ) ; if ( ! VAR13 ) { FUN9 ( VAR9 ) ; return FUN7 ( VAR19 ) ; } FUN10 ( & VAR13 -> VAR22 , "" "" , VAR10 , 0 ) ; memcpy ( VAR13 -> VAR9 , VAR9 , VAR11 . VAR21 ) ; FUN9 ( VAR9 ) ; FUN11 ( & VAR2 -> VAR14 , VAR3 + 4 ) ; return 0 ; } "#0
365#365#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR3 * VAR5 , int * VAR6 , int VAR7 , int VAR8 , int VAR9 ) { if ( VAR2 -> VAR10 == 1 && VAR2 -> VAR11 == 1 ) { int VAR12 = VAR2 -> VAR12 ; int VAR13 = VAR2 -> VAR13 ; int64_t VAR14 = ( 1LL << 32 ) * VAR2 -> VAR13 / VAR2 -> VAR15 + ( 1LL << 32 ) * VAR12 ; int64_t VAR16 = ( 1LL << 32 ) * VAR2 -> VAR17 / VAR2 -> VAR15 ; int VAR18 = ( VAR7 * ( VAR19 ) VAR2 -> VAR15 - VAR13 + VAR2 -> VAR17 - 1 ) / VAR2 -> VAR17 ; VAR8 = FUN2 ( FUN3 ( VAR8 , VAR18 ) , 0 ) ; if ( VAR8 > 0 ) VAR2 -> VAR20 . FUN4 ( VAR4 , VAR5 , VAR8 , VAR14 , VAR16 ) ; VAR12 += VAR8 * VAR2 -> VAR21 ; VAR12 += ( VAR13 + VAR8 * ( VAR19 ) VAR2 -> VAR22 ) / VAR2 -> VAR15 ; FUN5 ( VAR12 >= 0 ) ; * VAR6 = VAR12 ; if ( VAR9 ) { VAR2 -> VAR13 = ( VAR13 + VAR8 * ( VAR19 ) VAR2 -> VAR22 ) % VAR2 -> VAR15 ; VAR2 -> VAR12 = 0 ; } } else { int64_t VAR23 = ( 1LL + VAR7 - VAR2 -> VAR10 ) * VAR2 -> VAR11 ; int64_t VAR24 = ( VAR23 - VAR2 -> VAR12 ) * VAR2 -> VAR15 - VAR2 -> VAR13 ; int VAR25 = ( VAR24 + VAR2 -> VAR17 - 1 ) / VAR2 -> VAR17 ; VAR8 = FUN2 ( FUN3 ( VAR8 , VAR25 ) , 0 ) ; if ( VAR8 > 0 ) { if ( VAR2 -> VAR26 && ( VAR2 -> VAR13 || VAR2 -> VAR22 ) ) * VAR6 = VAR2 -> VAR20 . FUN6 ( VAR2 , VAR4 , VAR5 , VAR8 , VAR9 ) ; else * VAR6 = VAR2 -> VAR20 . FUN7 ( VAR2 , VAR4 , VAR5 , VAR8 , VAR9 ) ; } else { * VAR6 = 0 ; } } return VAR8 ; } #1
366#366#static int FUN1 ( VAR1 * VAR2 , const char * VAR3 , size_t VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = FUN2 ( VAR2 ) ; if ( VAR8 == NULL ) return 0 ; if ( VAR8 -> VAR9 == NULL || * VAR8 -> VAR9 == ' ' ) { if ( VAR4 > 0 ) VAR8 -> VAR10 = ( VAR3 [ VAR4 - 1 ] == ' ' ) ; return FUN3 ( FUN4 ( VAR2 ) , VAR3 , VAR4 , VAR6 ) ; } * VAR6 = 0 ; while ( VAR4 > 0 ) { size_t VAR11 ; char VAR12 ; if ( VAR8 -> VAR10 ) { size_t VAR13 ; if ( ! FUN3 ( FUN4 ( VAR2 ) , VAR8 -> VAR9 , strlen ( VAR8 -> VAR9 ) , & VAR13 ) ) return 0 ; VAR8 -> VAR10 = 0 ; } for ( VAR11 = 0 , VAR12 = ' ' ; VAR11 < VAR4 && ( VAR12 = VAR3 [ VAR11 ] ) != ' ' ; VAR11 ++ ) continue ; if ( VAR12 == ' ' ) VAR11 ++ ; while ( VAR11 > 0 ) { size_t VAR14 = 0 ; if ( ! FUN3 ( FUN4 ( VAR2 ) , VAR3 , VAR11 , & VAR14 ) ) return 0 ; VAR3 += VAR14 ; VAR4 -= VAR14 ; * VAR6 += VAR14 ; VAR11 -= VAR14 ; } if ( VAR12 == ' ' ) VAR8 -> VAR10 = 1 ; } return 1 ; } #0
367#367#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , int VAR9 , int VAR10 , int VAR11 ) { int VAR12 = VAR8 -> VAR13 , VAR14 = 2 , VAR15 = VAR8 -> VAR16 - 1 , VAR17 ; int VAR18 = 0 ; int VAR19 = VAR4 -> VAR20 & VAR21 ; int VAR22 = VAR4 -> VAR20 & VAR23 ; FUN2 ( VAR9 <= VAR24 ) ; FUN2 ( VAR10 <= VAR25 ) ; for ( VAR17 = 0 ; VAR17 < VAR10 ; VAR17 ++ ) memset ( VAR6 -> VAR26 [ VAR17 ] , 0 , VAR9 * sizeof ( * * VAR6 -> VAR26 ) ) ; if ( ! VAR8 -> VAR27 ) return 0 ; for ( VAR17 = 0 ; VAR17 < VAR10 + 2 ; VAR17 ++ ) memset ( VAR6 -> VAR28 [ VAR17 ] , 0 , ( VAR9 + 2 ) * sizeof ( * * VAR6 -> VAR28 ) ) ; VAR8 -> VAR26 [ VAR8 -> VAR27 ] = 0xff ; VAR8 -> VAR26 [ VAR8 -> VAR27 + 1 ] = 0xff ; FUN3 ( & VAR6 -> VAR29 , VAR8 -> VAR26 , 0 , 1 ) ; while ( VAR12 -- ) { switch ( VAR14 ) { case 0 : FUN4 ( VAR6 , VAR9 , VAR10 , VAR15 + 1 , VAR11 , VAR19 && ( VAR18 >= 4 ) , VAR22 ) ; break ; case 1 : FUN5 ( VAR6 , VAR9 , VAR10 , VAR15 + 1 ) ; break ; case 2 : FUN6 ( VAR2 , VAR6 , VAR9 , VAR10 , VAR15 + 1 , VAR11 , VAR4 -> VAR20 & VAR30 , VAR22 ) ; break ; } VAR14 ++ ; if ( VAR14 == 3 ) { VAR15 -- ; VAR14 = 0 ; } } return 0 ; } #0
368#368#static void FUN1 ( float VAR1 [ 38 ] [ 64 ] [ 2 ] , const float VAR2 [ 64 ] [ 40 ] [ 2 ] , VAR3 * VAR4 , VAR5 * VAR6 , const int VAR7 [ 2 ] ) { int VAR8 , VAR9 , VAR10 , VAR11 ; const int VAR12 = 4 * ! VAR4 -> VAR13 ; const int VAR14 = VAR4 -> VAR14 [ 1 ] ; const int VAR15 = VAR4 -> VAR11 [ 1 ] ; static const float VAR16 [ 5 ] = { 0.33333333333333 , 0.30150283239582 , 0.21816949906249 , 0.11516383427084 , 0.03183050093751 , } ; static const int8_t VAR17 [ 2 ] [ 4 ] = { { 1 , 0 , -1 , 0 } , { 0 , 1 , 0 , -1 } , } ; float ( * VAR18 ) [ 48 ] = VAR6 -> VAR18 , ( * VAR19 ) [ 48 ] = VAR6 -> VAR19 ; int VAR20 = VAR6 -> VAR21 ; int VAR22 = VAR6 -> VAR23 ; if ( VAR4 -> VAR24 ) { for ( VAR9 = 0 ; VAR9 < VAR12 ; VAR9 ++ ) { memcpy ( VAR18 [ VAR9 + 2 * VAR6 -> VAR25 [ 0 ] ] , VAR4 -> VAR26 [ 0 ] , VAR15 * sizeof ( VAR4 -> VAR26 [ 0 ] [ 0 ] ) ) ; memcpy ( VAR19 [ VAR9 + 2 * VAR6 -> VAR25 [ 0 ] ] , VAR4 -> VAR27 [ 0 ] , VAR15 * sizeof ( VAR4 -> VAR27 [ 0 ] [ 0 ] ) ) ; } } else if ( VAR12 ) { memcpy ( VAR18 [ 2 * VAR6 -> VAR25 [ 0 ] ] , VAR18 [ 2 * VAR6 -> VAR28 ] , 4 * sizeof ( VAR18 [ 0 ] ) ) ; memcpy ( VAR19 [ 2 * VAR6 -> VAR25 [ 0 ] ] , VAR19 [ 2 * VAR6 -> VAR28 ] , 4 * sizeof ( VAR19 [ 0 ] ) ) ; } for ( VAR8 = 0 ; VAR8 < VAR6 -> VAR29 ; VAR8 ++ ) { for ( VAR9 = 2 * VAR6 -> VAR25 [ VAR8 ] ; VAR9 < 2 * VAR6 -> VAR25 [ VAR8 + 1 ] ; VAR9 ++ ) { memcpy ( VAR18 [ VAR12 + VAR9 ] , VAR4 -> VAR26 [ VAR8 ] , VAR15 * sizeof ( VAR4 -> VAR26 [ 0 ] [ 0 ] ) ) ; memcpy ( VAR19 [ VAR12 + VAR9 ] , VAR4 -> VAR27 [ VAR8 ] , VAR15 * sizeof ( VAR4 -> VAR27 [ 0 ] [ 0 ] ) ) ; } } for ( VAR8 = 0 ; VAR8 < VAR6 -> VAR29 ; VAR8 ++ ) { for ( VAR9 = 2 * VAR6 -> VAR25 [ VAR8 ] ; VAR9 < 2 * VAR6 -> VAR25 [ VAR8 + 1 ] ; VAR9 ++ ) { int VAR30 = ( 1 - 2 * ( VAR14 & 1 ) ) ; FUN2 ( float , VAR31 , [ 48 ] ) ; FUN2 ( float , VAR32 , [ 48 ] ) ; float * VAR33 , * VAR34 ; if ( VAR12 && VAR8 != VAR7 [ 0 ] && VAR8 != VAR7 [ 1 ] ) { VAR33 = VAR31 ; VAR34 = VAR32 ; for ( VAR11 = 0 ; VAR11 < VAR15 ; VAR11 ++ ) { const int VAR35 = VAR9 + VAR12 ; VAR33 [ VAR11 ] = 0.0f ; VAR34 [ VAR11 ] = 0.0f ; for ( VAR10 = 0 ; VAR10 <= VAR12 ; VAR10 ++ ) { VAR33 [ VAR11 ] += VAR18 [ VAR35 - VAR10 ] [ VAR11 ] * VAR16 [ VAR10 ] ; VAR34 [ VAR11 ] += VAR19 [ VAR35 - VAR10 ] [ VAR11 ] * VAR16 [ VAR10 ] ; } } } else { VAR33 = VAR18 [ VAR9 + VAR12 ] ; VAR34 = VAR19 [ VAR9 ] ; } VAR4 -> VAR36 . FUN3 ( VAR1 [ VAR9 ] + VAR14 , VAR2 + VAR14 , VAR33 , VAR15 , VAR9 + VAR37 ) ; if ( VAR8 != VAR7 [ 0 ] && VAR8 != VAR7 [ 1 ] ) { VAR4 -> VAR36 . VAR38 [ VAR22 ] ( VAR1 [ VAR9 ] + VAR14 , VAR4 -> VAR39 [ VAR8 ] , VAR34 , VAR20 , VAR14 , VAR15 ) ; } else { for ( VAR11 = 0 ; VAR11 < VAR15 ; VAR11 ++ ) { VAR1 [ VAR9 ] [ VAR11 + VAR14 ] [ 0 ] += VAR4 -> VAR39 [ VAR8 ] [ VAR11 ] * VAR17 [ 0 ] [ VAR22 ] ; VAR1 [ VAR9 ] [ VAR11 + VAR14 ] [ 1 ] += VAR4 -> VAR39 [ VAR8 ] [ VAR11 ] * ( VAR17 [ 1 ] [ VAR22 ] * VAR30 ) ; VAR30 = - VAR30 ; } } VAR20 = ( VAR20 + VAR15 ) & 0x1ff ; VAR22 = ( VAR22 + 1 ) & 3 ; } } VAR6 -> VAR21 = VAR20 ; VAR6 -> VAR23 = VAR22 ; } #1
369#369#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , int VAR6 , int VAR7 , int VAR8 , int VAR9 , int VAR10 , int VAR11 , int VAR12 ) { VAR13 * VAR14 = VAR2 -> VAR15 ; int VAR16 , VAR17 , VAR18 ; int VAR19 , VAR20 ; int VAR21 = VAR7 + VAR9 ; int VAR22 = VAR10 + VAR12 ; int VAR23 , VAR24 ; VAR19 = FUN2 ( VAR11 - VAR6 , VAR8 ) ; VAR23 = FUN2 ( VAR22 , VAR21 ) ; VAR24 = FUN3 ( VAR7 , VAR10 ) ; VAR20 = VAR23 - VAR24 ; if ( VAR14 -> VAR25 ) { VAR26 * VAR27 = VAR4 -> VAR28 [ 0 ] + VAR6 * VAR14 -> VAR29 [ 0 ] + VAR24 * VAR4 -> VAR30 [ 0 ] ; VAR26 * VAR31 = VAR5 -> VAR28 [ 0 ] ; uint8_t VAR32 ; const int VAR33 = VAR14 -> VAR34 [ VAR35 ] ; const int VAR36 = VAR14 -> VAR34 [ VAR37 ] ; const int VAR38 = VAR14 -> VAR34 [ VAR39 ] ; const int VAR40 = VAR14 -> VAR34 [ VAR41 ] ; const int VAR42 = VAR14 -> VAR29 [ 0 ] ; const int VAR43 = VAR14 -> VAR44 [ VAR35 ] ; const int VAR45 = VAR14 -> VAR44 [ VAR37 ] ; const int VAR46 = VAR14 -> VAR44 [ VAR39 ] ; const int VAR47 = VAR14 -> VAR44 [ VAR41 ] ; const int VAR48 = VAR14 -> VAR49 [ 0 ] ; const int VAR50 = VAR14 -> VAR50 ; if ( VAR10 > VAR7 ) VAR31 += ( VAR10 - VAR7 ) * VAR5 -> VAR30 [ 0 ] ; for ( VAR16 = 0 ; VAR16 < VAR20 ; VAR16 ++ ) { VAR26 * VAR51 = VAR27 , * VAR52 = VAR31 ; for ( VAR17 = 0 ; VAR17 < VAR19 ; VAR17 ++ ) { VAR32 = VAR52 [ VAR47 ] ; if ( VAR50 && VAR32 != 0 && VAR32 != 255 ) { VAR32 = ( ( VAR32 << 16 ) - ( VAR32 << 9 ) + VAR32 ) / ( ( ( VAR32 + VAR51 [ VAR40 ] ) << 8 ) - ( VAR32 + VAR51 [ VAR40 ] ) - VAR51 [ VAR40 ] * VAR32 ) ; } switch ( VAR32 ) { case 0 : break ; case 255 : VAR51 [ VAR33 ] = VAR52 [ VAR43 ] ; VAR51 [ VAR36 ] = VAR52 [ VAR45 ] ; VAR51 [ VAR38 ] = VAR52 [ VAR46 ] ; break ; default : VAR51 [ VAR33 ] = FUN4 ( VAR51 [ VAR33 ] * ( 255 - VAR32 ) + VAR52 [ VAR43 ] * VAR32 ) ; VAR51 [ VAR36 ] = FUN4 ( VAR51 [ VAR36 ] * ( 255 - VAR32 ) + VAR52 [ VAR45 ] * VAR32 ) ; VAR51 [ VAR38 ] = FUN4 ( VAR51 [ VAR38 ] * ( 255 - VAR32 ) + VAR52 [ VAR46 ] * VAR32 ) ; } if ( VAR50 ) { switch ( VAR32 ) { case 0 : break ; case 255 : VAR51 [ VAR40 ] = VAR52 [ VAR47 ] ; break ; default : VAR51 [ VAR40 ] += FUN4 ( ( 255 - VAR51 [ VAR40 ] ) * VAR52 [ VAR47 ] ) ; } } VAR51 += VAR42 ; VAR52 += VAR48 ; } VAR27 += VAR4 -> VAR30 [ 0 ] ; VAR31 += VAR5 -> VAR30 [ 0 ] ; } } else { for ( VAR16 = 0 ; VAR16 < 3 ; VAR16 ++ ) { int VAR53 = VAR16 ? VAR14 -> VAR53 : 0 ; int VAR54 = VAR16 ? VAR14 -> VAR54 : 0 ; VAR26 * VAR27 = VAR4 -> VAR28 [ VAR16 ] + ( VAR6 >> VAR53 ) + ( VAR24 >> VAR54 ) * VAR4 -> VAR30 [ VAR16 ] ; VAR26 * VAR31 = VAR5 -> VAR28 [ VAR16 ] ; VAR26 * VAR55 = VAR5 -> VAR28 [ 3 ] ; int VAR56 = FUN5 ( VAR19 , 1 << VAR53 ) >> VAR53 ; int VAR57 = FUN5 ( VAR20 , 1 << VAR54 ) >> VAR54 ; if ( VAR10 > VAR7 ) { VAR31 += ( ( VAR10 - VAR7 ) >> VAR54 ) * VAR5 -> VAR30 [ VAR16 ] ; VAR55 += ( VAR10 - VAR7 ) * VAR5 -> VAR30 [ 3 ] ; } for ( VAR17 = 0 ; VAR17 < VAR57 ; VAR17 ++ ) { VAR26 * VAR51 = VAR27 , * VAR52 = VAR31 , * VAR58 = VAR55 ; for ( VAR18 = 0 ; VAR18 < VAR56 ; VAR18 ++ ) { int VAR59 , VAR60 , VAR32 ; if ( VAR53 && VAR54 && VAR17 + 1 < VAR57 && VAR18 + 1 < VAR56 ) { VAR32 = ( VAR58 [ 0 ] + VAR58 [ VAR5 -> VAR30 [ 3 ] ] + VAR58 [ 1 ] + VAR58 [ VAR5 -> VAR30 [ 3 ] + 1 ] ) >> 2 ; } else if ( VAR53 || VAR54 ) { VAR60 = VAR53 && VAR18 + 1 < VAR56 ? ( VAR58 [ 0 ] + VAR58 [ 1 ] ) >> 1 : VAR58 [ 0 ] ; VAR59 = VAR54 && VAR17 + 1 < VAR57 ? ( VAR58 [ 0 ] + VAR58 [ VAR5 -> VAR30 [ 3 ] ] ) >> 1 : VAR58 [ 0 ] ; VAR32 = ( VAR59 + VAR60 ) >> 1 ; } else VAR32 = VAR58 [ 0 ] ; * VAR51 = FUN4 ( * VAR51 * ( 255 - VAR32 ) + * VAR52 * VAR32 ) ; VAR52 ++ ; VAR51 ++ ; VAR58 += 1 << VAR53 ; } VAR27 += VAR4 -> VAR30 [ VAR16 ] ; VAR31 += VAR5 -> VAR30 [ VAR16 ] ; VAR55 += ( 1 << VAR54 ) * VAR5 -> VAR30 [ 3 ] ; } } } } #1
370#370#"int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , size_t VAR4 , const char * VAR5 , size_t VAR6 , const unsigned char * VAR7 , size_t VAR8 , int VAR9 ) { unsigned char VAR10 [ VAR11 ] ; static const unsigned char VAR12 [ ] = "" "" ; unsigned char VAR13 [ VAR11 ] ; const VAR14 * VAR15 = FUN2 ( VAR2 ) ; VAR16 * VAR17 = FUN3 ( ) ; unsigned int VAR18 ; int VAR19 = 0 ; if ( VAR17 == NULL || ! FUN4 ( VAR2 ) ) goto VAR20 ; if ( ! VAR9 ) VAR8 = 0 ; if ( EVP_DigestInit_ex ( VAR17 , VAR15 , NULL ) <= 0 || EVP_DigestUpdate ( VAR17 , VAR7 , VAR8 ) <= 0 || FUN5 ( VAR17 , VAR13 , & VAR18 ) <= 0 || ! FUN6 ( VAR2 , VAR15 , VAR2 -> VAR21 , ( const unsigned char * ) VAR5 , VAR6 , NULL , 0 , VAR10 , VAR18 ) || ! FUN6 ( VAR2 , VAR15 , VAR10 , VAR12 , sizeof ( VAR12 ) - 1 , VAR13 , VAR18 , VAR3 , VAR4 ) ) goto VAR20 ; VAR19 = 1 ; VAR20 : FUN7 ( VAR17 ) ; return VAR19 ; } "#0
371#371#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const char * VAR5 , int VAR6 ) { VAR2 -> VAR7 &= ~ VAR8 ; switch ( VAR4 -> VAR9 ) { case VAR10 : case VAR11 : { char VAR12 [ FUN2 ( VAR4 -> VAR13 . VAR14 . VAR15 ) + 1 ] ; char VAR16 [ FUN2 ( VAR4 -> VAR13 . VAR14 . VAR17 ) + 1 ] ; FUN3 ( VAR12 , sizeof ( VAR12 ) , , VAR4 -> VAR13 . VAR14 . VAR17 ) ; if ( VAR6 < VAR4 -> VAR13 . VAR14 . VAR15 ) { VAR2 -> VAR7 |= VAR8 ; FUN4 ( VAR18 , VAR19 ) ; FUN5 ( 5 , , VAR16 , , VAR12 , ) ; return -1 ; } } if ( VAR4 -> VAR21 == NULL ) { FUN4 ( VAR18 , VAR22 ) ; return -1 ; } memcpy ( VAR4 -> VAR21 , VAR5 , VAR6 ) ; if ( VAR6 <= VAR4 -> VAR13 . VAR14 . VAR17 ) VAR4 -> VAR21 [ VAR6 ] = ' ' ; VAR4 -> VAR23 = VAR6 ; break ; case VAR24 : { const char * VAR25 ; if ( VAR4 -> VAR21 == NULL ) { FUN4 ( VAR18 , VAR22 ) ; return -1 ; } VAR4 -> VAR21 [ 0 ] = ' ' ; for ( VAR25 = VAR5 ; * VAR25 ; VAR25 ++ ) { if ( strchr ( VAR4 -> VAR13 . VAR26 . VAR27 , * VAR25 ) ) { VAR4 -> VAR21 [ 0 ] = VAR4 -> VAR13 . VAR26 . VAR27 [ 0 ] ; break ; } if ( strchr ( VAR4 -> VAR13 . VAR26 . VAR28 , * VAR25 ) ) { VAR4 -> VAR21 [ 0 ] = VAR4 -> VAR13 . VAR26 . VAR28 [ 0 ] ; break ; } } } case VAR29 : case VAR30 : case VAR31 : break ; } return 0 ; } #0
372#372#static int FUN1 ( VAR1 * VAR2 , unsigned long * VAR3 , VAR4 * VAR5 ) { int VAR6 ; unsigned char * VAR7 ; VAR6 = FUN2 ( VAR5 , NULL ) ; if ( VAR6 < 0 || ! FUN3 ( VAR2 , ( int ) ( VAR6 + ( * VAR3 ) + 3 ) ) ) { FUN4 ( VAR8 , VAR9 ) ; return 0 ; } VAR7 = ( unsigned char * ) & ( VAR2 -> VAR10 [ * VAR3 ] ) ; FUN5 ( VAR6 , VAR7 ) ; VAR6 = FUN2 ( VAR5 , & VAR7 ) ; if ( VAR6 < 0 ) { FUN4 ( VAR8 , VAR9 ) ; return 0 ; } * VAR3 += VAR6 + 3 ; return 1 ; } #0
373#373#"int FUN1 ( VAR1 * VAR2 ) { unsigned char * VAR3 , * VAR4 ; unsigned char VAR5 [ VAR6 + VAR7 ] ; VAR8 * VAR9 ; VAR10 * VAR11 = NULL ; EVP_MD_CTX VAR12 ; unsigned VAR13 = 0 ; unsigned long VAR14 ; int VAR15 ; EVP_MD_CTX_init ( & VAR12 ) ; if ( VAR2 -> VAR16 == VAR17 ) { VAR4 = ( unsigned char * ) VAR2 -> VAR18 -> VAR5 ; VAR3 = & ( VAR4 [ 4 ] ) ; VAR9 = VAR2 -> VAR19 -> VAR20 -> VAR21 ; VAR11 = FUN2 ( VAR9 , NULL ) ; FUN3 ( VAR11 ) ; if ( FUN4 ( VAR11 , FUN5 ( ) ) > 0 ) { if ( VAR2 -> VAR22 < VAR23 ) VAR2 -> VAR24 -> VAR25 -> FUN6 ( VAR2 , VAR26 , & ( VAR5 [ VAR6 ] ) ) ; } else { FUN7 ( ) ; } if ( VAR2 -> VAR22 >= VAR23 ) { long VAR27 = 0 ; void * VAR28 ; const VAR29 * VAR30 = VAR2 -> VAR19 -> VAR20 -> VAR31 ; VAR27 = FUN8 ( VAR2 -> VAR32 -> VAR33 , & VAR28 ) ; if ( VAR27 <= 0 || ! FUN9 ( VAR3 , VAR9 , VAR30 ) ) { FUN10 ( VAR34 , VAR35 ) ; goto VAR36 ; } VAR3 += 2 ; #ifdef VAR37 fprintf ( VAR38 , "" "" , FUN11 ( VAR30 ) ) ; #endif if ( ! FUN12 ( & VAR12 , VAR30 , NULL ) || ! FUN13 ( & VAR12 , VAR28 , VAR27 ) || ! FUN14 ( & VAR12 , VAR3 + 2 , & VAR13 , VAR9 ) ) { FUN10 ( VAR34 , VAR39 ) ; goto VAR36 ; } FUN15 ( VAR13 , VAR3 ) ; VAR14 = VAR13 + 4 ; if ( ! FUN16 ( VAR2 ) ) goto VAR36 ; } else #ifndef OPENSSL_NO_RSA if ( VAR9 -> VAR40 == VAR41 ) { VAR2 -> VAR24 -> VAR25 -> FUN6 ( VAR2 , VAR42 , & ( VAR5 [ 0 ] ) ) ; if ( FUN17 ( VAR43 , VAR5 , VAR6 + VAR7 , & ( VAR3 [ 2 ] ) , & VAR13 , VAR9 -> VAR9 . VAR44 ) <= 0 ) { FUN10 ( VAR34 , VAR45 ) ; goto VAR36 ; } FUN15 ( VAR13 , VAR3 ) ; VAR14 = VAR13 + 2 ; } else #endif #ifndef OPENSSL_NO_DSA if ( VAR9 -> VAR40 == VAR46 ) { if ( ! FUN18 ( VAR9 -> VAR47 , & ( VAR5 [ VAR6 ] ) , VAR7 , & ( VAR3 [ 2 ] ) , ( unsigned int * ) & VAR15 , VAR9 -> VAR9 . VAR48 ) ) { FUN10 ( VAR34 , VAR49 ) ; goto VAR36 ; } FUN15 ( VAR15 , VAR3 ) ; VAR14 = VAR15 + 2 ; } else #endif #ifndef OPENSSL_NO_ECDSA if ( VAR9 -> VAR40 == VAR50 ) { if ( ! FUN19 ( VAR9 -> VAR47 , & ( VAR5 [ VAR6 ] ) , VAR7 , & ( VAR3 [ 2 ] ) , ( unsigned int * ) & VAR15 , VAR9 -> VAR9 . VAR51 ) ) { FUN10 ( VAR34 , VAR52 ) ; goto VAR36 ; } FUN15 ( VAR15 , VAR3 ) ; VAR14 = VAR15 + 2 ; } else #endif if ( VAR9 -> VAR40 == VAR53 || VAR9 -> VAR40 == VAR54 ) { unsigned char VAR55 [ 64 ] ; int VAR56 ; size_t VAR57 = 64 ; VAR2 -> VAR24 -> VAR25 -> FUN6 ( VAR2 , VAR58 , VAR5 ) ; if ( FUN20 ( VAR11 , VAR55 , & VAR57 , VAR5 , 32 ) <= 0 ) { FUN10 ( VAR34 , VAR35 ) ; goto VAR36 ; } for ( VAR56 = 63 , VAR15 = 0 ; VAR56 >= 0 ; VAR15 ++ , VAR56 -- ) { VAR3 [ 2 + VAR15 ] = VAR55 [ VAR56 ] ; } FUN15 ( VAR15 , VAR3 ) ; VAR14 = VAR15 + 2 ; } else { FUN10 ( VAR34 , VAR35 ) ; goto VAR36 ; } * ( VAR4 ++ ) = VAR59 ; FUN21 ( VAR14 , VAR4 ) ; VAR2 -> VAR16 = VAR60 ; VAR2 -> VAR61 = ( int ) VAR14 + 4 ; VAR2 -> VAR62 = 0 ; } FUN22 ( & VAR12 ) ; FUN23 ( VAR11 ) ; return ( FUN24 ( VAR2 , VAR63 ) ) ; VAR36 : FUN22 ( & VAR12 ) ; FUN23 ( VAR11 ) ; return ( -1 ) ; } "#0
374#374#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , uint8_t VAR5 , VAR3 * VAR6 , uint8_t VAR7 , VAR8 * VAR9 , int VAR10 ) { int VAR11 = VAR4 -> VAR12 [ 0 ] + VAR4 -> VAR12 [ 1 ] ; if ( VAR10 ) { if ( VAR4 -> VAR13 || VAR6 -> VAR13 ) return 2 ; if ( VAR5 || VAR7 ) return 1 ; } if ( VAR11 == VAR6 -> VAR12 [ 0 ] + VAR6 -> VAR12 [ 1 ] ) { if ( VAR11 == 2 ) { if ( VAR2 -> VAR14 -> VAR15 [ 0 ] . VAR16 [ VAR4 -> VAR17 [ 0 ] ] == VAR9 [ 0 ] . VAR16 [ VAR6 -> VAR17 [ 0 ] ] && VAR2 -> VAR14 -> VAR15 [ 0 ] . VAR16 [ VAR4 -> VAR17 [ 0 ] ] == VAR2 -> VAR14 -> VAR15 [ 1 ] . VAR16 [ VAR4 -> VAR17 [ 1 ] ] && VAR9 [ 0 ] . VAR16 [ VAR6 -> VAR17 [ 0 ] ] == VAR9 [ 1 ] . VAR16 [ VAR6 -> VAR17 [ 1 ] ] ) { if ( ( FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR19 - VAR4 -> VAR18 [ 0 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR20 - VAR4 -> VAR18 [ 0 ] . VAR20 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR19 - VAR4 -> VAR18 [ 1 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR20 - VAR4 -> VAR18 [ 1 ] . VAR20 ) >= 4 ) && ( FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR19 - VAR4 -> VAR18 [ 0 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR20 - VAR4 -> VAR18 [ 0 ] . VAR20 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR19 - VAR4 -> VAR18 [ 1 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR20 - VAR4 -> VAR18 [ 1 ] . VAR20 ) >= 4 ) ) return 1 ; else return 0 ; } else if ( VAR9 [ 0 ] . VAR16 [ VAR6 -> VAR17 [ 0 ] ] == VAR2 -> VAR14 -> VAR15 [ 0 ] . VAR16 [ VAR4 -> VAR17 [ 0 ] ] && VAR9 [ 1 ] . VAR16 [ VAR6 -> VAR17 [ 1 ] ] == VAR2 -> VAR14 -> VAR15 [ 1 ] . VAR16 [ VAR4 -> VAR17 [ 1 ] ] ) { if ( FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR19 - VAR4 -> VAR18 [ 0 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR20 - VAR4 -> VAR18 [ 0 ] . VAR20 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR19 - VAR4 -> VAR18 [ 1 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR20 - VAR4 -> VAR18 [ 1 ] . VAR20 ) >= 4 ) return 1 ; else return 0 ; } else if ( VAR9 [ 1 ] . VAR16 [ VAR6 -> VAR17 [ 1 ] ] == VAR2 -> VAR14 -> VAR15 [ 0 ] . VAR16 [ VAR4 -> VAR17 [ 0 ] ] && VAR9 [ 0 ] . VAR16 [ VAR6 -> VAR17 [ 0 ] ] == VAR2 -> VAR14 -> VAR15 [ 1 ] . VAR16 [ VAR4 -> VAR17 [ 1 ] ] ) { if ( FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR19 - VAR4 -> VAR18 [ 0 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 1 ] . VAR20 - VAR4 -> VAR18 [ 0 ] . VAR20 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR19 - VAR4 -> VAR18 [ 1 ] . VAR19 ) >= 4 || FUN2 ( VAR6 -> VAR18 [ 0 ] . VAR20 - VAR4 -> VAR18 [ 1 ] . VAR20 ) >= 4 ) return 1 ; else return 0 ; } else { return 1 ; } } else { Mv VAR21 , VAR22 ; int VAR23 , VAR24 ; if ( VAR4 -> VAR12 [ 0 ] ) { VAR21 = VAR4 -> VAR18 [ 0 ] ; VAR23 = VAR2 -> VAR14 -> VAR15 [ 0 ] . VAR16 [ VAR4 -> VAR17 [ 0 ] ] ; } else { VAR21 = VAR4 -> VAR18 [ 1 ] ; VAR23 = VAR2 -> VAR14 -> VAR15 [ 1 ] . VAR16 [ VAR4 -> VAR17 [ 1 ] ] ; } if ( VAR6 -> VAR12 [ 0 ] ) { VAR22 = VAR6 -> VAR18 [ 0 ] ; VAR24 = VAR9 [ 0 ] . VAR16 [ VAR6 -> VAR17 [ 0 ] ] ; } else { VAR22 = VAR6 -> VAR18 [ 1 ] ; VAR24 = VAR9 [ 1 ] . VAR16 [ VAR6 -> VAR17 [ 1 ] ] ; } if ( VAR23 == VAR24 ) { if ( FUN2 ( VAR21 . VAR19 - VAR22 . VAR19 ) >= 4 || FUN2 ( VAR21 . VAR20 - VAR22 . VAR20 ) >= 4 ) return 1 ; else return 0 ; } else return 1 ; } } return 1 ; } #1
375#375#"static VAR1 FUN1 ( VAR2 * * new , const char * VAR3 , VAR4 * VAR5 , unsigned int * VAR6 , VAR7 * VAR8 ) { char * VAR9 ; VAR2 * VAR10 ; VAR2 * VAR11 = VAR12 ; VAR13 * VAR14 ; const char * VAR15 ; VAR16 * VAR17 ; apr_status_t VAR18 ; if ( VAR19 == NULL ) { return VAR20 ; } if ( ! FUN2 ( VAR8 , VAR3 , & VAR15 , NULL ) ) { return VAR20 ; } FUN3 ( VAR21 , VAR22 , 0 , VAR23 , FUN4 ( 02301 ) VAR26VAR26 "" "" , VAR15 , * VAR5 , * VAR6 ) ; return VAR27 ; } "#0
376#376#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , size_t VAR5 ) { if ( VAR2 -> VAR6 ) { unsigned int VAR7 = 32 - VAR2 -> VAR6 ; if ( VAR7 > VAR5 ) { VAR7 = VAR5 ; } memcpy ( & ( VAR2 -> VAR8 [ VAR2 -> VAR6 ] ) , VAR4 , VAR7 ) ; VAR2 -> VAR6 += VAR7 ; if ( VAR2 -> VAR6 < 32 ) { return 1 ; } VAR4 += VAR7 ; VAR5 -= VAR7 ; FUN2 ( VAR2 -> VAR9 , VAR2 -> VAR10 , VAR2 -> VAR8 ) ; FUN3 ( 32 , VAR2 -> VAR11 , VAR2 -> VAR8 ) ; VAR2 -> VAR12 += 32 ; VAR2 -> VAR6 = 0 ; } while ( VAR5 >= 32 ) { FUN2 ( VAR2 -> VAR9 , VAR2 -> VAR10 , VAR4 ) ; FUN3 ( 32 , VAR2 -> VAR11 , VAR4 ) ; VAR2 -> VAR12 += 32 ; VAR4 += 32 ; VAR5 -= 32 ; } if ( VAR5 ) { memcpy ( VAR2 -> VAR8 , VAR4 , VAR2 -> VAR6 = VAR5 ) ; } return 1 ; } #1
377#377#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 ; int * VAR5 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR6 ; VAR4 ++ ) { if ( FUN2 ( 1 , VAR2 -> VAR7 ) >= VAR8 / sizeof ( VAR9 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return -1 ; } VAR2 -> VAR14 [ VAR4 ] = FUN4 ( VAR2 -> VAR14 [ VAR4 ] , sizeof ( VAR9 ) * FUN2 ( 1 , VAR2 -> VAR7 ) ) ; VAR2 -> VAR15 [ VAR4 ] = FUN4 ( VAR2 -> VAR15 [ VAR4 ] , sizeof ( VAR9 ) * ( VAR2 -> VAR12 + VAR2 -> VAR13 ) ) ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR13 ; VAR3 ++ ) VAR2 -> VAR15 [ VAR4 ] [ VAR3 ] = 0 ; VAR2 -> VAR15 [ VAR4 ] += VAR2 -> VAR13 ; } VAR5 = FUN4 ( VAR2 -> VAR5 , VAR2 -> VAR13 * sizeof ( * VAR2 -> VAR5 ) ) ; if ( ! VAR5 ) return FUN5 ( VAR16 ) ; VAR2 -> VAR5 = VAR5 ; return 0 ; } #1
378#378#"VAR1 * FUN1 ( VAR2 * VAR3 ) { VAR1 * VAR4 = NULL ; if ( VAR3 == NULL ) { FUN2 ( VAR5 , VAR6 ) ; return ( NULL ) ; } if ( FUN3 ( ) < 0 ) { FUN2 ( VAR5 , VAR7 ) ; goto VAR8 ; } VAR4 = ( VAR1 * ) FUN4 ( sizeof ( VAR1 ) ) ; if ( VAR4 == NULL ) goto VAR8 ; memset ( VAR4 , 0 , sizeof ( VAR1 ) ) ; VAR4 -> VAR9 = VAR3 ; VAR4 -> VAR10 = NULL ; VAR4 -> VAR11 = VAR12 ; VAR4 -> VAR13 = VAR14 ; VAR4 -> VAR15 = NULL ; VAR4 -> VAR16 = NULL ; VAR4 -> VAR17 = VAR3 -> FUN5 ( ) ; VAR4 -> VAR18 = NULL ; VAR4 -> VAR19 = NULL ; VAR4 -> VAR20 = NULL ; VAR4 -> VAR21 = NULL ; memset ( ( char * ) & VAR4 -> VAR22 , 0 , sizeof ( VAR4 -> VAR22 ) ) ; VAR4 -> VAR23 = 1 ; VAR4 -> VAR24 = 0 ; VAR4 -> VAR25 = NULL ; VAR4 -> VAR26 = NULL ; VAR4 -> VAR27 = NULL ; VAR4 -> VAR28 = 0 ; VAR4 -> VAR29 = VAR30 ; VAR4 -> VAR31 = -1 ; VAR4 -> VAR32 = NULL ; if ( ( VAR4 -> VAR33 = FUN6 ( ) ) == NULL ) goto VAR8 ; VAR4 -> VAR34 = NULL ; VAR4 -> VAR35 = NULL ; VAR4 -> VAR36 = NULL ; VAR4 -> VAR37 = FUN7 ( FUN8 ( VAR38 ) , FUN9 ( VAR39 ) ) ; if ( VAR4 -> VAR37 == NULL ) goto VAR8 ; VAR4 -> VAR10 = FUN10 ( ) ; if ( VAR4 -> VAR10 == NULL ) goto VAR8 ; FUN11 ( VAR4 -> VAR9 , & VAR4 -> VAR40 , & VAR4 -> VAR41 , VAR42 ) ; if ( VAR4 -> VAR40 == NULL || FUN12 ( VAR4 -> VAR40 ) <= 0 ) { FUN2 ( VAR5 , VAR43 ) ; goto VAR44 ; } if ( ( VAR4 -> VAR45 = FUN13 ( ) ) == NULL ) { FUN2 ( VAR5 , VAR48 ) ; goto VAR44 ; } if ( ( VAR4 -> VAR49 = FUN13 ( "" "" ) ) == NULL ) { FUN2 ( VAR5 , VAR50 ) ; goto VAR44 ; } if ( ( VAR4 -> VAR51 = FUN14 ( ) ) == NULL ) goto VAR8 ; FUN15 ( VAR52 , VAR4 , & VAR4 -> VAR53 ) ; VAR4 -> VAR54 = NULL ; VAR4 -> VAR55 = FUN16 ( ) ; return ( VAR4 ) ; VAR8 : FUN2 ( VAR5 , VAR56 ) ; VAR44 : if ( VAR4 != NULL ) FUN17 ( VAR4 ) ; return ( NULL ) ; } "#1
379#379#VAR1 FUN1 ( const VAR2 * VAR3 , const VAR4 * VAR5 , point_conversion_form_t VAR6 , unsigned char * VAR7 , size_t VAR8 , VAR9 * VAR10 ) { size_t VAR11 ; VAR9 * VAR12 = NULL ; int VAR13 = 0 ; VAR14 * VAR15 , * VAR16 , * VAR17 ; size_t VAR18 , VAR19 , VAR20 ; if ( ( VAR6 != VAR21 ) && ( VAR6 != VAR22 ) && ( VAR6 != VAR23 ) ) { FUN2 ( VAR24 , VAR25 ) ; goto VAR26 ; } if ( FUN3 ( VAR3 , VAR5 ) ) { if ( VAR7 != NULL ) { if ( VAR8 < 1 ) { FUN2 ( VAR24 , VAR27 ) ; return 0 ; } VAR7 [ 0 ] = 0 ; } return 1 ; } VAR18 = ( FUN4 ( VAR3 ) + 7 ) / 8 ; VAR11 = ( VAR6 == VAR21 ) ? 1 + VAR18 : 1 + 2 * VAR18 ; if ( VAR7 != NULL ) { if ( VAR8 < VAR11 ) { FUN2 ( VAR24 , VAR27 ) ; goto VAR26 ; } if ( VAR10 == NULL ) { VAR10 = VAR12 = FUN5 ( ) ; if ( VAR10 == NULL ) return 0 ; } FUN6 ( VAR10 ) ; VAR13 = 1 ; VAR15 = FUN7 ( VAR10 ) ; VAR16 = FUN7 ( VAR10 ) ; VAR17 = FUN7 ( VAR10 ) ; if ( VAR17 == NULL ) goto VAR26 ; if ( ! FUN8 ( VAR3 , VAR5 , VAR15 , VAR16 , VAR10 ) ) goto VAR26 ; VAR7 [ 0 ] = VAR6 ; if ( ( VAR6 != VAR22 ) && ! FUN9 ( VAR15 ) ) { if ( ! VAR3 -> VAR28 -> FUN10 ( VAR3 , VAR17 , VAR16 , VAR15 , VAR10 ) ) goto VAR26 ; if ( FUN11 ( VAR17 ) ) VAR7 [ 0 ] ++ ; } VAR19 = 1 ; VAR20 = VAR18 - FUN12 ( VAR15 ) ; if ( VAR20 > VAR18 ) { FUN2 ( VAR24 , VAR29 ) ; goto VAR26 ; } while ( VAR20 > 0 ) { VAR7 [ VAR19 ++ ] = 0 ; VAR20 -- ; } VAR20 = FUN13 ( VAR15 , VAR7 + VAR19 ) ; VAR19 += VAR20 ; if ( VAR19 != 1 + VAR18 ) { FUN2 ( VAR24 , VAR29 ) ; goto VAR26 ; } if ( VAR6 == VAR22 || VAR6 == VAR23 ) { VAR20 = VAR18 - FUN12 ( VAR16 ) ; if ( VAR20 > VAR18 ) { FUN2 ( VAR24 , VAR29 ) ; goto VAR26 ; } while ( VAR20 > 0 ) { VAR7 [ VAR19 ++ ] = 0 ; VAR20 -- ; } VAR20 = FUN13 ( VAR16 , VAR7 + VAR19 ) ; VAR19 += VAR20 ; } if ( VAR19 != VAR11 ) { FUN2 ( VAR24 , VAR29 ) ; goto VAR26 ; } } if ( VAR13 ) FUN14 ( VAR10 ) ; FUN15 ( VAR12 ) ; return VAR11 ; VAR26 : if ( VAR13 ) FUN14 ( VAR10 ) ; FUN15 ( VAR12 ) ; return 0 ; } #1
380#380#char * FUN1 ( const char * VAR1 , size_t VAR2 ) { char * VAR3 ; if ( VAR1 == NULL ) return NULL ; VAR2 = FUN2 ( VAR1 , VAR2 ) ; if ( VAR2 >= VAR4 ) return NULL ; VAR3 = FUN3 ( VAR2 + 1 ) ; if ( VAR3 == NULL ) { FUN4 ( VAR5 , VAR6 ) ; return NULL ; } memcpy ( VAR3 , VAR1 , VAR2 ) ; VAR3 [ VAR2 ] = ' ' ; return ( VAR3 ) ; } #1
381#381#static void FUN1 ( void ( * VAR1 ) ( char * * , VAR2 * , VAR2 * , int ) , char * * VAR3 , VAR2 * VAR4 , VAR2 * VAR5 , LDOUBLE VAR6 , int VAR7 , int VAR8 , int VAR9 ) { int VAR10 = 0 ; LDOUBLE VAR11 ; char VAR12 [ 20 ] ; char VAR13 [ 20 ] ; int VAR14 = 0 ; int VAR15 = 0 ; int VAR16 = 0 ; int VAR17 = 0 ; int VAR18 = 0 ; long VAR19 ; long VAR20 ; if ( VAR8 < 0 ) VAR8 = 6 ; VAR11 = FUN2 ( VAR6 ) ; if ( VAR6 < 0 ) VAR10 = ' ' ; else if ( VAR9 & VAR21 ) VAR10 = ' ' ; else if ( VAR9 & VAR22 ) VAR10 = ' ' ; VAR19 = ( long ) VAR11 ; if ( VAR8 > 9 ) VAR8 = 9 ; VAR20 = FUN3 ( ( FUN4 ( VAR8 ) ) * ( VAR11 - VAR19 ) ) ; if ( VAR20 >= FUN4 ( VAR8 ) ) { VAR19 ++ ; VAR20 -= ( long ) FUN4 ( VAR8 ) ; } do { VAR12 [ VAR14 ++ ] = ( VAR18 ? ) [ VAR19 % 10 ] ; VAR19 = ( VAR19 / 10 ) ; } while ( VAR19 && ( VAR14 < 20 ) ) ; if ( VAR14 == 20 ) VAR14 -- ; VAR12 [ VAR14 ] = 0 ; do { VAR13 [ VAR15 ++ ] = ( VAR18 ? ) [ VAR20 % 10 ] ; VAR20 = ( VAR20 / 10 ) ; } while ( VAR20 && ( VAR15 < 20 ) ) ; if ( VAR15 == 20 ) VAR15 -- ; VAR13 [ VAR15 ] = 0 ; VAR16 = VAR7 - VAR14 - VAR8 - 1 - ( ( VAR10 ) ? 1 : 0 ) ; VAR17 = VAR8 - VAR15 ; if ( VAR17 < 0 ) VAR17 = 0 ; if ( VAR16 < 0 ) VAR16 = 0 ; if ( VAR9 & VAR23 ) VAR16 = - VAR16 ; if ( ( VAR9 & VAR24 ) && ( VAR16 > 0 ) ) { if ( VAR10 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , VAR10 ) ; -- VAR16 ; VAR10 = 0 ; } while ( VAR16 > 0 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , ' ' ) ; -- VAR16 ; } } while ( VAR16 > 0 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , ' ' ) ; -- VAR16 ; } if ( VAR10 ) ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , VAR10 ) ; while ( VAR14 > 0 ) ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , VAR12 [ -- VAR14 ] ) ; if ( VAR8 > 0 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , ' ' ) ; while ( VAR15 > 0 ) ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , VAR13 [ -- VAR15 ] ) ; } while ( VAR17 > 0 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , ' ' ) ; -- VAR17 ; } while ( VAR16 < 0 ) { ( * VAR1 ) ( VAR3 , VAR4 , VAR5 , ' ' ) ; ++ VAR16 ; } } #0
382#382#void * FUN1 ( VAR1 * VAR2 , void * VAR3 ) { unsigned long VAR4 ; VAR5 * VAR6 , * * VAR7 ; void * VAR8 ; VAR2 -> VAR9 = 0 ; VAR7 = FUN2 ( VAR2 , VAR3 , & VAR4 ) ; if ( * VAR7 == NULL ) { VAR2 -> VAR10 ++ ; return ( NULL ) ; } else { VAR6 = * VAR7 ; * VAR7 = VAR6 -> VAR11 ; VAR8 = VAR6 -> VAR3 ; FUN3 ( VAR6 ) ; VAR2 -> VAR12 ++ ; } VAR2 -> VAR13 -- ; if ( ( VAR2 -> VAR14 > VAR15 ) && ( VAR2 -> VAR16 >= ( VAR2 -> VAR13 * VAR17 / VAR2 -> VAR14 ) ) ) FUN4 ( VAR2 ) ; return ( VAR8 ) ; } #1
383#383#static av_always_inline int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { int VAR6 , VAR7 ; int VAR8 = 0 ; if ( VAR5 ) { if ( VAR3 == 0 ) { VAR6 = VAR2 -> VAR9 & 0x100 ; VAR7 = VAR2 -> VAR10 & 0x100 ; } else { VAR6 = ( VAR2 -> VAR9 >> ( 6 + VAR4 ) ) & 0x01 ; VAR7 = ( VAR2 -> VAR10 >> ( 6 + VAR4 ) ) & 0x01 ; } } else { if ( VAR3 == 1 || VAR3 == 2 ) { VAR6 = VAR2 -> VAR11 [ VAR12 [ VAR4 ] - 1 ] ; VAR7 = VAR2 -> VAR11 [ VAR12 [ VAR4 ] - 8 ] ; } else { assert ( VAR3 == 4 ) ; VAR6 = VAR2 -> VAR11 [ VAR12 [ 16 + VAR4 ] - 1 ] ; VAR7 = VAR2 -> VAR11 [ VAR12 [ 16 + VAR4 ] - 8 ] ; } } if ( VAR6 > 0 ) VAR8 ++ ; if ( VAR7 > 0 ) VAR8 += 2 ; return VAR8 + 4 * VAR3 ; } #0
384#384#void FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 ; VAR5 * VAR6 ; if ( ! VAR2 ) return ; FUN2 ( VAR2 ) ; if ( VAR2 -> VAR7 && VAR2 -> VAR7 -> VAR8 && VAR2 -> VAR9 ) FUN2 ( VAR2 -> VAR9 ) ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR10 ; VAR3 ++ ) { VAR6 = VAR2 -> VAR11 [ VAR3 ] ; for ( VAR4 = 0 ; VAR4 < VAR6 -> VAR12 ; VAR4 ++ ) FUN3 ( & VAR6 -> VAR13 [ VAR4 ] . VAR14 ) ; FUN3 ( & VAR6 -> VAR13 ) ; VAR6 -> VAR12 = 0 ; if ( VAR6 -> VAR15 ) { FUN4 ( VAR6 -> VAR15 ) ; } if ( VAR6 -> VAR16 . VAR14 ) FUN5 ( & VAR6 -> VAR16 ) ; FUN6 ( & VAR6 -> VAR17 ) ; FUN3 ( & VAR6 -> VAR18 . VAR19 ) ; FUN7 ( VAR6 -> VAR20 ) ; FUN7 ( VAR6 -> VAR21 -> VAR22 ) ; FUN7 ( VAR6 -> VAR21 -> VAR23 ) ; FUN7 ( VAR6 -> VAR21 ) ; FUN7 ( VAR6 -> VAR9 ) ; FUN7 ( VAR6 -> VAR24 ) ; FUN7 ( VAR6 ) ; } for ( VAR3 = VAR2 -> VAR25 - 1 ; VAR3 >= 0 ; VAR3 -- ) { FUN6 ( & VAR2 -> VAR26 [ VAR3 ] -> VAR17 ) ; FUN3 ( & VAR2 -> VAR26 [ VAR3 ] -> VAR27 ) ; FUN3 ( & VAR2 -> VAR26 [ VAR3 ] ) ; } FUN3 ( & VAR2 -> VAR26 ) ; FUN3 ( & VAR2 -> VAR9 ) ; while ( VAR2 -> VAR28 -- ) { FUN6 ( & VAR2 -> VAR29 [ VAR2 -> VAR28 ] -> VAR17 ) ; FUN7 ( VAR2 -> VAR29 [ VAR2 -> VAR28 ] ) ; } FUN3 ( & VAR2 -> VAR29 ) ; FUN6 ( & VAR2 -> VAR17 ) ; FUN3 ( & VAR2 -> VAR11 ) ; FUN3 ( & VAR2 -> VAR30 ) ; FUN7 ( VAR2 ) ; } #1
385#385#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const char * VAR5 , VAR6 * * VAR7 , int * VAR8 , const VAR6 * VAR9 , int VAR10 , int VAR11 ) { if ( VAR10 < 2 ) return 0 ; * VAR8 = FUN2 ( VAR10 - 2 , FUN3 ( VAR9 ) ) ; * VAR7 = FUN4 ( * VAR8 + VAR12 ) ; if ( ! * VAR7 ) return FUN5 ( VAR13 ) ; memcpy ( * VAR7 , VAR9 + 2 , * VAR8 ) ; return 1 ; } #0
386#386#void FUN1 ( void * VAR1 ) { void * VAR2 ; memcpy ( & VAR2 , VAR1 , sizeof ( VAR2 ) ) ; memcpy ( VAR1 , & ( void * ) { NULL } , sizeof ( VAR2 ) ) ; FUN2 ( VAR2 ) ; } #1
387#387#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = NULL ; unsigned char * VAR7 , * VAR8 ; int VAR9 ; VAR9 = FUN2 ( VAR4 , NULL ) ; if ( ( VAR8 = FUN3 ( VAR9 ) ) == NULL ) goto VAR10 ; VAR7 = VAR8 ; FUN2 ( VAR4 , & VAR7 ) ; if ( ! ( VAR6 = FUN4 ( ) ) || ! FUN5 ( VAR6 , VAR8 , VAR9 ) ) goto VAR10 ; FUN6 ( VAR8 ) ; VAR8 = NULL ; if ( ! FUN7 ( VAR2 , VAR11 , VAR12 , VAR6 , -1 ) ) goto VAR10 ; FUN8 ( VAR6 ) ; return 1 ; VAR10 : FUN9 ( VAR13 , VAR14 ) ; FUN8 ( VAR6 ) ; FUN6 ( VAR8 ) ; return 0 ; } #0
388#388#static void FUN1 ( int VAR1 ) { int VAR2 ; for ( VAR2 = 0 ; VAR1 && VAR2 < VAR3 ; ++ VAR2 ) { if ( VAR4 -> VAR5 [ VAR2 ] . VAR6 != 0 ) { continue ; } if ( FUN2 ( VAR7 , VAR2 , VAR2 % VAR8 -> VAR9 ) < 0 ) { break ; } -- VAR1 ; } } #1
389#389#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , uint16 VAR7 , uint32 VAR8 , float * VAR9 ) { static const char VAR10 [ ] = ) ; return ( 0 ) ; } for ( VAR12 = VAR9 , VAR13 = VAR11 , VAR14 = 0 ; VAR14 < VAR8 ; VAR12 ++ , VAR13 += 2 , VAR14 ++ ) { if ( * VAR12 <= 0.0 || * VAR12 != * VAR12 ) { VAR13 [ 0 ] = 0 ; VAR13 [ 1 ] = 1 ; } else if ( * VAR12 >= 0 && * VAR12 <= ( float ) 0xFFFFFFFFU && * VAR12 == ( float ) ( VAR3 ) ( * VAR12 ) ) { VAR13 [ 0 ] = ( VAR3 ) ( * VAR12 ) ; VAR13 [ 1 ] = 1 ; } else if ( * VAR12 < 1.0 ) { VAR13 [ 0 ] = ( VAR3 ) ( ( double ) ( * VAR12 ) * 0xFFFFFFFF ) ; VAR13 [ 1 ] = 0xFFFFFFFF ; } else { VAR13 [ 0 ] = 0xFFFFFFFF ; VAR13 [ 1 ] = ( VAR3 ) ( ( double ) 0xFFFFFFFF / ( * VAR12 ) ) ; } } if ( VAR2 -> VAR17 & VAR18 ) FUN4 ( VAR11 , VAR8 * 2 ) ; VAR15 = FUN5 ( VAR2 , VAR4 , VAR6 , VAR7 , VAR19 , VAR8 , VAR8 * 8 , & VAR11 [ 0 ] ) ; FUN6 ( VAR11 ) ; return ( VAR15 ) ; } #1
390#390#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; int VAR9 ; if ( ! ( VAR2 -> VAR10 & VAR11 ) ) { VAR9 = FUN2 ( VAR7 -> VAR12 , 0 ) ; if ( VAR9 < 0 ) return VAR9 ; } VAR9 = recv ( VAR7 -> VAR12 , VAR4 , VAR5 , 0 ) ; return VAR9 < 0 ? FUN3 ( ) : VAR9 ; } #0
391#391#"static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , ngx_uint_t VAR5 ) { ngx_uint_t VAR6 , VAR7 ; FUN2 ( VAR8 , VAR2 -> VAR9 -> VAR10 , 0 , ) ; } if ( VAR4 -> VAR11 . VAR21 && VAR5 == VAR22 ) { VAR6 = 0 ; VAR4 -> VAR11 . VAR23 ++ ; } else { switch ( VAR5 ) { case VAR18 : VAR6 = VAR24 ; break ; case VAR25 : VAR6 = VAR26 ; break ; case VAR13 : VAR6 = VAR27 ; break ; case VAR14 : VAR6 = VAR28 ; break ; default : VAR6 = VAR29 ; } } if ( VAR2 -> VAR9 -> VAR30 ) { FUN4 ( VAR2 , VAR4 , VAR31 ) ; return ; } if ( VAR6 ) { VAR4 -> VAR7 -> VAR6 = VAR6 ; if ( VAR4 -> VAR11 . VAR23 == 0 || ! ( VAR4 -> VAR32 -> VAR33 & VAR5 ) ) { #if ( VAR34 ) if ( VAR4 - > VAR35 == VAR36 && ( VAR4 - > VAR32 - > VAR37 & VAR5 ) ) { ngx_int_t VAR38 ; VAR38 = VAR4 - > FUN5 ( VAR2 ) ; if ( VAR38 == VAR39 ) { VAR4 - > VAR35 = VAR40 ; VAR38 = FUN6 ( VAR2 , VAR4 ) ; } FUN4 ( VAR2 , VAR4 , VAR38 ) ; return ; } #endif FUN4(VAR2, VAR4, VAR6); return; } }  if (VAR4->VAR11.VAR9) { FUN2(VAR8, VAR2->VAR9->VAR10, 0, """", VAR4->VAR11.VAR9->VAR41); #if (VAR42)  if (VAR4->VAR11.VAR9->VAR43) { VAR4->VAR11.VAR9->VAR43->VAR44 = 1; VAR4->VAR11.VAR9->VAR43->VAR45 = 1;  (void) FUN7(VAR4->VAR11.VAR9); } #endif  if (VAR4->VAR11.VAR9->VAR46) { FUN8(VAR4->VAR11.VAR9->VAR46); }  FUN9(VAR4->VAR11.VAR9); VAR4->VAR11.VAR9 = NULL; }  FUN10(VAR2, VAR4); } "#1
392#392#int FUN1 ( const VAR1 * VAR2 , VAR3 * VAR4 ) { static const size_t VAR5 = sizeof ( ) - 1 ; VAR1 * VAR7 = NULL ; int VAR8 , VAR9 , VAR10 , VAR11 = 0 ; switch ( VAR2 -> VAR12 ) { case VAR13 : if ( VAR2 -> VAR14 != ( int ) ( VAR5 ) ) return 0 ; break ; case VAR15 : if ( VAR2 -> VAR14 != ( int ) ( VAR6 ) ) return 0 ; break ; default : return 0 ; } for ( VAR8 = 0 ; VAR8 < VAR2 -> VAR14 - 1 ; VAR8 ++ ) { if ( ! FUN2 ( VAR2 -> VAR16 [ VAR8 ] ) ) return 0 ; } if ( VAR2 -> VAR16 [ VAR2 -> VAR14 - 1 ] != ' ' ) return 0 ; VAR7 = FUN3 ( NULL , 0 , VAR4 ) ; if ( VAR7 == NULL ) goto VAR17 ; if ( ! FUN4 ( & VAR9 , & VAR10 , VAR2 , VAR7 ) ) goto VAR17 ; VAR11 = ( VAR9 >= 0 && VAR10 >= 0 ) ? -1 : 1 ; VAR17 : FUN5 ( VAR7 ) ; return VAR11 ; } #1
393#393#int FUN1 ( VAR1 * VAR2 ) { if ( VAR2 -> VAR3 < VAR2 -> VAR4 ) { return * VAR2 -> VAR3 ++ ; } else { FUN2 ( VAR2 ) ; if ( VAR2 -> VAR3 < VAR2 -> VAR4 ) return * VAR2 -> VAR3 ++ ; else return VAR5 ; } } #1
394#394#static inline void FUN1 ( VAR1 * VAR2 , size_t VAR3 ) { VAR2 -> VAR4 += VAR3 ; VAR2 -> VAR5 -= VAR3 ; } #1
395#395#"VAR1 FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 , int VAR5 ) { BN_ULONG VAR6 , VAR7 ; int VAR8 = 0 ; assert ( VAR5 >= 0 ) ; if ( VAR5 <= 0 ) return ( ( VAR1 ) 0 ) ; #ifndef OPENSSL_SMALL_FOOTPRINT while ( VAR5 & ~ 3 ) { VAR6 = VAR3 [ 0 ] ; VAR7 = VAR4 [ 0 ] ; VAR2 [ 0 ] = ( VAR6 - VAR7 - VAR8 ) & VAR9 ; if ( VAR6 != VAR7 ) VAR8 = ( VAR6 < VAR7 ) ; VAR6 = VAR3 [ 1 ] ; VAR7 = VAR4 [ 1 ] ; VAR2 [ 1 ] = ( VAR6 - VAR7 - VAR8 ) & VAR9 ; if ( VAR6 != VAR7 ) VAR8 = ( VAR6 < VAR7 ) ; VAR6 = VAR3 [ 2 ] ; VAR7 = VAR4 [ 2 ] ; VAR2 [ 2 ] = ( VAR6 - VAR7 - VAR8 ) & VAR9 ; if ( VAR6 != VAR7 ) VAR8 = ( VAR6 < VAR7 ) ; VAR6 = VAR3 [ 3 ] ; VAR7 = VAR4 [ 3 ] ; VAR2 [ 3 ] = ( VAR6 - VAR7 - VAR8 ) & VAR9 ; if ( VAR6 != VAR7 ) VAR8 = ( VAR6 < VAR7 ) ; VAR3 += 4 ; VAR4 += 4 ; VAR2 += 4 ; VAR5 -= 4 ; } #endif while ( VAR5 ) { VAR6 = VAR3 [ 0 ] ; VAR7 = VAR4 [ 0 ] ; VAR2 [ 0 ] = ( VAR6 - VAR7 - VAR8 ) & VAR9 ; if ( VAR6 != VAR7 ) VAR8 = ( VAR6 < VAR7 ) ; VAR3 ++ ; VAR4 ++ ; VAR2 ++ ; VAR5 -- ; } return ( VAR8 ) ; } "#1
396#396#void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { uint64_t VAR5 = 0 ; int VAR6 , VAR7 ; VAR2 -> VAR8 = FUN2 ( VAR4 , VAR9 ) ; FUN3 ( VAR4 , VAR10 ) ; VAR6 = FUN2 ( VAR4 , VAR11 ) ; VAR2 -> VAR12 = FUN4 ( VAR4 , VAR13 ) ; VAR2 -> VAR14 = FUN2 ( VAR4 , VAR15 ) ; VAR2 -> VAR16 = FUN2 ( VAR4 , VAR17 ) + VAR18 ; VAR2 -> VAR19 = FUN2 ( VAR4 , VAR20 ) + VAR21 ; VAR2 -> VAR22 = FUN2 ( VAR4 , VAR23 ) + VAR24 ; if ( FUN5 ( VAR4 ) ) { FUN3 ( VAR4 , VAR25 ) ; if ( FUN5 ( VAR4 ) ) { for ( VAR7 = 0 ; VAR7 < VAR2 -> VAR22 ; VAR7 ++ ) { int VAR26 = FUN2 ( VAR4 , VAR27 ) ; if ( VAR26 < FUN6 ( VAR28 ) ) VAR5 |= VAR28 [ VAR26 ] ; } } } VAR2 -> VAR29 = VAR5 ; VAR2 -> VAR30 = FUN7 ( VAR2 -> VAR16 , VAR6 ) ; } #0
397#397#"VAR1 FUN1 ( VAR2 * VAR3 , VAR2 * VAR4 , size_t VAR5 , ngx_uint_t VAR6 ) { ngx_uint_t VAR7 ; VAR8 * VAR9 ; static u_char VAR10 [ ] = "" "" ; static uint32_t VAR11 [ ] = { 0xffffffff , 0x80000029 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR12 [ ] = { 0xffffffff , 0x80000829 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR13 [ ] = { 0xffffffff , 0x000000ad , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR14 [ ] = { 0xffffffff , 0x00000085 , 0x00000000 , 0x80000000 , 0xffffffff , 0xffffffff , 0xffffffff , 0xffffffff } ; static uint32_t VAR15 [ ] = { 0xffffffff , 0x00000021 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , 0x00000000 , } ; static VAR8 * VAR16 [ ] = { VAR11 , VAR12 , VAR13 , VAR14 , VAR15 , VAR15 } ; VAR9 = VAR16 [ VAR6 ] ; if ( VAR3 == NULL ) { VAR7 = 0 ; while ( VAR5 ) { if ( VAR9 [ * VAR4 >> 5 ] & ( 1 << ( * VAR4 & 0x1f ) ) ) { VAR7 ++ ; } VAR4 ++ ; VAR5 -- ; } return ( VAR1 ) VAR7 ; } while ( VAR5 ) { if ( VAR9 [ * VAR4 >> 5 ] & ( 1 << ( * VAR4 & 0x1f ) ) ) { * VAR3 ++ = ' ' ; * VAR3 ++ = VAR10 [ * VAR4 >> 4 ] ; * VAR3 ++ = VAR10 [ * VAR4 & 0xf ] ; VAR4 ++ ; } else { * VAR3 ++ = * VAR4 ++ ; } VAR5 -- ; } return ( VAR1 ) VAR3 ; } "#0
398#398#static int FUN1 ( int VAR1 , const char * VAR2 , const char * VAR3 ) { int VAR4 = 0 ; const char VAR5 [ ] = , FUN8 ( VAR1 ) ) ; if ( ! FUN2 ( VAR11 = FUN9 ( VAR1 ) ) ) goto VAR21 ; VAR22 = 1 ; if ( ! FUN4 ( FUN10 ( VAR11 ) ) ) goto VAR21 ; VAR22 = 1 ; if ( ! FUN4 ( FUN11 ( VAR11 , NULL , & VAR17 , & VAR18 ) ) ) goto VAR21 ; if ( ! FUN2 ( VAR13 = FUN12 ( VAR6 , 20 , VAR17 , VAR18 , VAR11 ) ) ) goto VAR21 ; if ( ! FUN2 ( VAR15 = FUN13 ( ) ) || ! FUN2 ( VAR16 = FUN13 ( ) ) ) goto VAR21 ; if ( ! FUN4 ( FUN14 ( & VAR15 , VAR2 ) ) || ! FUN4 ( FUN14 ( & VAR16 , VAR3 ) ) ) goto VAR21 ; FUN15 ( VAR13 , & VAR19 , & VAR20 ) ; if ( ! FUN16 ( FUN17 ( VAR19 , VAR15 ) , 0 ) || ! FUN16 ( FUN17 ( VAR20 , VAR16 ) , 0 ) ) goto VAR21 ; if ( ! FUN16 ( FUN18 ( VAR6 , 20 , VAR13 , VAR11 ) , 1 ) ) goto VAR21 ; VAR4 = 1 ; VAR21 : FUN19 ( VAR11 ) ; FUN20 ( VAR13 ) ; FUN21 ( VAR15 ) ; FUN21 ( VAR16 ) ; FUN22 ( VAR9 ) ; FUN23 ( VAR17 ) ; FUN23 ( VAR18 ) ; return VAR4 ; } #0
399#399#"int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 ; if ( VAR2 -> VAR5 == VAR6 ) { VAR7 * VAR8 [ 32 ] ; int VAR9 , VAR10 ; int VAR11 [ 2 ] ; if ( FUN2 ( VAR2 ) ) VAR9 = VAR2 -> VAR12 -> VAR13 [ VAR2 -> VAR14 == VAR15 ] ; else VAR9 = VAR2 -> VAR12 -> VAR16 ; for ( VAR10 = 0 ; VAR10 < 2 ; VAR10 ++ ) { VAR4 = FUN3 ( VAR8 , VAR2 -> VAR17 , VAR2 -> VAR18 , VAR9 , 1 ^ VAR10 ) ; VAR4 += FUN3 ( VAR8 + VAR4 , VAR2 -> VAR17 , VAR2 -> VAR18 , VAR9 , 0 ^ VAR10 ) ; FUN4 ( VAR4 <= 32 ) ; VAR4 = FUN5 ( VAR2 -> VAR19 [ VAR10 ] , VAR8 , VAR4 , 0 , VAR2 -> VAR14 ) ; VAR4 += FUN5 ( VAR2 -> VAR19 [ VAR10 ] + VAR4 , VAR2 -> VAR20 , 16 , 1 , VAR2 -> VAR14 ) ; FUN4 ( VAR4 <= 32 ) ; if ( VAR4 < VAR2 -> VAR21 [ VAR10 ] ) memset ( & VAR2 -> VAR19 [ VAR10 ] [ VAR4 ] , 0 , sizeof ( VAR7 ) * ( VAR2 -> VAR21 [ VAR10 ] - VAR4 ) ) ; VAR11 [ VAR10 ] = VAR4 ; } if ( VAR11 [ 0 ] == VAR11 [ 1 ] && VAR11 [ 1 ] > 1 ) { for ( VAR3 = 0 ; VAR2 -> VAR19 [ 0 ] [ VAR3 ] . VAR22 . VAR23 [ 0 ] == VAR2 -> VAR19 [ 1 ] [ VAR3 ] . VAR22 . VAR23 [ 0 ] && VAR3 < VAR11 [ 0 ] ; VAR3 ++ ) ; if ( VAR3 == VAR11 [ 0 ] ) { Picture VAR24 ; FUN6 ( & VAR24 , & VAR2 -> VAR19 [ 1 ] [ 0 ] ) ; FUN6 ( & VAR2 -> VAR19 [ 1 ] [ 0 ] , & VAR2 -> VAR19 [ 1 ] [ 1 ] ) ; FUN6 ( & VAR2 -> VAR19 [ 1 ] [ 1 ] , & VAR24 ) ; } } } else { VAR4 = FUN5 ( VAR2 -> VAR19 [ 0 ] , VAR2 -> VAR17 , VAR2 -> VAR18 , 0 , VAR2 -> VAR14 ) ; VAR4 += FUN5 ( VAR2 -> VAR19 [ 0 ] + VAR4 , VAR2 -> VAR20 , 16 , 1 , VAR2 -> VAR14 ) ; FUN4 ( VAR4 <= 32 ) ; if ( VAR4 < VAR2 -> VAR21 [ 0 ] ) memset ( & VAR2 -> VAR19 [ 0 ] [ VAR4 ] , 0 , sizeof ( VAR7 ) * ( VAR2 -> VAR21 [ 0 ] - VAR4 ) ) ; } #ifdef TRACE for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR21 [ 0 ] ; VAR3 ++ ) { FUN7 ( VAR2 -> VAR25 , : , ( VAR2 -> VAR19 [ 1 ] [ VAR3 ] . VAR20 ? ) , VAR2 -> VAR19 [ 1 ] [ VAR3 ] . VAR26 , VAR2 -> VAR19 [ 1 ] [ VAR3 ] . VAR22 . VAR23 [ 0 ] ) ; } } #endif return 0 ; } "#1
400#400#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { const VAR7 * VAR8 = VAR6 -> VAR3 ; int VAR9 = VAR6 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR13 ; VAR14 * VAR15 = VAR3 ; GetBitContext VAR16 ; int VAR17 , VAR18 ; VAR17 = VAR9 * 8 / VAR12 -> VAR19 ; VAR18 = VAR17 * FUN2 ( VAR2 -> VAR20 ) ; if ( * VAR4 < VAR18 ) { FUN3 ( VAR2 , VAR21 , ) ; * VAR4 = VAR18 ; return VAR9 ; } #0
401#401#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; int VAR6 , VAR7 ; if ( VAR2 -> VAR8 <= 0 || VAR2 -> VAR8 > 8 ) return VAR9 ; for ( VAR6 = 0 ; VAR6 < ( VAR2 -> VAR8 + 1 ) / 2 ; VAR6 ++ ) { VAR7 = FUN2 ( & VAR4 -> VAR10 [ VAR6 ] , VAR2 ) ; if ( VAR7 < 0 ) return VAR7 ; VAR4 -> VAR11 [ VAR6 ] = FUN3 ( ) ; if ( ! VAR4 -> VAR11 [ VAR6 ] ) return FUN4 ( VAR12 ) ; VAR4 -> VAR11 [ VAR6 ] -> VAR13 = 512 ; if ( ( VAR7 = FUN5 ( VAR2 , VAR4 -> VAR11 [ VAR6 ] , 0 ) ) < 0 ) { return FUN4 ( VAR12 ) ; } } return VAR7 ; } #0
402#402#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , int VAR9 , uint64_t VAR10 , int64_t VAR11 ) { int VAR12 = VAR6 -> VAR13 -> VAR14 ; int VAR15 = VAR4 -> VAR16 . VAR17 ; int VAR18 = VAR4 -> VAR16 . VAR19 ; int VAR20 = VAR4 -> VAR16 . VAR21 ; int VAR22 = VAR4 -> VAR16 . VAR23 ; int VAR24 = VAR4 -> VAR16 . VAR25 ; int VAR26 ; if ( ! VAR4 -> VAR16 . VAR27 ) { if ( VAR4 -> VAR16 . VAR23 == 0 ) VAR4 -> VAR16 . VAR28 = VAR10 ; if ( VAR6 -> VAR13 -> VAR29 == VAR30 ) { if ( VAR9 < VAR18 * VAR20 / 2 ) { FUN2 ( VAR2 -> VAR31 , VAR32 , ) ; return VAR33 ; } memcpy ( VAR4 -> VAR16 . VAR34 + VAR22 * VAR24 , VAR8 , VAR24 ) ; } else { if ( VAR9 < VAR15 * VAR24 / VAR15 ) { FUN2 ( VAR2 -> VAR31 , VAR32 , "" "" ) ; return VAR33 ; } for ( VAR26 = 0 ; VAR26 < VAR24 / VAR15 ; VAR26 ++ ) memcpy ( VAR4 -> VAR16 . VAR34 + VAR15 * ( VAR20 * VAR26 + ( ( VAR20 + 1 ) / 2 ) * ( VAR22 & 1 ) + ( VAR22 >> 1 ) ) , VAR8 + VAR26 * VAR15 , VAR15 ) ; } if ( ++ VAR4 -> VAR16 . VAR23 >= VAR20 ) { if ( VAR6 -> VAR13 -> VAR29 == VAR35 ) FUN3 ( VAR4 -> VAR16 . VAR34 , VAR20 , VAR24 ) ; VAR4 -> VAR16 . VAR23 = 0 ; VAR4 -> VAR16 . VAR27 = VAR20 * VAR24 / VAR12 ; } } while ( VAR4 -> VAR16 . VAR27 ) { VAR36 * VAR37 = NULL ; if ( ! ( VAR37 = FUN4 ( sizeof ( VAR36 ) ) ) || FUN5 ( VAR37 , VAR12 ) < 0 ) { FUN6 ( VAR37 ) ; return FUN7 ( VAR38 ) ; } memcpy ( VAR37 -> VAR8 , VAR4 -> VAR16 . VAR34 + VAR12 * ( VAR20 * VAR24 / VAR12 - VAR4 -> VAR16 . VAR27 -- ) , VAR12 ) ; VAR37 -> VAR39 = VAR4 -> VAR16 . VAR28 ; VAR4 -> VAR16 . VAR28 = VAR40 ; VAR37 -> VAR11 = VAR11 ; VAR37 -> VAR41 = VAR6 -> VAR42 ; FUN8 ( & VAR2 -> VAR43 , & VAR2 -> VAR44 , VAR37 ) ; } return 0 ; } "#1
403#403#char * FUN1 ( VAR1 * VAR2 , char * VAR3 ) { int VAR4 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR5 ; VAR4 ++ ) if ( VAR2 -> VAR6 [ VAR4 ] == VAR3 ) return ( FUN2 ( VAR2 , VAR4 ) ) ; return ( NULL ) ; } #1
404#404#VAR1 * FUN1 ( const unsigned char * VAR2 , size_t VAR3 ) { while ( * VAR2 == 0 && VAR3 > 0 ) { VAR2 ++ ; VAR3 -- ; } if ( VAR3 ) { return FUN2 ( VAR2 , VAR3 , NULL ) ; } else { VAR1 * VAR4 = FUN3 ( ) ; FUN4 ( VAR4 ) ; return VAR4 ; } } #1
405#405#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { VAR1 * VAR6 , * VAR7 , * VAR8 , * VAR9 ; int VAR10 ; VAR1 * VAR11 ; VAR11 = FUN2 ( VAR4 ) ; VAR6 = VAR2 ; memcpy ( VAR11 , VAR6 , VAR4 ) ; VAR7 = & VAR6 [ VAR3 ] ; VAR8 = & VAR7 [ VAR3 ] ; VAR9 = & VAR8 [ VAR3 ] ; for ( VAR10 = 0 ; VAR10 < ( VAR5 - 2 ) ; VAR10 += 2 ) { FUN3 ( VAR11 , VAR6 , VAR7 , VAR8 , VAR9 , VAR4 ) ; VAR6 = VAR8 ; VAR7 = VAR9 ; VAR8 += 2 * VAR3 ; VAR9 += 2 * VAR3 ; } FUN3 ( VAR11 , VAR6 , VAR7 , VAR7 , VAR7 , VAR4 ) ; FUN4 ( VAR11 ) ; } #1
406#406#int FUN1 ( const char * VAR1 , size_t VAR2 , const unsigned char * VAR3 , size_t VAR4 , uint64_t VAR5 , uint64_t VAR6 , uint64_t VAR7 , uint64_t VAR8 , unsigned char * VAR9 , size_t VAR10 ) { int VAR11 = 0 ; unsigned char * VAR12 ; VAR13 * VAR14 , * VAR15 , * VAR16 ; uint64_t VAR17 , VAR18 , VAR19 ; if ( VAR6 == 0 || VAR7 == 0 || VAR5 < 2 || ( VAR5 & ( VAR5 - 1 ) ) ) return 0 ; if ( VAR7 > VAR20 / VAR6 ) return 0 ; if ( 16 * VAR6 <= VAR21 ) { if ( VAR5 >= ( ( ( VAR22 ) 1 ) << ( 16 * VAR6 ) ) ) return 0 ; } VAR18 = VAR7 * 128 * VAR6 ; if ( VAR18 > VAR23 ) { FUN2 ( VAR24 , VAR25 ) ; return 0 ; } VAR17 = VAR26 / ( 32 * sizeof ( VAR13 ) ) ; if ( VAR5 + 2 > VAR17 / VAR6 ) return 0 ; VAR19 = 32 * VAR6 * ( VAR5 + 2 ) * sizeof ( VAR13 ) ; if ( VAR18 > VAR26 - VAR19 ) return 0 ; if ( VAR8 == 0 ) VAR8 = VAR27 ; if ( VAR8 > VAR28 ) VAR8 = VAR28 ; if ( VAR18 + VAR19 > VAR8 ) { FUN2 ( VAR24 , VAR25 ) ; return 0 ; } if ( VAR9 == NULL ) return 1 ; VAR12 = FUN3 ( ( VAR29 ) ( VAR18 + VAR19 ) ) ; if ( VAR12 == NULL ) return 0 ; VAR14 = ( VAR13 * ) ( VAR12 + VAR18 ) ; VAR16 = VAR14 + 32 * VAR6 ; VAR15 = VAR16 + 32 * VAR6 ; if ( FUN4 ( VAR1 , VAR2 , VAR3 , VAR4 , 1 , FUN5 ( ) , ( int ) VAR18 , VAR12 ) == 0 ) goto VAR30 ; for ( VAR17 = 0 ; VAR17 < VAR7 ; VAR17 ++ ) FUN6 ( VAR12 + 128 * VAR6 * VAR17 , VAR6 , VAR5 , VAR14 , VAR16 , VAR15 ) ; if ( FUN4 ( VAR1 , VAR2 , VAR12 , ( int ) VAR18 , 1 , FUN5 ( ) , VAR10 , VAR9 ) == 0 ) goto VAR30 ; VAR11 = 1 ; VAR30 : FUN7 ( VAR12 , ( VAR29 ) ( VAR18 + VAR19 ) ) ; return VAR11 ; } #0
407#407#int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , const unsigned char * VAR5 , int VAR6 , const unsigned char * VAR7 , VAR8 * VAR9 ) { unsigned char * VAR10 = NULL ; int VAR11 , VAR12 = 0 , VAR13 = 0 ; if ( VAR4 ) { FUN2 ( VAR2 ) ; if ( ! FUN3 ( VAR2 , VAR4 , NULL , NULL , NULL ) ) return 0 ; } if ( ! VAR9 ) return 1 ; if ( FUN4 ( VAR9 ) != VAR14 ) { FUN5 ( VAR15 , VAR16 ) ; goto VAR17 ; } VAR12 = FUN6 ( VAR9 ) ; VAR10 = FUN7 ( VAR12 + 2 ) ; if ( VAR10 == NULL ) { FUN5 ( VAR15 , VAR18 ) ; goto VAR17 ; } VAR11 = FUN8 ( VAR10 , VAR5 , VAR6 , VAR9 ) ; if ( ( VAR11 <= 0 ) || ! FUN9 ( VAR2 , VAR11 ) ) { goto VAR17 ; } if ( ! FUN3 ( VAR2 , NULL , NULL , VAR10 , VAR7 ) ) goto VAR17 ; VAR13 = 1 ; VAR17 : FUN10 ( VAR10 , VAR12 ) ; return VAR13 ; } #1
408#408#static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , VAR3 * VAR5 , const VAR3 * VAR6 , int VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR10 ; int VAR11 , VAR12 ; const VAR3 * VAR13 ; FUN2 ( VAR4 , 0x2c ) ; FUN3 ( VAR4 , 0 ) ; FUN3 ( VAR4 , 0 ) ; FUN3 ( VAR4 , VAR2 -> VAR14 ) ; FUN3 ( VAR4 , VAR2 -> VAR12 ) ; FUN2 ( VAR4 , 0x00 ) ; FUN2 ( VAR4 , 0x08 ) ; FUN4 ( VAR9 -> VAR15 , VAR9 -> VAR6 , VAR2 -> VAR14 * VAR2 -> VAR12 , 12 , VAR16 , VAR17 ) ; VAR13 = VAR6 ; for ( VAR12 = VAR2 -> VAR12 ; VAR12 -- ; ) { VAR11 += FUN5 ( VAR9 -> VAR15 , VAR13 , VAR2 -> VAR14 ) ; VAR13 += VAR7 ; } VAR11 += FUN6 ( VAR9 -> VAR15 , VAR18 ) ; VAR13 = VAR9 -> VAR6 ; while ( VAR11 > 0 ) { int VAR19 = FUN7 ( 255 , VAR11 ) ; FUN2 ( VAR4 , VAR19 ) ; if ( VAR5 - * VAR4 < VAR19 ) return -1 ; FUN8 ( VAR4 , VAR13 , VAR19 ) ; VAR13 += VAR19 ; VAR11 -= VAR19 ; } FUN2 ( VAR4 , 0x00 ) ; FUN2 ( VAR4 , 0x3b ) ; return 0 ; } #1
409#409#static av_always_inline void FUN1 ( const VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , const int16_t VAR6 [ 7 ] , int VAR7 , int VAR8 , int VAR9 , int VAR10 , int VAR11 ) { const unsigned int VAR12 = VAR8 + VAR9 ; const int VAR13 = VAR14 [ VAR12 ] ; const int VAR15 = VAR16 [ VAR8 + VAR10 ] ; if ( VAR13 == 0 || VAR15 == 0 ) return ; if ( VAR6 [ 0 ] < 4 || ! VAR11 ) { int8_t VAR17 [ 4 ] ; VAR17 [ 0 ] = VAR18 [ VAR12 ] [ VAR6 [ 0 * VAR7 ] ] + 1 ; VAR17 [ 1 ] = VAR18 [ VAR12 ] [ VAR6 [ 1 * VAR7 ] ] + 1 ; VAR17 [ 2 ] = VAR18 [ VAR12 ] [ VAR6 [ 2 * VAR7 ] ] + 1 ; VAR17 [ 3 ] = VAR18 [ VAR12 ] [ VAR6 [ 3 * VAR7 ] ] + 1 ; VAR2 -> VAR19 . FUN2 ( VAR4 , VAR5 , VAR13 , VAR15 , VAR17 ) ; } else { VAR2 -> VAR19 . FUN3 ( VAR4 , VAR5 , VAR13 , VAR15 ) ; } } #1
410#410#"static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 ; VAR5 * VAR6 ; VAR7 * VAR8 ; VAR9 * VAR10 ; VAR11 * VAR12 ; VAR13 * VAR14 ; VAR15 * VAR16 ; VAR17 * VAR18 ; VAR19 * VAR20 ; VAR8 = VAR2 -> VAR21 ; if ( VAR2 -> VAR22 ) { FUN2 ( VAR23 , VAR8 -> VAR24 , VAR25 , "" "" ) ; FUN3 ( VAR8 ) ; return ; } VAR8 -> VAR26 ++ ; VAR14 = VAR8 -> VAR21 ; VAR16 = FUN4 ( VAR14 -> VAR27 , VAR28 ) ; VAR4 = FUN5 ( VAR16 -> VAR29 , VAR8 -> VAR24 ) ; if ( VAR4 == NULL ) { FUN3 ( VAR8 ) ; return ; } VAR10 = FUN6 ( VAR4 , sizeof ( VAR9 ) ) ; if ( VAR10 == NULL ) { FUN7 ( VAR4 ) ; FUN3 ( VAR8 ) ; return ; } VAR10 -> VAR4 = VAR4 ; VAR10 -> VAR30 = VAR14 -> VAR30 ; VAR8 -> VAR21 = VAR10 ; VAR10 -> VAR31 = VAR14 ; VAR8 -> VAR32 = 0 ; VAR10 -> VAR33 = VAR34 ; VAR10 -> VAR35 = VAR8 ; VAR10 -> VAR36 = VAR14 -> VAR27 -> VAR36 ; VAR10 -> VAR37 = VAR14 -> VAR27 -> VAR37 ; VAR10 -> VAR38 = VAR14 -> VAR27 -> VAR38 ; VAR10 -> VAR39 = VAR40 ; VAR18 = FUN8 ( VAR10 , VAR28 ) ; FUN9 ( VAR10 -> VAR35 , VAR18 -> VAR41 ) ; if ( VAR8 -> VAR42 == NULL ) { VAR8 -> VAR42 = FUN10 ( VAR8 -> VAR4 , VAR16 -> VAR43 ) ; if ( VAR8 -> VAR42 == NULL ) { FUN7 ( VAR10 -> VAR4 ) ; FUN3 ( VAR8 ) ; return ; } } VAR10 -> VAR44 = VAR14 -> VAR45 ? VAR14 -> VAR46 [ 0 ] : VAR8 -> VAR42 ; if ( FUN11 ( & VAR10 -> VAR47 . VAR48 , VAR10 -> VAR4 , 20 , sizeof ( VAR49 ) ) != VAR50 ) { FUN7 ( VAR10 -> VAR4 ) ; FUN3 ( VAR8 ) ; return ; } VAR10 -> VAR12 = FUN6 ( VAR10 -> VAR4 , sizeof ( void * ) * VAR51 ) ; if ( VAR10 -> VAR12 == NULL ) { FUN7 ( VAR10 -> VAR4 ) ; FUN3 ( VAR8 ) ; return ; } VAR20 = FUN12 ( VAR10 , VAR28 ) ; VAR10 -> VAR52 = FUN6 ( VAR10 -> VAR4 , VAR20 -> VAR52 . VAR53 * sizeof ( VAR54 ) ) ; if ( VAR10 -> VAR52 == NULL ) { FUN7 ( VAR10 -> VAR4 ) ; FUN3 ( VAR8 ) ; return ; } VAR8 -> VAR55 = 1 ; VAR8 -> VAR56 = 0 ; #if ( VAR57 ) if ( VAR8 - > VAR58 ) { VAR10 - > VAR59 = 1 ; } #endif VAR10->main = VAR10; VAR10->VAR60 = 1;  VAR6 = FUN13(); VAR10->VAR61 = VAR6->VAR62; VAR10->VAR63 = VAR6->VAR64;  VAR10->VAR65 = VAR66;  VAR10->VAR67.VAR68 = -1; VAR10->VAR67.VAR69 = -1; VAR10->VAR47.VAR68 = -1; VAR10->VAR47.VAR70 = -1;  VAR10->VAR71 = VAR72 + 1; VAR10->VAR73 = VAR74 + 1;  VAR10->VAR75 = VAR76;  VAR12 = VAR8->VAR24->VAR21; VAR12->VAR77 = VAR10; VAR12->VAR78 = VAR10; VAR10->VAR79 = VAR80;  #if (VAR81) (void) FUN14(VAR82, 1); VAR10->VAR83 = 1; (void) FUN14(VAR84, 1); #endif  VAR2->VAR85 = VAR86; FUN15(VAR2); } "#0
411#411#static void FUN1 ( VAR1 * VAR2 , const unsigned char * VAR3 , size_t VAR4 ) { size_t VAR5 , VAR6 ; if ( VAR3 == NULL || VAR4 == 0 ) return ; VAR6 = VAR4 < VAR2 -> VAR7 ? VAR4 : VAR2 -> VAR7 ; for ( VAR5 = 0 ; VAR5 < VAR6 ; VAR5 ++ ) VAR2 -> VAR8 [ VAR5 ] ^= VAR3 [ VAR5 ] ; if ( VAR4 <= VAR2 -> VAR7 ) return ; VAR6 = VAR4 - VAR2 -> VAR7 ; if ( VAR6 > 16 ) { VAR6 = 16 ; } for ( VAR5 = 0 ; VAR5 < VAR6 ; VAR5 ++ ) VAR2 -> VAR9 [ VAR5 ] ^= VAR3 [ VAR5 + VAR2 -> VAR7 ] ; } #0
412#412#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , const VAR7 * VAR8 , const VAR7 * VAR9 , int VAR10 , VAR11 * VAR12 , int VAR13 , int VAR14 , int VAR15 , int VAR16 , int VAR17 ) { int VAR18 , VAR19 , VAR20 , VAR21 ; VAR11 * VAR22 = VAR12 + VAR14 ; VAR12 += VAR13 ; for ( ; ; ) { VAR18 = FUN2 ( VAR4 , VAR6 -> VAR23 , VAR24 , VAR25 ) ; if ( VAR18 < 0 ) return -1 ; if ( VAR18 == 1 ) { break ; } else if ( VAR18 == 0 ) { if ( ! VAR10 ) { VAR20 = FUN3 ( VAR4 , VAR17 ) ; VAR19 = FUN3 ( VAR4 , VAR16 ) ; } else { VAR20 = FUN4 ( VAR4 ) ; if ( FUN5 ( VAR4 ) ) { if ( FUN5 ( VAR4 ) ) { if ( FUN5 ( VAR4 ) ) { FUN6 ( VAR2 , VAR26 , ) ; break ; } * VAR12 ++ = VAR20 ; if ( VAR12 >= VAR22 ) break ; } return 0 ; } #1
413#413#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 [ 0 ] ; VAR11 * VAR12 = VAR2 -> VAR12 ; unsigned int VAR13 ; int VAR14 ; if ( VAR6 -> VAR15 > VAR6 -> VAR16 ) return FUN2 ( VAR17 ) ; VAR13 = 15 * VAR9 -> VAR18 -> VAR19 ; VAR14 = FUN3 ( VAR12 , VAR4 , VAR13 ) ; if ( VAR14 < 0 ) return VAR14 ; VAR4 -> VAR20 = VAR9 -> VAR21 ; VAR6 -> VAR15 += VAR13 ; VAR4 -> VAR22 = VAR6 -> VAR23 ; VAR6 -> VAR23 += 28 * VAR9 -> VAR18 -> VAR19 ; return VAR14 ; } #0
414#414#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , VAR6 * VAR7 ) { VAR8 * VAR9 = VAR2 -> VAR9 ; AVRational VAR10 = VAR2 -> VAR11 [ 0 ] -> VAR12 -> VAR13 ; int VAR14 ; int64_t VAR15 = 0 ; if ( VAR10 . VAR16 > 0 && VAR10 . VAR17 > 0 ) { VAR15 = VAR10 . VAR16 * 64LL / VAR10 . VAR17 - 15 ; if ( VAR15 < 0 || VAR15 > 255 ) VAR15 = 0 ; } FUN2 ( VAR9 , , 3 ) ; FUN3 ( VAR9 , VAR3 ) ; FUN3 ( VAR9 , VAR4 ) ; if ( VAR7 ) { FUN4 ( VAR9 , 0xf7 ) ; FUN4 ( VAR9 , 0x1f ) ; FUN4 ( VAR9 , VAR15 ) ; for ( VAR14 = 0 ; VAR14 < 256 ; VAR14 ++ ) { const uint32_t VAR18 = VAR7 [ VAR14 ] & 0xffffff ; FUN5 ( VAR9 , VAR18 ) ; } } else { FUN4 ( VAR9 , 0 ) ; FUN4 ( VAR9 , 0 ) ; FUN4 ( VAR9 , VAR15 ) ; } if ( VAR5 >= 0 ) { FUN4 ( VAR9 , 0x21 ) ; FUN4 ( VAR9 , 0xff ) ; FUN4 ( VAR9 , 0x0b ) ; FUN2 ( VAR9 , ) - 1 ) ; FUN4 ( VAR9 , 0x03 ) ; FUN4 ( VAR9 , 0x01 ) ; FUN3 ( VAR9 , ( VAR19 ) VAR5 ) ; FUN4 ( VAR9 , 0x00 ) ; } return 0 ; } #0
415#415#static int FUN1 ( int VAR1 ) { static const char VAR2 [ ] = ; int VAR4 = 0 ; VAR5 * VAR6 = NULL , * VAR7 = NULL ; VAR8 * VAR9 = NULL , * VAR10 = NULL ; VAR11 * VAR12 = NULL ; const unsigned char * VAR13 = NULL ; unsigned char VAR14 [ 80 ] , VAR15 [ 80 ] ; unsigned char VAR16 [ 80 ] , VAR17 [ 80 ] ; unsigned char VAR18 [ 1 ] ; size_t VAR19 , VAR20 ; if ( ! FUN2 ( FUN3 ( & VAR6 , & VAR7 , & VAR9 , & VAR10 , & VAR12 , VAR1 ) ) ) goto VAR21 ; if ( ! FUN2 ( FUN4 ( VAR9 , NULL , 0 , & VAR20 ) ) || ! FUN5 ( FUN6 ( VAR10 , VAR18 , sizeof ( VAR18 ) , & VAR19 ) , VAR22 ) || ! FUN5 ( FUN7 ( VAR10 ) , VAR23 ) ) goto VAR21 ; if ( ! FUN5 ( FUN8 ( VAR9 , VAR14 , sizeof ( VAR14 ) , VAR2 , sizeof ( VAR2 ) - 1 , VAR3 , sizeof ( VAR3 ) - 1 ) , 1 ) || ! FUN5 ( FUN8 ( VAR9 , VAR15 , sizeof ( VAR15 ) , VAR2 , sizeof ( VAR2 ) - 1 , VAR13 , 0 ) , 1 ) || ! FUN5 ( FUN8 ( VAR10 , VAR16 , sizeof ( VAR16 ) , VAR2 , sizeof ( VAR2 ) - 1 , VAR3 , sizeof ( VAR3 ) - 1 ) , 1 ) || ! FUN5 ( FUN8 ( VAR10 , VAR17 , sizeof ( VAR17 ) , VAR2 , sizeof ( VAR2 ) - 1 , VAR13 , 0 ) , 1 ) || ! FUN9 ( VAR14 , sizeof ( VAR14 ) , VAR16 , sizeof ( VAR16 ) ) || ! FUN9 ( VAR15 , sizeof ( VAR15 ) , VAR17 , sizeof ( VAR17 ) ) || ! FUN10 ( VAR14 , sizeof ( VAR14 ) , VAR15 , sizeof ( VAR15 ) ) ) goto VAR21 ; VAR4 = 1 ; VAR21 : FUN11 ( VAR12 ) ; FUN11 ( VAR24 ) ; FUN11 ( VAR25 ) ; VAR24 = VAR25 = NULL ; FUN12 ( VAR10 ) ; FUN12 ( VAR9 ) ; FUN13 ( VAR7 ) ; FUN13 ( VAR6 ) ; return VAR4 ; } #0
416#416#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , VAR4 * VAR5 , int * VAR6 , double * * VAR7 , double * * VAR8 ) { char * VAR9 , * VAR10 , * VAR11 , * VAR12 = NULL , * VAR13 = NULL ; int VAR14 , VAR15 ; VAR9 = VAR11 = FUN2 ( VAR5 ) ; if ( ! VAR9 ) return FUN3 ( VAR16 ) ; for ( VAR14 = 0 ; VAR14 < VAR3 ; VAR14 ++ ) { if ( ! ( VAR10 = FUN4 ( VAR9 , "" "" , & VAR13 ) ) ) VAR10 = VAR12 ; if ( ! VAR10 ) return FUN3 ( VAR17 ) ; FUN5 ( VAR10 , & VAR6 [ VAR14 ] ) ; VAR9 = NULL ; VAR8 [ VAR14 ] = FUN6 ( VAR6 [ VAR14 ] + 1 , sizeof ( double ) ) ; VAR7 [ VAR14 ] = FUN6 ( VAR6 [ VAR14 ] , sizeof ( double ) ) ; if ( ! VAR7 [ VAR14 ] || ! VAR8 [ VAR14 ] ) return FUN3 ( VAR16 ) ; VAR15 = FUN7 ( VAR2 , VAR10 , VAR6 [ VAR14 ] , VAR7 [ VAR14 ] ) ; if ( VAR15 < 0 ) return VAR15 ; VAR12 = VAR10 ; } FUN8 ( & VAR11 ) ; return 0 ; } "#0
417#417#"static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 ) { #define FUN2 (VAR5 + VAR6) enum AVPixelFormat VAR7[VAR8 + 2], *VAR9 = VAR7; int VAR10;  FUN3(VAR2); VAR2->VAR11.VAR4 = NULL; VAR2->VAR11.VAR12 = NULL;  if (!VAR4) return 0;  VAR10 = FUN4(VAR2, VAR4); if (VAR10 < 0) goto VAR13;  FUN5(VAR2->VAR14, &VAR2->VAR11, VAR4);  if (VAR4->VAR15 == VAR16 || VAR4->VAR15 == VAR17) { #if VAR5 *VAR9++ = VAR18; #endif #if VAR6 *VAR9++ = VAR19; #endif }  *VAR9++ = VAR4->VAR15; *VAR9 = VAR20;  VAR10 = FUN6(VAR2->VAR14, VAR7); if (VAR10 < 0) goto VAR13; VAR2->VAR14->VAR15 = VAR10;  FUN7(&VAR2->VAR21,     VAR4->VAR22); FUN8 (&VAR2->VAR23, VAR4->VAR22); FUN9 (&VAR2->VAR24,    VAR4->VAR22);  if (VAR4->VAR25 && !VAR2->VAR14->VAR26) { FUN10(VAR2->VAR27); VAR10 = FUN11(VAR2->VAR14, VAR2->VAR27, VAR28); if (VAR10 < 0) goto VAR13; VAR2->VAR29 = VAR2->VAR27; }  VAR2->VAR11.VAR4 = VAR4; VAR2->VAR11.VAR12 = (VAR30*) VAR2->VAR11.VAR31[VAR2->VAR11.VAR4->VAR32]->VAR33;  return 0;  VAR13: FUN3(VAR2); VAR2->VAR11.VAR4 = NULL; return VAR10; } "#0
418#418#static int FUN1 ( VAR1 * VAR2 , char * VAR3 , char * * VAR4 , char * VAR5 ) { int VAR6 , VAR7 , VAR8 = 0 , VAR9 = 0 , VAR10 = 0 ; char * VAR11 , * VAR12 , * VAR13 , * VAR14 , * VAR15 , * VAR16 , * VAR17 , VAR18 ; VAR19 * VAR20 ; if ( ( VAR20 = FUN2 ( ) ) == NULL ) return ( 0 ) ; VAR10 = strlen ( VAR5 ) + 1 ; if ( ! FUN3 ( VAR20 , VAR10 ) ) goto VAR21 ; for ( ; ; ) { if ( FUN4 ( VAR2 , * VAR5 ) ) { VAR6 = * VAR5 ; VAR5 ++ ; while ( ! FUN5 ( VAR2 , * VAR5 ) && ( * VAR5 != VAR6 ) ) { if ( FUN6 ( VAR2 , * VAR5 ) ) { VAR5 ++ ; if ( FUN5 ( VAR2 , * VAR5 ) ) break ; } VAR20 -> VAR22 [ VAR9 ++ ] = * ( VAR5 ++ ) ; } if ( * VAR5 == VAR6 ) VAR5 ++ ; } else if ( FUN7 ( VAR2 , * VAR5 ) ) { VAR6 = * VAR5 ; VAR5 ++ ; while ( ! FUN5 ( VAR2 , * VAR5 ) ) { if ( * VAR5 == VAR6 ) { if ( * ( VAR5 + 1 ) == VAR6 ) { VAR5 ++ ; } else { break ; } } VAR20 -> VAR22 [ VAR9 ++ ] = * ( VAR5 ++ ) ; } if ( * VAR5 == VAR6 ) VAR5 ++ ; } else if ( FUN6 ( VAR2 , * VAR5 ) ) { VAR5 ++ ; VAR18 = * ( VAR5 ++ ) ; if ( FUN5 ( VAR2 , VAR18 ) ) break ; else if ( VAR18 == ' ' ) VAR18 = ' ' ; else if ( VAR18 == ' ' ) VAR18 = ' ' ; else if ( VAR18 == ' ' ) VAR18 = ' ' ; else if ( VAR18 == ' ' ) VAR18 = ' ' ; VAR20 -> VAR22 [ VAR9 ++ ] = VAR18 ; } else if ( FUN5 ( VAR2 , * VAR5 ) ) break ; else if ( * VAR5 == ' ' ) { VAR15 = NULL ; VAR11 = & ( VAR5 [ 1 ] ) ; if ( * VAR11 == ' ' ) VAR6 = ' ' ; else if ( * VAR11 == ' ' ) VAR6 = ' ' ; else VAR6 = 0 ; if ( VAR6 ) VAR11 ++ ; VAR17 = VAR3 ; VAR12 = VAR16 = VAR11 ; while ( FUN8 ( VAR2 , * VAR12 ) ) VAR12 ++ ; if ( ( VAR12 [ 0 ] == ' ' ) && ( VAR12 [ 1 ] == ' ' ) ) { VAR17 = VAR16 ; VAR15 = VAR12 ; VAR8 = * VAR12 ; * VAR15 = ' ' ; VAR12 += 2 ; VAR16 = VAR12 ; while ( FUN8 ( VAR2 , * VAR12 ) ) VAR12 ++ ; } VAR7 = * VAR12 ; * VAR12 = ' ' ; VAR13 = VAR12 ; if ( VAR6 ) { if ( VAR7 != VAR6 ) { FUN9 ( VAR23 , VAR24 ) ; goto VAR21 ; } VAR12 ++ ; } VAR14 = FUN10 ( VAR2 , VAR17 , VAR16 ) ; if ( VAR15 != NULL ) * VAR15 = VAR8 ; * VAR13 = VAR7 ; if ( VAR14 == NULL ) { FUN9 ( VAR23 , VAR25 ) ; goto VAR21 ; } FUN11 ( VAR20 , ( strlen ( VAR14 ) + VAR10 - ( VAR12 - VAR5 ) ) ) ; while ( * VAR14 ) VAR20 -> VAR22 [ VAR9 ++ ] = * ( VAR14 ++ ) ; VAR5 = VAR12 ; } else VAR20 -> VAR22 [ VAR9 ++ ] = * ( VAR5 ++ ) ; } VAR20 -> VAR22 [ VAR9 ] = ' ' ; if ( * VAR4 != NULL ) FUN12 ( * VAR4 ) ; * VAR4 = VAR20 -> VAR22 ; FUN12 ( VAR20 ) ; return ( 1 ) ; VAR21 : if ( VAR20 != NULL ) FUN13 ( VAR20 ) ; return ( 0 ) ; } #1
419#419#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; int VAR10 ; int VAR11 , VAR12 ; int VAR13 = 2 ; if ( ! VAR8 -> VAR3 [ 0 ] && VAR6 ) { int VAR14 = VAR6 -> VAR15 / VAR2 -> VAR16 - VAR13 ; if ( VAR6 -> VAR15 % VAR2 -> VAR16 ) { FUN2 ( VAR2 , VAR17 , ) ; return FUN3 ( VAR19 ) ; } VAR8 -> VAR20 [ 0 ] = VAR6 -> VAR3 [ 1 ] + 128 ; if ( VAR2 -> VAR16 == 2 ) VAR8 -> VAR20 [ 1 ] = VAR6 -> VAR3 [ 2 + VAR14 + 1 ] + 128 ; VAR8 -> VAR21 = 0 ; VAR8 -> VAR22 = VAR14 ; if ( ! ( VAR8 -> VAR3 [ 0 ] = FUN4 ( VAR14 ) ) ) return FUN3 ( VAR23 ) ; if ( VAR2 -> VAR16 == 2 ) { if ( ! ( VAR8 -> VAR3 [ 1 ] = FUN4 ( VAR14 ) ) ) { FUN5 ( & VAR8 -> VAR3 [ 0 ] ) ; return FUN3 ( VAR23 ) ; } } memcpy ( VAR8 -> VAR3 [ 0 ] , & VAR6 -> VAR3 [ VAR13 ] , VAR14 ) ; if ( VAR2 -> VAR16 == 2 ) memcpy ( VAR8 -> VAR3 [ 1 ] , & VAR6 -> VAR3 [ 2 * VAR13 + VAR14 ] , VAR14 ) ; } if ( ! VAR8 -> VAR3 [ 0 ] ) { FUN2 ( VAR2 , VAR18 , ) ; return VAR12 ; } for ( VAR11 = 0 ; VAR11 < VAR2 -> VAR16 ; VAR11 ++ ) { FUN8 ( VAR8 -> VAR25 . VAR3 [ VAR11 ] , & VAR8 -> VAR3 [ VAR11 ] [ VAR8 -> VAR21 ] , VAR10 , & VAR8 -> VAR20 [ VAR11 ] , VAR8 -> VAR27 ) ; } VAR8 -> VAR21 += VAR10 ; * VAR4 = 1 ; * ( VAR28 * ) VAR3 = VAR8 -> VAR25 ; return ( ( VAR2 -> VAR29 == 0 ) * VAR13 + VAR10 ) * VAR2 -> VAR16 ; } #0
420#420#"void FUN1 ( VAR1 * VAR2 ) { int VAR3 ; if ( VAR4 && VAR2 -> VAR5 -> VAR6 ) { FUN2 ( VAR2 ) ; } else if ( ( VAR2 -> VAR7 || VAR2 -> VAR8 ) && ! VAR2 -> VAR5 -> VAR9 && ! ( VAR2 -> VAR5 -> VAR10 -> VAR11 & VAR12 ) && VAR2 -> VAR13 && VAR2 -> VAR14 . VAR15 . VAR16 && ! VAR2 -> VAR17 && ! ( VAR2 -> VAR18 & VAR19 ) ) { int VAR20 = VAR21 [ VAR2 -> VAR5 -> VAR22 ] . VAR23 ; int VAR24 = VAR21 [ VAR2 -> VAR5 -> VAR22 ] . VAR25 ; VAR2 -> VAR26 . FUN3 ( VAR2 -> VAR14 . VAR15 . VAR27 [ 0 ] , VAR2 -> VAR28 , VAR2 -> VAR29 , VAR2 -> VAR30 , VAR31 , VAR31 , VAR32 | VAR33 ) ; VAR2 -> VAR26 . FUN3 ( VAR2 -> VAR14 . VAR15 . VAR27 [ 1 ] , VAR2 -> VAR34 , VAR2 -> VAR29 >> VAR20 , VAR2 -> VAR30 >> VAR24 , VAR31 >> VAR20 , VAR31 >> VAR24 , VAR32 | VAR33 ) ; VAR2 -> VAR26 . FUN3 ( VAR2 -> VAR14 . VAR15 . VAR27 [ 2 ] , VAR2 -> VAR34 , VAR2 -> VAR29 >> VAR20 , VAR2 -> VAR30 >> VAR24 , VAR31 >> VAR20 , VAR31 >> VAR24 , VAR32 | VAR33 ) ; } FUN4 ( ) ; VAR2 -> VAR35 = VAR2 -> VAR36 ; VAR2 -> VAR37 [ VAR2 -> VAR36 ] = VAR2 -> VAR38 -> VAR15 . VAR39 ; if ( VAR2 -> VAR36 != VAR40 ) { VAR2 -> VAR41 = VAR2 -> VAR36 ; } #if 0 for ( VAR3 = 0 ; VAR3 < VAR42 ; VAR3 + + ) { if ( VAR2 - > VAR43 [ VAR3 ] . VAR15 . VAR27 [ 0 ] == VAR2 - > VAR14 . VAR15 . VAR27 [ 0 ] ) { VAR2 -> VAR43 [ VAR3 ] = VAR2 -> VAR14 ; break ; } } assert ( VAR3 < VAR42 ) ; #endif if (VAR2->VAR8) {  for (VAR3 = 0; VAR3 < VAR2->VAR44; VAR3++) { if (VAR2->VAR43[VAR3].VAR15.VAR27[0] && !VAR2->VAR43[VAR3].VAR15.VAR16 ) { FUN5(VAR2, &VAR2->VAR43[VAR3]); } } }  #if 0 memset(&VAR2->VAR45,    0, sizeof(VAR46)); memset(&VAR2->VAR47,    0, sizeof(VAR46)); memset(&VAR2->VAR14, 0, sizeof(VAR46)); #endif VAR2->VAR5->VAR48 = &VAR2->VAR38->VAR15;  if (VAR2->VAR49 != VAR50 && VAR2->VAR14.VAR15.VAR16) { FUN6(&VAR2->VAR38->VAR15, VAR51, 0); } } "#1
421#421#VAR1 * FUN1 ( void ) { VAR1 * VAR2 ; VAR2 = ( VAR1 * ) FUN2 ( sizeof ( VAR1 ) ) ; if ( VAR2 ) memset ( VAR2 , 0 , sizeof ( VAR1 ) ) ; return VAR2 ; } #1
422#422#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; struct VAR9 * VAR10 = NULL ; int VAR11 , VAR12 ; int64_t VAR13 ; if ( ( VAR5 & VAR14 ) || ! VAR7 -> VAR15 [ 0 ] -> VAR16 [ 0 ] -> VAR17 ) return FUN2 ( VAR18 ) ; VAR13 = FUN3 ( VAR4 , VAR19 , VAR2 -> VAR20 [ VAR3 ] -> VAR21 . VAR22 , VAR5 & VAR23 ? VAR24 : VAR25 ) ; if ( VAR2 -> VAR26 < VAR13 ) return FUN2 ( VAR27 ) ; for ( VAR11 = 0 ; VAR11 < VAR7 -> VAR28 ; VAR11 ++ ) { struct VAR9 * VAR29 = VAR7 -> VAR16 [ VAR11 ] ; if ( VAR3 >= VAR29 -> VAR30 && VAR3 - VAR29 -> VAR30 < VAR29 -> VAR31 -> VAR32 ) { VAR10 = VAR29 ; break ; } } if ( ! VAR10 || ! FUN4 ( VAR7 , VAR10 , VAR13 , & VAR12 ) ) return FUN2 ( VAR27 ) ; VAR10 -> VAR33 = VAR12 ; VAR10 -> VAR34 = VAR3 - VAR10 -> VAR30 ; for ( VAR11 = 0 ; VAR11 < VAR7 -> VAR28 ; VAR11 ++ ) { struct VAR9 * VAR29 = VAR7 -> VAR16 [ VAR11 ] ; if ( VAR29 -> VAR35 ) { FUN5 ( VAR29 -> VAR35 ) ; VAR29 -> VAR35 = NULL ; } FUN6 ( & VAR29 -> VAR36 ) ; FUN7 ( & VAR29 -> VAR36 ) ; VAR29 -> VAR37 . VAR38 = 0 ; VAR29 -> VAR37 . VAR39 = VAR29 -> VAR37 . VAR40 = VAR29 -> VAR37 . VAR41 ; VAR29 -> VAR37 . VAR42 = 0 ; VAR29 -> VAR13 = VAR13 ; VAR29 -> VAR43 = VAR5 ; if ( VAR29 != VAR10 ) { FUN4 ( VAR7 , VAR29 , VAR13 , & VAR29 -> VAR33 ) ; VAR29 -> VAR34 = -1 ; VAR29 -> VAR43 |= VAR44 ; } } VAR7 -> VAR45 = VAR13 ; return 0 ; } #0
423#423#static int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , int VAR4 ) { VAR2 -> VAR5 = NULL ; VAR2 -> VAR6 = NULL ; VAR2 -> VAR7 = 0 ; if ( VAR2 -> VAR8 ) { VAR9 * VAR10 = FUN2 ( VAR3 -> VAR8 ) ; if ( ! VAR10 ) return FUN3 ( VAR11 ) ; VAR2 -> VAR8 = VAR10 ; VAR2 -> VAR5 = VAR10 -> VAR5 ; } else { FUN4 ( VAR2 -> VAR5 , VAR3 -> VAR5 , VAR2 -> VAR12 , 1 , VAR13 ) ; } if ( VAR3 -> VAR7 && VAR4 ) { VAR2 -> VAR6 = VAR3 -> VAR6 ; VAR2 -> VAR7 = VAR3 -> VAR7 ; } if ( VAR3 -> VAR7 && ! VAR4 ) { return FUN5 ( VAR2 , VAR3 ) ; } return 0 ; VAR14 : FUN6 ( VAR2 ) ; return FUN3 ( VAR11 ) ; } #0
424#424#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const char * VAR5 , VAR6 * * VAR7 , int * VAR8 , const VAR6 * VAR9 , int VAR10 , int VAR11 ) { unsigned int * VAR12 = VAR2 -> VAR13 ; int VAR14 = VAR5 ? FUN2 ( VAR5 ) : ( * VAR12 % 10001 + 1 ) ; int VAR15 ; * VAR7 = FUN3 ( VAR10 + VAR16 ) ; memcpy ( * VAR7 , VAR9 , VAR10 + VAR16 ) ; for ( VAR15 = 0 ; VAR15 < VAR10 ; VAR15 ++ ) { ( * VAR12 ) += ( * VAR7 ) [ VAR15 ] + 1 ; if ( * VAR12 % VAR14 == 0 ) ( * VAR7 ) [ VAR15 ] = * VAR12 ; } return 1 ; } #1
425#425#static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , VAR3 * * VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 [ 0 ] -> VAR7 ; VAR9 * VAR10 = VAR2 -> VAR11 [ 0 ] -> VAR10 ; VAR3 * VAR12 ; VAR13 * VAR14 = VAR10 -> VAR15 -> VAR14 ; char * VAR16 ; AVRational VAR17 ; char VAR18 [ 255 ] ; int VAR19 ; if ( VAR7 -> VAR15 -> VAR17 . VAR20 ) { VAR17 = VAR7 -> VAR15 -> VAR17 ; } else VAR17 = VAR7 -> VAR15 -> VAR14 -> VAR17 ; snprintf ( VAR18 , 255 , ) , ) , , VAR14 -> VAR21 , VAR14 -> VAR22 , ( unsigned ) VAR10 -> VAR27 ) ; if ( ( VAR19 = FUN2 ( & VAR12 , FUN3 ( ) , , ( unsigned ) VAR10 -> VAR27 ) ; VAR2 -> VAR26 -> VAR28 = FUN7 ( VAR18 ) ; return 0 ; } #0
426#426#static void FUN1 ( VAR1 * VAR2 , double * VAR3 , int * VAR4 , int VAR5 , int VAR6 ) { int VAR7 , VAR8 , VAR9 = * VAR4 ; int * VAR10 = VAR2 -> VAR11 [ VAR5 ] [ VAR6 ] ; float * VAR12 = VAR2 -> VAR13 [ VAR5 ] [ VAR6 ] ; float VAR14 [ VAR15 ] = { 0.0f } , VAR16 [ VAR15 ] = { 0.0f } ; if ( ! VAR9 ) return ; for ( VAR7 = 0 ; VAR7 < VAR9 ; VAR7 ++ ) { VAR10 [ VAR7 ] = FUN2 ( VAR3 [ VAR7 ] , VAR17 , 16 ) ; VAR12 [ VAR7 ] = VAR17 [ VAR10 [ VAR7 ] ] ; } for ( VAR7 = VAR9 - 1 ; VAR7 > -1 ; VAR7 -- ) { VAR12 [ VAR7 ] = ( FUN3 ( VAR12 [ VAR7 ] ) > 0.1f ) ? VAR12 [ VAR7 ] : 0.0f ; if ( VAR12 [ VAR7 ] != 0.0 ) { VAR9 = VAR7 ; break ; } } VAR16 [ 0 ] = 1.0f ; for ( VAR7 = 1 ; VAR7 <= VAR9 ; VAR7 ++ ) { for ( VAR8 = 1 ; VAR8 < VAR7 ; VAR8 ++ ) { VAR14 [ VAR8 ] = VAR16 [ VAR8 ] + VAR12 [ VAR7 ] * VAR16 [ VAR7 - VAR8 ] ; } for ( VAR8 = 1 ; VAR8 <= VAR7 ; VAR8 ++ ) { VAR16 [ VAR8 ] = VAR14 [ VAR8 ] ; } VAR16 [ VAR7 ] = VAR12 [ VAR7 - 1 ] ; } * VAR4 = VAR9 ; memcpy ( VAR12 , VAR16 , VAR15 * sizeof ( float ) ) ; } #1
427#427#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int final , int64_t VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 ; int VAR9 , VAR10 = 0 ; char VAR11 [ 1024 ] ; int VAR12 = VAR2 -> VAR13 [ VAR4 -> VAR14 ] -> VAR15 ; if ( ! VAR4 -> VAR16 ) return 0 ; FUN2 ( VAR4 -> VAR17 -> VAR18 ) ; VAR4 -> VAR16 = 0 ; FUN3 ( VAR2 , VAR4 ) ; snprintf ( VAR11 , sizeof ( VAR11 ) , "" "" , VAR2 -> VAR19 , VAR12 , VAR4 -> VAR20 ) ; VAR10 = FUN4 ( VAR4 -> VAR21 , VAR11 ) ; if ( VAR10 < 0 ) return VAR10 ; FUN5 ( VAR4 , VAR11 , VAR4 -> VAR22 , VAR5 - VAR4 -> VAR22 ) ; if ( ! final ) { VAR10 = FUN6 ( VAR2 , VAR4 , VAR5 ) ; if ( VAR10 < 0 ) return VAR10 ; } if ( VAR7 -> VAR23 || ( final && VAR7 -> VAR24 ) ) { int remove = VAR4 -> VAR25 - VAR7 -> VAR23 - VAR7 -> VAR26 ; if ( final && VAR7 -> VAR24 ) remove = VAR4 -> VAR25 ; if ( remove > 0 ) { for ( VAR9 = 0 ; VAR9 < remove ; VAR9 ++ ) { unlink ( VAR4 -> VAR27 [ VAR9 ] -> VAR28 ) ; FUN7 ( VAR4 -> VAR27 [ VAR9 ] ) ; } VAR4 -> VAR25 -= remove ; memmove ( VAR4 -> VAR27 , VAR4 -> VAR27 + remove , VAR4 -> VAR25 * sizeof ( * VAR4 -> VAR27 ) ) ; } } if ( VAR10 >= 0 ) VAR10 = FUN8 ( VAR2 , VAR4 , final ) ; return VAR10 ; } "#0
428#428#"static void FUN1 ( VAR1 * * VAR2 , int VAR3 , const VAR1 * VAR4 , enum TiffTypes VAR5 , int VAR6 ) { int VAR7 ; #if HAVE_BIGENDIAN VAR6 ^= ( ( int [ ] ) { 0 , 0 , 0 , 1 , 3 , 3 } ) [ VAR5 ] ; #endif for (VAR7 = 0; VAR7 < VAR3 * VAR8[VAR5]; VAR7++) *(*VAR2)++ = VAR4[VAR7 ^ VAR6]; } "#1
429#429#VAR1 * FUN1 ( VAR1 * VAR2 ) { VAR1 * VAR3 ; int VAR4 ; if ( ! FUN2 ( VAR2 ) || ! FUN3 ( VAR2 ) ) { FUN4 ( & VAR2 -> VAR5 , & VAR4 , VAR2 -> VAR6 ) ; return VAR2 ; } if ( ( VAR3 = FUN5 ( FUN6 ( VAR2 ) ) ) == NULL ) return NULL ; if ( VAR2 -> VAR7 != NULL ) { if ( ! FUN7 ( VAR3 , VAR2 ) ) goto VAR8 ; } else { if ( ! FUN8 ( VAR3 , VAR2 -> VAR9 ) ) goto VAR8 ; if ( VAR2 -> VAR10 != NULL ) { FUN9 ( VAR3 -> VAR10 ) ; VAR3 -> VAR10 = FUN10 ( VAR2 -> VAR10 ) ; if ( VAR3 -> VAR10 == NULL ) goto VAR8 ; } if ( ! FUN11 ( VAR3 , VAR2 -> VAR11 , ( int ) VAR2 -> VAR12 ) ) goto VAR8 ; } if ( ! FUN12 ( VAR3 , VAR2 ) ) goto VAR8 ; VAR3 -> VAR13 = VAR2 -> VAR13 ; VAR3 -> VAR14 = VAR2 -> VAR14 ; VAR3 -> VAR15 = VAR2 -> VAR15 ; FUN13 ( VAR3 , FUN14 ( VAR2 ) ) ; FUN15 ( VAR3 , FUN16 ( VAR2 ) ) ; VAR3 -> VAR16 = VAR2 -> VAR16 ; VAR3 -> VAR17 = VAR2 -> VAR17 ; FUN17 ( VAR3 , FUN18 ( VAR2 ) , FUN19 ( VAR2 ) ) ; FUN20 ( VAR3 , FUN21 ( VAR2 ) ) ; VAR3 -> VAR18 = VAR2 -> VAR18 ; FUN22 ( VAR3 , FUN23 ( VAR2 ) ) ; if ( ! FUN24 ( VAR19 , & VAR3 -> VAR20 , & VAR2 -> VAR20 ) ) goto VAR8 ; if ( VAR2 -> VAR21 != NULL ) { if ( ! FUN25 ( VAR2 -> VAR21 , ( char * ) & VAR3 -> VAR21 ) ) goto VAR8 ; } if ( VAR2 -> VAR22 != NULL ) { if ( VAR2 -> VAR22 != VAR2 -> VAR21 ) { if ( ! FUN25 ( VAR2 -> VAR22 , ( char * ) & VAR3 -> VAR22 ) ) goto VAR8 ; } else { FUN26 ( VAR3 -> VAR21 ) ; VAR3 -> VAR22 = VAR3 -> VAR21 ; } } VAR3 -> VAR23 = VAR2 -> VAR23 ; if ( VAR2 -> VAR24 ) { if ( VAR2 -> VAR23 ) FUN27 ( VAR3 ) ; else FUN28 ( VAR3 ) ; } VAR3 -> VAR25 = VAR2 -> VAR25 ; VAR3 -> VAR26 = VAR2 -> VAR26 ; VAR3 -> VAR27 = VAR2 -> VAR27 ; VAR3 -> VAR28 = VAR2 -> VAR28 ; FUN29 ( VAR3 -> VAR29 , VAR2 -> VAR29 ) ; if ( VAR2 -> VAR30 != NULL ) { if ( ( VAR3 -> VAR30 = FUN30 ( VAR2 -> VAR30 ) ) == NULL ) goto VAR8 ; } if ( VAR2 -> VAR31 != NULL ) if ( ( VAR3 -> VAR31 = FUN30 ( VAR2 -> VAR31 ) ) == NULL ) goto VAR8 ; if ( ! FUN31 ( & VAR3 -> VAR32 , VAR2 -> VAR32 ) || ! FUN31 ( & VAR3 -> VAR33 , VAR2 -> VAR33 ) ) goto VAR8 ; return VAR3 ; VAR8 : FUN32 ( VAR3 ) ; return NULL ; } #0
430#430#"static inline int FUN1 ( VAR1 * VAR2 , int VAR3 ) { unsigned VAR4 = FUN2 ( VAR2 ) ; if ( VAR4 >= ( ( 1U << 31 ) >> VAR3 ) ) { FUN3 ( NULL , VAR5 , "" "" ) ; return VAR6 ; } if ( VAR3 ) { return ( VAR4 << VAR3 ) + FUN4 ( VAR2 , VAR3 ) ; } return VAR4 ; } "#0
431#431#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = FUN2 ( VAR2 , VAR5 ) ; if ( VAR8 == VAR2 -> VAR8 ) return VAR9 ; if ( ! VAR8 ) { VAR8 = FUN3 ( VAR2 , VAR5 ) ; if ( ! VAR8 ) return FUN4 ( VAR10 ) ; } VAR4 -> VAR4 [ VAR4 -> VAR11 ] = VAR8 -> VAR5 ; VAR4 -> VAR8 [ VAR4 -> VAR11 ] = VAR8 ; VAR4 -> VAR11 ++ ; FUN5 ( VAR8 , VAR6 ) ; return 0 ; } #1
432#432#"VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 , off_t VAR6 , VAR7 * VAR8 ) { VAR9 * VAR10 ; size_t VAR11 ; ssize_t VAR12 , VAR13 ; ngx_array_t VAR14 ; struct VAR15 * VAR16 , VAR17 [ VAR18 ] ; if ( VAR5 -> VAR19 == NULL ) { return FUN2 ( VAR3 , VAR5 -> VAR20 -> VAR21 , ( VAR22 ) ( VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ) , VAR6 ) ; } VAR12 = 0 ; VAR14 . VAR24 = VAR17 ; VAR14 . VAR11 = sizeof ( struct VAR15 ) ; VAR14 . VAR25 = VAR18 ; VAR14 . VAR8 = VAR8 ; do { VAR10 = NULL ; VAR16 = NULL ; VAR11 = 0 ; VAR14 . VAR26 = 0 ; while ( VAR5 && VAR14 . VAR26 < VAR27 ) { if ( VAR10 == VAR5 -> VAR20 -> VAR21 ) { VAR16 -> VAR28 += VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; } else { VAR16 = FUN3 ( & VAR14 ) ; if ( VAR16 == NULL ) { return VAR29 ; } VAR16 -> VAR30 = ( void * ) VAR5 -> VAR20 -> VAR21 ; VAR16 -> VAR28 = VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; } VAR11 += VAR5 -> VAR20 -> VAR23 - VAR5 -> VAR20 -> VAR21 ; VAR10 = VAR5 -> VAR20 -> VAR23 ; VAR5 = VAR5 -> VAR19 ; } if ( VAR14 . VAR26 == 1 ) { VAR16 = VAR14 . VAR24 ; VAR13 = FUN2 ( VAR3 , ( VAR9 * ) VAR16 [ 0 ] . VAR30 , VAR16 [ 0 ] . VAR28 , VAR6 ) ; if ( VAR13 == VAR29 ) { return VAR13 ; } return VAR12 + VAR13 ; } if ( VAR3 -> VAR31 != VAR6 ) { if ( FUN4 ( VAR3 -> VAR32 , VAR6 , VAR33 ) == -1 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , VAR36 , , VAR3 -> VAR38 . VAR39 ) ; return VAR29 ; } VAR3 -> VAR31 = VAR6 ; } VAR13 = FUN6 ( VAR3 -> VAR32 , VAR14 . VAR24 , VAR14 . VAR26 ) ; if ( VAR13 == -1 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , VAR36 , , VAR3 -> VAR38 . VAR39 ) ; return VAR29 ; } if ( ( VAR22 ) VAR13 != VAR11 ) { FUN5 ( VAR34 , VAR3 -> VAR35 , 0 , , VAR3 -> VAR38 . VAR39 , VAR13 , VAR11 ) ; return VAR29 ; } FUN7 ( VAR40 , VAR3 -> VAR35 , 0 , "" "" , VAR3 -> VAR32 , VAR13 ) ; VAR3 -> VAR31 += VAR13 ; VAR3 -> VAR6 += VAR13 ; VAR12 += VAR13 ; } while ( VAR5 ) ; return VAR12 ; } "#1
433#433#"void * FUN1 ( void * VAR1 , size_t VAR2 ) { if ( VAR2 > ( VAR3 - 32 ) ) return NULL ; #if HAVE_ALIGNED_MALLOC return FUN2 ( VAR1 , VAR2 + ! VAR2 , VAR4 ) ; #else return realloc(VAR1, VAR2 + !VAR2); #endif } "#1
434#434#"VAR1 FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , int VAR4 , BN_ULONG VAR5 ) { BN_ULONG VAR6 = 0 ; BN_ULONG VAR7 , VAR8 ; assert ( VAR4 >= 0 ) ; if ( VAR4 <= 0 ) return ( ( VAR1 ) 0 ) ; VAR7 = FUN2 ( VAR5 ) ; VAR8 = FUN3 ( VAR5 ) ; #ifndef OPENSSL_SMALL_FOOTPRINT while ( VAR4 & ~ 3 ) { FUN4 ( VAR2 [ 0 ] , VAR3 [ 0 ] , VAR7 , VAR8 , VAR6 ) ; FUN4 ( VAR2 [ 1 ] , VAR3 [ 1 ] , VAR7 , VAR8 , VAR6 ) ; FUN4 ( VAR2 [ 2 ] , VAR3 [ 2 ] , VAR7 , VAR8 , VAR6 ) ; FUN4 ( VAR2 [ 3 ] , VAR3 [ 3 ] , VAR7 , VAR8 , VAR6 ) ; VAR3 += 4 ; VAR2 += 4 ; VAR4 -= 4 ; } #endif while ( VAR4 ) { FUN4 ( VAR2 [ 0 ] , VAR3 [ 0 ] , VAR7 , VAR8 , VAR6 ) ; VAR3 ++ ; VAR2 ++ ; VAR4 -- ; } return ( VAR6 ) ; } "#1
435#435#static int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , const VAR4 * VAR5 , int VAR6 , int VAR7 ) { int VAR8 = VAR2 -> VAR9 -> VAR10 * VAR6 * VAR2 -> VAR11 ; if ( VAR6 ) { memset ( VAR3 , VAR2 -> VAR11 == 2 ? 0x00 : 0x80 , VAR8 ) ; VAR3 += VAR8 ; } if ( VAR2 -> VAR9 -> VAR12 == 16 ) FUN2 ( VAR2 , VAR3 , VAR5 , VAR7 , VAR2 -> VAR9 -> VAR13 == 2 ) ; else { memcpy ( VAR3 , VAR5 , VAR7 ) ; } return VAR8 + VAR7 * VAR2 -> VAR11 ; } #1
436#436#"static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , VAR3 * * VAR5 ) { VAR6 * VAR7 = VAR2 -> VAR8 [ 0 ] -> VAR7 ; VAR9 * VAR10 = VAR2 -> VAR11 [ 0 ] -> VAR10 ; VAR12 * VAR13 = VAR10 -> VAR14 -> VAR13 ; VAR12 * VAR15 = VAR7 -> VAR14 -> VAR13 ; char * VAR16 , * VAR17 , * VAR18 ; char VAR19 [ 256 ] ; int VAR20 ; FUN2 ( & VAR2 -> VAR21 ) ; if ( ! ( VAR2 -> VAR21 = FUN3 ( ) ) ) return FUN4 ( VAR22 ) ; snprintf ( VAR19 , sizeof ( VAR19 ) , VAR23 , VAR7 -> VAR14 -> VAR24 . VAR25 , VAR7 -> VAR14 -> VAR24 . VAR26 , VAR15 -> VAR27 , FUN5 ( VAR15 -> VAR28 ) , VAR15 -> VAR29 ) ; VAR20 = FUN6 ( & VAR2 -> VAR8 [ 0 ] -> VAR30 , FUN7 ( , VAR19 , NULL , VAR2 -> VAR21 ) ; if ( VAR20 < 0 ) return VAR20 ; VAR20 = FUN6 ( & VAR2 -> VAR11 [ 0 ] -> VAR30 , FUN7 ( , NULL , NULL , VAR2 -> VAR21 ) ; if ( VAR20 < 0 ) return VAR20 ; * VAR4 = VAR2 -> VAR8 [ 0 ] -> VAR30 ; * VAR5 = VAR2 -> VAR11 [ 0 ] -> VAR30 ; if ( VAR13 -> VAR31 && ! VAR13 -> VAR29 ) VAR13 -> VAR29 = FUN8 ( VAR13 -> VAR31 ) ; VAR16 = FUN9 ( VAR10 ) ; VAR17 = FUN10 ( VAR10 ) ; VAR18 = FUN11 ( VAR10 ) ; if ( VAR16 || VAR17 || VAR18 ) { VAR3 * VAR32 ; char VAR19 [ 256 ] ; int VAR33 = 0 ; if ( VAR16 ) VAR33 += snprintf ( VAR19 + VAR33 , sizeof ( VAR19 ) - VAR33 , , VAR17 ) ; if ( VAR18 ) VAR33 += snprintf ( VAR19 + VAR33 , sizeof ( VAR19 ) - VAR33 , ) , "" "" , VAR19 , NULL , VAR2 -> VAR21 ) ; if ( VAR20 < 0 ) return VAR20 ; VAR20 = FUN13 ( VAR32 , 0 , VAR2 -> VAR11 [ 0 ] -> VAR30 , 0 ) ; if ( VAR20 < 0 ) return VAR20 ; * VAR5 = VAR32 ; } return 0 ; } "#0
437#437#static int FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , const VAR1 * VAR4 , const VAR1 * VAR5 , VAR6 * VAR7 ) { int VAR8 = 0 ; int VAR9 ; if ( VAR10 == NULL ) { FUN2 ( VAR11 , VAR12 ) ; return 0 ; } VAR8 = FUN3 ( VAR5 ) ; if ( VAR8 > VAR13 ) { FUN2 ( VAR11 , VAR14 ) ; return FUN4 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR7 ) ; } if ( ! FUN5 ( VAR2 , VAR5 -> VAR15 ) ) { FUN2 ( VAR11 , VAR16 ) ; return 0 ; } if ( ( VAR9 = FUN6 ( VAR17 ) ) <= 0 ) { VAR9 = 0 ; FUN2 ( VAR18 , VAR19 ) ; return FUN4 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR7 ) ; } if ( FUN7 ( VAR9 , ( unsigned char * ) VAR3 -> VAR20 , FUN3 ( VAR3 ) , ( unsigned char * ) VAR5 -> VAR20 , FUN3 ( VAR5 ) , ( unsigned char * ) VAR4 -> VAR20 , FUN3 ( VAR4 ) , ( unsigned char * ) VAR2 -> VAR20 , & VAR8 ) != 0 ) { FUN2 ( VAR11 , VAR21 ) ; FUN8 ( VAR9 ) ; return FUN4 ( VAR2 , VAR3 , VAR4 , VAR5 , VAR7 ) ; } FUN8 ( VAR9 ) ; VAR2 -> VAR15 = ( FUN3 ( VAR5 ) + VAR22 - 1 ) / VAR22 ; return 1 ; } #0
438#438#"static void FUN1 ( VAR1 * VAR2 ) { char * VAR3 , * VAR4 ; char * VAR5 ; apr_port_t VAR6 ; apr_status_t VAR7 ; const char * VAR8 ; if ( ! * VAR2 -> VAR9 ) { return ; } for ( VAR8 = VAR2 -> VAR9 ; FUN2 ( * VAR8 ) ; ++ VAR8 ) ; if ( ! * VAR8 ) { return ; } VAR7 = FUN3 ( & VAR3 , & VAR4 , & VAR6 , VAR2 -> VAR9 , VAR2 -> VAR10 ) ; if ( VAR7 != VAR11 || VAR4 ) { goto VAR12 ; } if ( VAR6 ) { VAR2 -> VAR13 . VAR6 = VAR6 ; VAR2 -> VAR13 . VAR14 = FUN4 ( VAR2 -> VAR10 , ( int ) VAR6 ) ; } if ( VAR2 -> VAR9 [ 0 ] != ' ' ) { for ( VAR5 = VAR3 ; * VAR5 ; VAR5 ++ ) { if ( FUN5 ( * VAR5 ) ) { } else if ( * VAR5 == ' ' ) { if ( * ( VAR5 + 1 ) == ' ' ) { goto VAR12 ; } } else if ( FUN6 ( * VAR5 ) ) { * VAR5 = FUN7 ( * VAR5 ) ; } else if ( * VAR5 == ' ' || * VAR5 == ' ' ) { goto VAR12 ; } } if ( VAR5 > VAR3 && VAR5 [ -1 ] == ' ' ) { VAR5 [ -1 ] = ' ' ; } } VAR2 -> VAR9 = VAR3 ; return ; VAR12 : VAR2 -> VAR15 = VAR16 ; FUN8 ( VAR17 , VAR18 , 0 , VAR2 , FUN9 ( 00550 ) "" "" , VAR2 -> VAR9 ) ; return ; } "#1
439#439#VAR1 * FUN1 ( const VAR2 * VAR3 ) { VAR1 * VAR4 = FUN2 ( sizeof ( * VAR4 ) ) ; if ( VAR4 == NULL ) { FUN3 ( VAR5 , VAR6 ) ; return NULL ; } VAR4 -> VAR7 = FUN4 ( ) ; if ( VAR4 -> VAR7 == NULL ) { FUN3 ( VAR5 , VAR6 ) ; FUN5 ( VAR4 ) ; return NULL ; } if ( VAR3 == NULL ) VAR3 = FUN6 ( ) ; if ( VAR3 == NULL ) VAR3 = FUN7 ( ) ; VAR4 -> VAR8 = VAR3 ; if ( ! FUN8 ( VAR9 , VAR4 , & VAR4 -> VAR10 ) ) { FUN5 ( VAR4 ) ; return NULL ; } return VAR4 ; } #0
440#440#void FUN1 ( void * VAR1 , int VAR2 , const char * VAR3 , ... ) { VAR4 * VAR5 = VAR1 ? * ( VAR4 * * ) VAR1 : NULL ; va_list VAR6 ; FUN2 ( VAR6 , VAR3 ) ; if ( VAR5 && VAR5 -> VAR7 >= ( 50 << 16 | 15 << 8 | 2 ) && VAR5 -> VAR8 && VAR2 >= VAR9 ) VAR2 += * ( int * ) ( ( ( VAR10 * ) VAR1 ) + VAR5 -> VAR8 ) ; FUN3 ( VAR1 , VAR2 , VAR3 , VAR6 ) ; FUN4 ( VAR6 ) ; } #1
441#441#VAR1 * FUN1 ( const unsigned char * VAR2 , size_t VAR3 ) { while ( * VAR2 == 0 && VAR3 > 0 ) { VAR2 ++ ; VAR3 -- ; } if ( VAR3 ) { return FUN2 ( VAR2 , VAR3 , NULL ) ; } else { VAR1 * VAR4 = FUN3 ( ) ; FUN4 ( VAR4 ) ; return VAR4 ; } } #1
442#442#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR4 ; int VAR5 = 0 , VAR6 = VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR12 ; VAR13 * VAR14 = VAR2 -> VAR14 ; VAR13 * VAR15 = VAR2 -> VAR15 ; VAR16 * VAR17 ; apr_off_t VAR18 ; apr_off_t VAR19 = 0 ; do { if ( FUN2 ( VAR15 ) && FUN2 ( VAR14 ) ) { VAR6 = FUN3 ( VAR2 , VAR15 , 1 ) ; if ( VAR6 != VAR7 ) { return VAR6 ; } } if ( ! FUN2 ( VAR15 ) ) { FUN4 ( VAR15 , 1 , & VAR18 ) ; VAR19 += VAR18 ; if ( FUN5 ( FUN6 ( VAR15 ) ) ) { VAR5 = 1 ; VAR17 = FUN6 ( VAR15 ) ; FUN7 ( VAR17 ) ; if ( FUN8 ( VAR4 -> VAR20 , , VAR19 , VAR2 -> VAR22 ) ; return VAR26 ; } } FUN13 ( VAR15 , VAR14 ) ; VAR6 = FUN14 ( VAR12 , VAR4 , VAR9 , VAR2 -> VAR27 , VAR15 , VAR5 ) ; if ( VAR6 != VAR7 ) { return VAR6 ; } } while ( ! VAR5 ) ; if ( VAR19 != VAR2 -> VAR22 ) { FUN11 ( VAR23 , VAR24 , 0 , VAR4 , FUN12 ( 01087 ) , VAR4 -> VAR28 -> VAR29 ) ; return VAR30 ; } return VAR7 ; } #0
443#443#"static void FUN1 ( const char * VAR1 ) { fprintf ( VAR2 , "" "" ) ; FUN2 ( 1 ) ; } "#0
444#444#"int FUN1 ( const VAR1 * VAR2 , VAR3 * VAR4 , unsigned VAR5 , unsigned VAR6 ) { unsigned VAR7 , VAR8 , VAR9 , VAR10 ; const char VAR11 = VAR2 -> VAR12 >= VAR13 || VAR2 -> VAR12 == VAR14 ; const unsigned VAR15 = 1 + VAR6 + ( VAR11 ? VAR5 : 0 ) ; if ( VAR15 > VAR4 -> VAR16 ) return 0 ; if ( VAR11 ) { VAR4 -> VAR17 += VAR5 ; VAR4 -> VAR18 += VAR5 ; VAR4 -> VAR16 -= VAR5 ; } VAR7 = VAR4 -> VAR17 [ VAR4 -> VAR16 - 1 ] ; if ( ( VAR2 -> VAR19 & VAR20 ) && ! VAR2 -> VAR21 ) { if ( ( memcmp ( VAR2 -> VAR22 -> VAR23 , "" "" , 8 ) == 0 ) && ! ( VAR7 & 1 ) ) { VAR2 -> VAR22 -> VAR24 |= VAR25 ; } if ( ( VAR2 -> VAR22 -> VAR24 & VAR25 ) && VAR7 > 0 ) { VAR7 -- ; } } if ( FUN2 ( VAR2 -> VAR26 -> VAR27 ) & VAR28 ) { VAR4 -> VAR16 -= VAR7 ; return 1 ; } VAR8 = FUN3 ( VAR4 -> VAR16 , VAR15 + VAR7 ) ; VAR9 = 255 ; if ( VAR9 > VAR4 -> VAR16 - 1 ) VAR9 = VAR4 -> VAR16 - 1 ; for ( VAR10 = 0 ; VAR10 < VAR9 ; VAR10 ++ ) { unsigned char VAR29 = FUN3 ( VAR7 , VAR10 ) ; unsigned char VAR30 = VAR4 -> VAR17 [ VAR4 -> VAR16 - 1 - VAR10 ] ; VAR8 &= ~ ( VAR29 & ( VAR7 ^ VAR30 ) ) ; } VAR8 &= VAR8 >> 4 ; VAR8 &= VAR8 >> 2 ; VAR8 &= VAR8 >> 1 ; VAR8 <<= sizeof ( VAR8 ) * 8 - 1 ; VAR8 = FUN4 ( VAR8 ) ; VAR7 = VAR8 & ( VAR7 + 1 ) ; VAR4 -> VAR16 -= VAR7 ; VAR4 -> VAR31 |= VAR7 << 8 ; return ( int ) ( ( VAR8 & 1 ) | ( ~ VAR8 & -1 ) ) ; } "#0
445#445#static VAR1 FUN1 ( VAR2 * VAR3 , struct VAR4 * VAR5 , apr_size_t VAR6 , VAR7 * VAR8 , VAR9 * VAR10 , VAR11 * VAR12 ) { apr_status_t VAR13 = VAR14 , VAR15 ; apr_size_t VAR16 = 0 , VAR17 = 0 ; apr_size_t VAR18 , VAR19 ; apr_interval_time_t VAR20 ; VAR15 = FUN2 ( VAR3 , & VAR20 ) ; if ( VAR15 != VAR14 ) { return VAR15 ; } VAR15 = FUN3 ( VAR3 , 0 ) ; if ( VAR15 != VAR14 ) { return VAR15 ; } for ( VAR18 = 0 ; VAR18 < VAR6 ; VAR18 ++ ) { VAR17 += VAR5 [ VAR18 ] . VAR21 ; } VAR19 = 0 ; while ( VAR16 < VAR17 ) { apr_size_t VAR22 = 0 ; VAR13 = FUN4 ( VAR3 , VAR5 + VAR19 , VAR6 - VAR19 , & VAR22 ) ; if ( VAR22 > 0 ) { VAR16 += VAR22 ; for ( VAR18 = VAR19 ; VAR18 < VAR6 ; ) { VAR23 * VAR24 = FUN5 ( VAR8 ) ; if ( FUN6 ( VAR24 ) ) { FUN7 ( VAR24 ) ; } else if ( VAR22 >= VAR5 [ VAR18 ] . VAR21 ) { FUN7 ( VAR24 ) ; VAR19 ++ ; VAR22 -= VAR5 [ VAR18 ++ ] . VAR21 ; } else { FUN8 ( VAR24 , VAR22 ) ; FUN7 ( VAR24 ) ; VAR5 [ VAR18 ] . VAR21 -= VAR22 ; VAR5 [ VAR18 ] . VAR25 = ( char * ) VAR5 [ VAR18 ] . VAR25 + VAR22 ; break ; } } } if ( VAR13 != VAR14 ) { break ; } } if ( ( VAR26 != NULL ) && ( VAR16 > 0 ) ) { FUN9 ( VAR12 , VAR16 ) ; } * VAR10 += VAR16 ; VAR15 = FUN3 ( VAR3 , VAR20 ) ; if ( ( VAR15 != VAR14 ) && ( VAR13 == VAR14 ) ) { return VAR15 ; } else { return VAR13 ; } } #1
446#446#int FUN1 ( VAR1 * VAR2 ) { int VAR3 = 1 ; if ( VAR2 == NULL ) return 1 ; FUN2 ( VAR4 ) ; VAR3 = FUN3 ( VAR2 , 1 ) ; FUN4 ( VAR4 ) ; if ( ! VAR3 ) { FUN5 ( VAR5 , VAR6 ) ; return 0 ; } return VAR3 ; } #0
447#447#void * FUN1 ( VAR1 * VAR2 , int VAR3 , const char * VAR4 , const char * VAR5 , void * ( * VAR6 ) ( const char * VAR4 , const VAR7 * VAR8 , VAR9 * VAR10 , void * VAR11 ) , void * VAR11 , int ( * VAR12 ) ( void * ) , void ( * VAR13 ) ( void * ) ) { VAR14 * VAR15 = FUN2 ( VAR2 ) ; VAR16 * VAR17 = FUN3 ( VAR2 ) ; int VAR18 = 0 ; uint32_t VAR19 = 0 ; void * VAR20 = NULL ; if ( VAR15 == NULL || VAR17 == NULL ) return NULL ; if ( ! FUN4 ( VAR3 > 0 ) ) return NULL ; if ( ( VAR18 = FUN5 ( VAR17 , VAR4 ) ) != 0 && ( VAR19 = FUN6 ( VAR3 , VAR18 ) ) == 0 ) return NULL ; if ( VAR18 == 0 || ! FUN7 ( VAR15 , VAR19 , VAR5 , & VAR20 ) ) { OSSL_METHOD_CONSTRUCT_METHOD VAR21 = { VAR22 , VAR23 , VAR24 , VAR25 , VAR26 , VAR27 } ; struct method_data_st VAR28 ; VAR28 . VAR21 = & VAR21 ; VAR28 . VAR2 = VAR2 ; VAR28 . VAR4 = VAR4 ; VAR28 . VAR29 = VAR6 ; VAR28 . VAR27 = VAR13 ; VAR28 . VAR30 = VAR12 ; VAR28 . VAR27 = VAR13 ; VAR28 . VAR11 = VAR11 ; if ( ( VAR20 = FUN8 ( VAR2 , VAR3 , VAR4 , VAR5 , 0 , & VAR21 , & VAR28 ) ) != NULL ) { VAR18 = FUN5 ( VAR17 , VAR4 ) ; VAR19 = FUN6 ( VAR3 , VAR18 ) ; FUN9 ( VAR15 , VAR19 , VAR5 , VAR20 ) ; } } else { FUN10 ( VAR20 ) ; } return VAR20 ; } #0
448#448#static void FUN1 ( VAR1 * VAR2 ) { if ( VAR2 -> VAR3 ) { memset ( VAR2 -> VAR4 + VAR2 -> VAR3 , 0 , 16 - VAR2 -> VAR3 ) ; FUN2 ( VAR2 , VAR2 -> VAR4 ) ; } } #0
449#449#static int FUN1 ( VAR1 * VAR2 ) { if ( VAR2 -> VAR3 ) { VAR4 * VAR5 = VAR2 -> VAR6 ; int VAR7 = FUN2 ( VAR2 , 1 ) ; if ( VAR7 < 0 ) return VAR7 ; return FUN3 ( VAR5 ) >> 24 - VAR2 -> VAR8 ; } return 0 ; } #0
450#450#int FUN1 ( VAR1 * VAR2 , const unsigned char * VAR3 , size_t VAR4 , const unsigned char * VAR5 , size_t VAR6 , const unsigned char * VAR7 , size_t VAR8 ) { VAR9 * VAR10 = & VAR2 -> VAR10 ; memset ( VAR10 -> VAR11 , 0 , sizeof ( VAR10 -> VAR11 ) ) ; memset ( VAR10 -> VAR12 , 0 , sizeof ( VAR10 -> VAR12 ) ) ; FUN2 ( VAR10 -> VAR11 , VAR2 -> VAR13 , & VAR10 -> VAR14 ) ; FUN3 ( VAR2 , VAR3 , VAR4 , VAR7 , VAR8 , VAR5 , VAR6 ) ; return 1 ; } #0
451#451#static int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , size_t VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; if ( VAR6 == NULL ) return 0 ; if ( ! FUN2 ( VAR3 , VAR4 ) ) { FUN3 ( VAR8 , VAR9 ) ; return ( 0 ) ; } VAR6 -> VAR3 = FUN4 ( VAR6 -> VAR3 , VAR4 ) ; if ( VAR6 -> VAR3 == NULL ) { FUN3 ( VAR8 , VAR10 ) ; return 0 ; } VAR6 -> VAR4 = VAR4 ; memcpy ( VAR6 -> VAR3 , VAR3 , VAR4 ) ; return 1 ; } #1
452#452#VAR1 FUN1 ( char * VAR2 , const char * VAR3 , size_t VAR4 ) { size_t VAR5 = 0 ; for ( ; VAR4 > 1 && * VAR3 ; VAR4 -- ) { * VAR2 ++ = * VAR3 ++ ; VAR5 ++ ; } if ( VAR4 ) * VAR2 = ' ' ; return VAR5 + strlen ( VAR3 ) ; } #1
453#453#"void FUN1 ( char * VAR1 , const char * VAR2 , int VAR3 , char * VAR4 ) { static const unsigned char VAR5 [ 17 ] = ) ; strcat ( VAR1 , VAR2 ) ; strcat ( VAR1 , "" "" ) ; VAR7 = strlen ( VAR1 ) ; for ( VAR6 = 0 ; VAR6 < VAR3 ; VAR6 ++ ) { VAR1 [ VAR7 + VAR6 * 2 ] = VAR5 [ ( VAR4 [ VAR6 ] >> 4 ) & 0x0f ] ; VAR1 [ VAR7 + VAR6 * 2 + 1 ] = VAR5 [ ( VAR4 [ VAR6 ] ) & 0x0f ] ; } VAR1 [ VAR7 + VAR6 * 2 ] = ' ' ; VAR1 [ VAR7 + VAR6 * 2 + 1 ] = ' ' ; } "#0
454#454#static void * FUN1 ( void * VAR1 , int VAR2 , int * VAR3 , int VAR4 ) { if ( VAR4 >= VAR5 / VAR2 ) { fprintf ( VAR6 , ) ; FUN2 ( 1 ) ; } memset ( VAR8 + * VAR3 * VAR2 , 0 , ( VAR4 - * VAR3 ) * VAR2 ) ; * VAR3 = VAR4 ; return VAR8 ; } return VAR1 ; } #1
455#455#"static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 , VAR6 * * VAR7 ) { VAR8 * VAR9 , * VAR10 ; size_t VAR11 ; ngx_int_t VAR12 , VAR13 ; VAR6 * VAR14 , * VAR15 , * VAR16 , * VAR17 , * VAR18 , VAR19 ; VAR20 * VAR21 ; ngx_uint_t VAR22 , VAR23 ; VAR24 * VAR25 , * VAR26 , * * VAR27 , * VAR28 ; VAR2 * VAR29 ; VAR30 * VAR31 ; VAR4 * VAR32 ; VAR33 * VAR34 ; VAR35 * VAR36 ; VAR14 = VAR7 [ VAR37 ] ; VAR15 = VAR7 [ VAR38 ] ; VAR16 = VAR7 [ VAR39 ] ; VAR17 = VAR7 [ VAR40 ] ; VAR18 = VAR7 [ VAR41 ] ; if ( VAR14 && VAR15 ) { FUN2 ( VAR42 , VAR3 -> VAR43 -> VAR44 , 0 , % VAR45 V AR47 V AR17 ) ; return VAR46 ; } if ( VAR16 ) { if ( VAR14 == NULL ) { FUN2 ( VAR42 , VAR3 -> VAR43 -> VAR44 , 0 , % VAR45 , 2 ) == 0 ) { VAR16 = NULL ; } else if ( VAR16 -> VAR11 != 3 || FUN3 ( VAR16 -> VAR48 , ( VAR8 * ) % VAR45 , VAR16 ) ; return VAR46 ; } } if ( VAR14 == NULL ) { VAR14 = VAR15 ; VAR16 = ( VAR6 * ) -1 ; } VAR12 = FUN4 ( VAR3 , VAR5 , VAR14 , VAR49 ) ; if ( VAR12 != VAR50 ) { return VAR12 ; } VAR9 = VAR14 -> VAR48 ; VAR10 = VAR14 -> VAR48 ; FUN5 ( & VAR9 , & VAR10 , VAR14 -> VAR11 , VAR51 ) ; VAR11 = ( VAR14 -> VAR48 + VAR14 -> VAR11 ) - VAR10 ; if ( VAR11 ) { VAR9 = FUN6 ( VAR9 , VAR10 , VAR11 ) ; } VAR14 -> VAR11 = VAR9 - VAR14 -> VAR48 ; FUN7 ( VAR52 , VAR3 -> VAR43 -> VAR44 , 0 , , VAR14 ) ; FUN8 ( & VAR19 ) ; VAR22 = VAR53 ; if ( FUN9 ( VAR3 , VAR14 , & VAR19 , & VAR22 ) != VAR50 ) { return VAR46 ; } VAR36 = NULL ; VAR32 = FUN10 ( VAR3 -> main , VAR54 ) ; if ( VAR18 ) { if ( VAR32 -> VAR55 ) { VAR34 = VAR32 -> VAR55 -> VAR56 ; for ( VAR23 = 0 ; VAR23 < VAR32 -> VAR55 -> VAR57 ; VAR23 ++ ) { if ( VAR18 -> VAR11 == VAR34 [ VAR23 ] . VAR58 . VAR11 && FUN11 ( VAR18 -> VAR48 , VAR34 [ VAR23 ] . VAR58 . VAR48 , VAR18 -> VAR11 ) == 0 ) { goto VAR59 ; } } } FUN2 ( VAR42 , VAR3 -> VAR43 -> VAR44 , 0 , % VAR45 , VAR18 ) ; return VAR46 ; VAR59 : VAR36 = FUN12 ( VAR3 -> VAR60 , sizeof ( VAR35 ) ) ; if ( VAR36 == NULL ) { return VAR61 ; } VAR36 -> VAR62 = VAR63 ; if ( VAR34 [ VAR23 ] . VAR64 ++ ) { VAR28 = NULL ; VAR27 = & VAR28 ; for ( VAR26 = VAR34 [ VAR23 ] . VAR65 ; VAR26 ; VAR26 = VAR26 -> VAR66 ) { if ( VAR5 -> free ) { VAR25 = VAR5 -> free ; VAR5 -> free = VAR5 -> free -> VAR66 ; VAR21 = VAR25 -> VAR67 ; } else { VAR21 = FUN13 ( VAR3 -> VAR60 ) ; if ( VAR21 == NULL ) { return VAR61 ; } VAR25 = FUN14 ( VAR3 -> VAR60 ) ; if ( VAR25 == NULL ) { return VAR61 ; } VAR25 -> VAR67 = VAR21 ; } FUN15 ( VAR21 , VAR26 -> VAR67 , sizeof ( VAR20 ) ) ; VAR21 -> VAR68 = VAR21 -> VAR69 ; * VAR27 = VAR25 ; VAR25 -> VAR66 = NULL ; VAR27 = & VAR25 -> VAR66 ; } VAR36 -> VAR48 = VAR28 ; } else { VAR36 -> VAR48 = VAR34 [ VAR23 ] . VAR65 ; } } if ( VAR16 ) { VAR22 |= VAR70 ; } if ( VAR17 ) { VAR13 = FUN16 ( VAR17 -> VAR48 , VAR17 -> VAR48 , VAR17 -> VAR11 ) ; VAR36 = FUN12 ( VAR3 -> VAR60 , sizeof ( VAR35 ) ) ; if ( VAR36 == NULL ) { return VAR61 ; } VAR36 -> VAR62 = VAR71 ; VAR36 -> VAR48 = FUN17 ( VAR3 , VAR17 , VAR13 ) ; if ( VAR36 -> VAR48 == NULL ) { if ( VAR32 -> VAR72 == NULL ) { VAR32 -> VAR72 = FUN18 ( VAR3 -> VAR60 , 4 , sizeof ( VAR30 ) ) ; if ( VAR32 -> VAR72 == NULL ) { return VAR61 ; } } VAR31 = FUN19 ( VAR32 -> VAR72 ) ; if ( VAR31 == NULL ) { return VAR61 ; } VAR31 -> VAR58 = * VAR17 ; VAR31 -> VAR13 = VAR13 ; VAR31 -> VAR73 = VAR74 ; VAR36 -> VAR48 = & VAR31 -> VAR73 ; } VAR22 |= VAR75 | VAR70 ; } if ( FUN20 ( VAR3 , VAR14 , & VAR19 , & VAR29 , VAR36 , VAR22 ) != VAR50 ) { return VAR46 ; } if ( VAR16 == NULL && VAR17 == NULL ) { return VAR50 ; } if ( VAR5 -> VAR16 == NULL ) { VAR5 -> VAR16 = VAR29 ; return VAR76 ; } else { FUN2 ( VAR42 , VAR3 -> VAR43 -> VAR44 , 0 , "" "" ) ; } return VAR50 ; } "#1
456#456#int FUN1 ( VAR1 * VAR2 [ 4 ] , enum PixelFormat VAR3 , int VAR4 , VAR1 * VAR5 , const int VAR6 [ 4 ] ) { int VAR7 , VAR8 , VAR9 [ 4 ] , VAR10 [ 4 ] ; const VAR11 * VAR12 = & VAR13 [ VAR3 ] ; memset ( VAR2 , 0 , sizeof ( VAR2 [ 0 ] ) * 4 ) ; memset ( VAR9 , 0 , sizeof ( VAR9 ) ) ; memset ( VAR10 , 0 , sizeof ( VAR10 ) ) ; if ( VAR12 -> VAR14 & VAR15 ) return FUN2 ( VAR16 ) ; VAR2 [ 0 ] = VAR5 ; VAR9 [ 0 ] = VAR6 [ 0 ] * VAR4 ; if ( VAR12 -> VAR14 & VAR17 ) { VAR9 [ 0 ] = ( VAR9 [ 0 ] + 3 ) & ~ 3 ; VAR2 [ 1 ] = VAR5 + VAR9 [ 0 ] ; return VAR9 [ 0 ] + 256 * 4 ; } for ( VAR7 = 0 ; VAR7 < 4 ; VAR7 ++ ) VAR10 [ VAR12 -> VAR18 [ VAR7 ] . VAR19 ] = 1 ; VAR8 = VAR9 [ 0 ] ; for ( VAR7 = 1 ; VAR10 [ VAR7 ] && VAR7 < 4 ; VAR7 ++ ) { int VAR20 , VAR21 = ( VAR7 == 1 || VAR7 == 2 ) ? VAR12 -> VAR22 : 0 ; VAR2 [ VAR7 ] = VAR2 [ VAR7 - 1 ] + VAR9 [ VAR7 - 1 ] ; VAR20 = ( VAR4 + ( 1 << VAR21 ) - 1 ) >> VAR21 ; VAR9 [ VAR7 ] = VAR20 * VAR6 [ VAR7 ] ; VAR8 += VAR9 [ VAR7 ] ; } return VAR8 ; } #1
457#457#static void FUN1 ( fe VAR1 , fe VAR2 ) { int32_t VAR3 = VAR2 [ 0 ] ; int32_t VAR4 = VAR2 [ 1 ] ; int32_t VAR5 = VAR2 [ 2 ] ; int32_t VAR6 = VAR2 [ 3 ] ; int32_t VAR7 = VAR2 [ 4 ] ; int32_t VAR8 = VAR2 [ 5 ] ; int32_t VAR9 = VAR2 [ 6 ] ; int32_t VAR10 = VAR2 [ 7 ] ; int32_t VAR11 = VAR2 [ 8 ] ; int32_t VAR12 = VAR2 [ 9 ] ; int64_t VAR13 = VAR3 * ( VAR14 ) 121666 ; int64_t VAR15 = VAR4 * ( VAR14 ) 121666 ; int64_t VAR16 = VAR5 * ( VAR14 ) 121666 ; int64_t VAR17 = VAR6 * ( VAR14 ) 121666 ; int64_t VAR18 = VAR7 * ( VAR14 ) 121666 ; int64_t VAR19 = VAR8 * ( VAR14 ) 121666 ; int64_t VAR20 = VAR9 * ( VAR14 ) 121666 ; int64_t VAR21 = VAR10 * ( VAR14 ) 121666 ; int64_t VAR22 = VAR11 * ( VAR14 ) 121666 ; int64_t VAR23 = VAR12 * ( VAR14 ) 121666 ; int64_t VAR24 ; int64_t VAR25 ; int64_t VAR26 ; int64_t VAR27 ; int64_t VAR28 ; int64_t VAR29 ; int64_t VAR30 ; int64_t VAR31 ; int64_t VAR32 ; int64_t VAR33 ; VAR33 = VAR23 + ( 1 << 24 ) ; VAR13 += ( VAR33 >> 25 ) * 19 ; VAR23 -= VAR33 & VAR34 ; VAR25 = VAR15 + ( 1 << 24 ) ; VAR16 += VAR25 >> 25 ; VAR15 -= VAR25 & VAR34 ; VAR27 = VAR17 + ( 1 << 24 ) ; VAR18 += VAR27 >> 25 ; VAR17 -= VAR27 & VAR34 ; VAR29 = VAR19 + ( 1 << 24 ) ; VAR20 += VAR29 >> 25 ; VAR19 -= VAR29 & VAR34 ; VAR31 = VAR21 + ( 1 << 24 ) ; VAR22 += VAR31 >> 25 ; VAR21 -= VAR31 & VAR34 ; VAR24 = VAR13 + ( 1 << 25 ) ; VAR15 += VAR24 >> 26 ; VAR13 -= VAR24 & VAR35 ; VAR26 = VAR16 + ( 1 << 25 ) ; VAR17 += VAR26 >> 26 ; VAR16 -= VAR26 & VAR35 ; VAR28 = VAR18 + ( 1 << 25 ) ; VAR19 += VAR28 >> 26 ; VAR18 -= VAR28 & VAR35 ; VAR30 = VAR20 + ( 1 << 25 ) ; VAR21 += VAR30 >> 26 ; VAR20 -= VAR30 & VAR35 ; VAR32 = VAR22 + ( 1 << 25 ) ; VAR23 += VAR32 >> 26 ; VAR22 -= VAR32 & VAR35 ; VAR1 [ 0 ] = ( VAR36 ) VAR13 ; VAR1 [ 1 ] = ( VAR36 ) VAR15 ; VAR1 [ 2 ] = ( VAR36 ) VAR16 ; VAR1 [ 3 ] = ( VAR36 ) VAR17 ; VAR1 [ 4 ] = ( VAR36 ) VAR18 ; VAR1 [ 5 ] = ( VAR36 ) VAR19 ; VAR1 [ 6 ] = ( VAR36 ) VAR20 ; VAR1 [ 7 ] = ( VAR36 ) VAR21 ; VAR1 [ 8 ] = ( VAR36 ) VAR22 ; VAR1 [ 9 ] = ( VAR36 ) VAR23 ; } #1
458#458#"const VAR1 * FUN1 ( VAR2 * * VAR3 , int VAR4 ) { const VAR1 * VAR5 ; for ( ; ; ) { VAR5 = FUN2 ( VAR4 ) ; if ( ! VAR5 || ! ( VAR5 -> VAR6 & VAR7 ) ) break ; VAR4 = VAR5 -> VAR8 ; } if ( VAR3 ) { #ifndef OPENSSL_NO_ENGINE VAR2 * VAR9 ; VAR9 = FUN3 ( VAR4 ) ; if ( VAR9 ) { * VAR3 = VAR9 ; return FUN4 ( VAR9 , VAR4 ) ; } #endif * VAR3 = NULL ; } return VAR5 ; } "#1
459#459#char * FUN1 ( const char * VAR1 , size_t VAR2 ) { char * VAR3 = NULL , * VAR4 ; if ( ! VAR1 ) return NULL ; VAR4 = memchr ( VAR1 , 0 , VAR2 ) ; if ( VAR4 ) VAR2 = VAR4 - VAR1 ; VAR3 = FUN2 ( NULL , VAR2 + 1 ) ; if ( ! VAR3 ) return NULL ; memcpy ( VAR3 , VAR1 , VAR2 ) ; VAR3 [ VAR2 ] = 0 ; return VAR3 ; } #1
460#460#void FUN1 ( VAR1 * VAR2 ) { if ( VAR2 == NULL ) return ; if ( ! FUN2 ( VAR2 , VAR3 ) ) FUN3 ( VAR2 ) ; if ( VAR2 -> VAR4 & VAR5 ) FUN4 ( VAR2 ) ; } #0
461#461#"static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 ) { int VAR5 = 0 , VAR6 ; int VAR7 = 0 ; AVPacket VAR8 ; if ( ! VAR2 -> VAR9 ) { VAR2 -> VAR10 = VAR2 -> VAR11 -> VAR12 . VAR13 ? - VAR2 -> VAR11 -> VAR14 -> VAR15 * VAR16 / FUN2 ( VAR2 -> VAR11 -> VAR12 ) : 0 ; VAR2 -> VAR17 = 0 ; if ( VAR4 != NULL && VAR4 -> VAR17 != VAR18 && ! VAR2 -> VAR19 ) { VAR2 -> VAR10 += FUN3 ( VAR4 -> VAR17 , VAR2 -> VAR11 -> VAR20 , VAR21 ) ; VAR2 -> VAR17 = VAR2 -> VAR10 ; } VAR2 -> VAR9 = 1 ; } if ( VAR2 -> VAR22 == VAR18 ) VAR2 -> VAR22 = VAR2 -> VAR10 ; if ( VAR2 -> VAR23 == VAR18 ) VAR2 -> VAR23 = VAR2 -> VAR17 ; if ( VAR4 == NULL ) { FUN4 ( & VAR8 ) ; VAR8 . VAR24 = NULL ; VAR8 . VAR25 = 0 ; goto VAR26 ; } else { VAR8 = * VAR4 ; } if ( VAR4 -> VAR10 != VAR18 ) { VAR2 -> VAR22 = VAR2 -> VAR10 = FUN3 ( VAR4 -> VAR10 , VAR2 -> VAR11 -> VAR20 , VAR21 ) ; if ( VAR2 -> VAR11 -> VAR14 -> VAR27 != VAR28 || ! VAR2 -> VAR19 ) VAR2 -> VAR23 = VAR2 -> VAR17 = VAR2 -> VAR10 ; } while ( VAR2 -> VAR19 && ( VAR8 . VAR25 > 0 || ( ! VAR4 && VAR7 ) ) ) { int VAR29 ; VAR26 : VAR2 -> VAR17 = VAR2 -> VAR23 ; VAR2 -> VAR10 = VAR2 -> VAR22 ; if ( VAR8 . VAR25 && VAR8 . VAR25 != VAR4 -> VAR25 ) { FUN5 ( NULL , VAR2 -> VAR30 ? VAR31 : VAR32 , "" "" , VAR4 -> VAR33 ) ; VAR2 -> VAR30 = 1 ; } switch ( VAR2 -> VAR11 -> VAR14 -> VAR27 ) { case VAR34 : VAR5 = FUN6 ( VAR2 , & VAR8 , & VAR7 ) ; break ; case VAR28 : VAR5 = FUN7 ( VAR2 , & VAR8 , & VAR7 ) ; if ( VAR8 . VAR29 ) { VAR29 = FUN3 ( VAR8 . VAR29 , VAR2 -> VAR11 -> VAR20 , VAR21 ) ; } else if ( VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR13 != 0 && VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR35 != 0 ) { int VAR36 = VAR2 -> VAR11 -> VAR37 ? VAR2 -> VAR11 -> VAR37 -> VAR38 + 1 : VAR2 -> VAR11 -> VAR14 -> VAR39 ; VAR29 = ( ( VAR40 ) VAR16 * VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR13 * VAR36 ) / VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR35 ; } else VAR29 = 0 ; if ( VAR2 -> VAR10 != VAR18 && VAR29 ) { VAR2 -> VAR22 += VAR29 ; } else VAR2 -> VAR22 = VAR18 ; if ( VAR7 ) VAR2 -> VAR23 += VAR29 ; break ; case VAR41 : VAR5 = FUN8 ( VAR2 , & VAR8 , & VAR7 ) ; break ; default : return -1 ; } if ( VAR5 < 0 ) return VAR5 ; VAR8 . VAR10 = VAR8 . VAR17 = VAR18 ; if ( VAR4 ) { if ( VAR2 -> VAR11 -> VAR14 -> VAR27 != VAR34 ) VAR5 = VAR8 . VAR25 ; VAR8 . VAR24 += VAR5 ; VAR8 . VAR25 -= VAR5 ; } if ( ! VAR7 ) { continue ; } } if ( ! VAR2 -> VAR19 ) { FUN9 ( VAR2 ) ; VAR2 -> VAR10 = VAR2 -> VAR22 ; switch ( VAR2 -> VAR11 -> VAR14 -> VAR27 ) { case VAR34 : VAR2 -> VAR22 += ( ( VAR40 ) VAR16 * VAR2 -> VAR11 -> VAR14 -> VAR42 ) / VAR2 -> VAR11 -> VAR14 -> VAR43 ; break ; case VAR28 : if ( VAR4 -> VAR29 ) { VAR2 -> VAR22 += FUN3 ( VAR4 -> VAR29 , VAR2 -> VAR11 -> VAR20 , VAR21 ) ; } else if ( VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR13 != 0 ) { int VAR36 = VAR2 -> VAR11 -> VAR37 ? VAR2 -> VAR11 -> VAR37 -> VAR38 + 1 : VAR2 -> VAR11 -> VAR14 -> VAR39 ; VAR2 -> VAR22 += ( ( VAR40 ) VAR16 * VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR13 * VAR36 ) / VAR2 -> VAR11 -> VAR14 -> VAR20 . VAR35 ; } break ; } VAR2 -> VAR17 = VAR2 -> VAR10 ; VAR2 -> VAR23 = VAR2 -> VAR22 ; } for ( VAR6 = 0 ; VAR4 && VAR6 < VAR44 ; VAR6 ++ ) { VAR45 * VAR46 = VAR47 [ VAR6 ] ; if ( ! FUN10 ( VAR2 , VAR46 ) || VAR46 -> VAR48 ) continue ; FUN11 ( VAR2 , VAR46 , VAR4 ) ; } return 0 ; } "#0
462#462#static VAR1 * FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR1 * VAR5 = FUN2 ( ) ; FUN3 ( VAR5 , VAR2 ) ; FUN4 ( VAR5 , VAR4 ) ; FUN5 ( VAR5 ) ; return VAR5 ; } #1
463#463#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 , VAR7 , VAR8 , VAR9 ; int VAR10 ; int VAR11 ; int VAR12 ; int VAR13 ; int VAR14 [ VAR15 ] ; const int * VAR16 ; if ( VAR2 -> VAR17 ) { for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR18 ; VAR5 ++ ) VAR2 -> VAR19 [ VAR5 ] . VAR20 = VAR21 ; } else { VAR10 = FUN2 ( VAR4 , 3 ) ; if ( VAR10 == 0 ) { for ( VAR5 = 0 ; VAR5 < 8 ; VAR5 ++ ) VAR14 [ VAR5 ] = VAR22 ; for ( VAR5 = 0 ; VAR5 < 8 ; VAR5 ++ ) VAR14 [ FUN2 ( VAR4 , 3 ) ] = VAR5 ; VAR16 = VAR14 ; } else VAR16 = VAR23 [ VAR10 - 1 ] ; for ( VAR9 = 0 ; VAR9 < VAR2 -> VAR24 ; VAR9 ++ ) { for ( VAR8 = 0 ; VAR8 < VAR2 -> VAR25 ; VAR8 ++ ) { for ( VAR6 = 0 ; VAR6 < 4 ; VAR6 ++ ) { int VAR26 = 2 * VAR8 + ( VAR6 >> 1 ) ; int VAR27 = 2 * VAR9 + ( ( ( VAR6 >> 1 ) + VAR6 ) & 1 ) ; int VAR28 = 0 ; VAR11 = VAR27 * VAR2 -> VAR29 + VAR26 ; if ( VAR26 >= VAR2 -> VAR29 || VAR27 >= VAR2 -> VAR30 ) continue ; #define FUN3 (2*VAR26 + (VAR7&1)) #define FUN4 (2*VAR27 + (VAR7>>1))  for (VAR7 = 0; VAR7 < 4; VAR7++) { VAR12 = VAR31*VAR2->VAR32 + VAR33; if (VAR2->VAR19[VAR12].VAR20 != VAR34) break; } if (VAR7 == 4) { VAR2->VAR35[VAR11] = VAR22; continue; }   if (VAR10 == 7) VAR13 = FUN2(VAR4, 3); else VAR13 = VAR16 [FUN5(VAR4, VAR2->VAR36.VAR37, 3, 3)];  VAR2->VAR35[VAR11] = VAR13; for (VAR7 = 0; VAR7 < 4; VAR7++) { VAR12 = VAR31*VAR2->VAR32 + VAR33; if (VAR2->VAR19[VAR12].VAR20 != VAR34) VAR2->VAR19[VAR12].VAR20 = VAR13; } for (VAR7 = 0; VAR7 < 2; VAR7++) { VAR12 = VAR2->VAR38[VAR7+1] + VAR27*(VAR2->VAR32>>1) + VAR26; if (VAR2->VAR19[VAR12].VAR20 != VAR34) VAR2->VAR19[VAR12].VAR20 = VAR13; } } } } }  return 0; } "#0
464#464#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 ; int VAR6 , VAR7 ; int VAR8 ; unsigned VAR9 , VAR10 , VAR11 ; VAR10 = VAR2 -> VAR12 ; VAR2 -> VAR12 >>= VAR13 ; VAR11 = VAR2 -> VAR14 / VAR2 -> VAR12 ; VAR8 = VAR11 >> VAR15 ; VAR5 = VAR4 -> VAR16 [ VAR8 ] ; VAR7 = VAR6 = VAR4 -> VAR16 [ VAR8 + 1 ] + 1 ; while ( VAR7 > VAR5 + 1 ) { VAR8 = ( VAR7 + VAR5 ) >> 1 ; if ( VAR4 -> VAR17 [ VAR8 ] <= VAR11 ) { VAR7 = VAR6 ; VAR5 = VAR8 ; } else { VAR7 = ( VAR7 + VAR5 ) >> 1 ; VAR6 = VAR8 ; } } VAR9 = VAR4 -> VAR17 [ VAR5 ] * VAR2 -> VAR12 ; if ( VAR5 != 255 ) VAR10 = VAR4 -> VAR17 [ VAR5 + 1 ] * VAR2 -> VAR12 ; VAR2 -> VAR14 -= VAR9 ; VAR2 -> VAR12 = VAR10 - VAR9 ; if ( VAR2 -> VAR12 < VAR18 ) FUN2 ( VAR2 ) ; FUN3 ( VAR4 , VAR5 ) ; return VAR5 ; } #0
465#465#static const char * FUN1 ( VAR1 * VAR2 , void * VAR3 , int argc , char * const argv [ ] ) { int VAR4 ; char * VAR5 ; apr_int32_t VAR6 ; apr_int32_t VAR7 ; apr_int32_t VAR8 ; char VAR9 ; VAR10 * VAR11 = ( VAR10 * ) VAR3 ; VAR6 = VAR11 -> VAR6 ; VAR7 = VAR11 -> VAR12 ; VAR8 = VAR11 -> VAR13 ; for ( VAR4 = 0 ; VAR4 < argc ; VAR4 ++ ) { int VAR14 = 0 ; VAR5 = argv [ VAR4 ] ; if ( ( * VAR5 == ' ' ) || ( * VAR5 == ' ' ) ) { VAR9 = * ( VAR5 ++ ) ; } else { VAR9 = ' ' ; } if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR16 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR18 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR20 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR22 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR24 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR26 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR28 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR30 ; } else if ( ! FUN2 ( VAR5 , ) ) { VAR14 = VAR32 ; } else if ( ! FUN2 ( VAR5 , ; } VAR6 = VAR33 ; VAR7 = 0 ; VAR8 = 0 ; } else if ( ! FUN2 ( VAR5 , , 10 ) ) { if ( VAR9 == ' ' { return ) ) { if ( VAR9 != ' ' { VAR11 -> VAR36 = VAR37 ; } else { VAR11 -> VAR36 = 0 ; } } else if ( ! FUN3 ( VAR5 , ; } VAR11 -> VAR36 = FUN4 ( & VAR5 [ 11 ] ) ; } else if ( ! FUN2 ( VAR5 , , 10 ) ) { if ( VAR9 == ' ' { return ; } VAR11 -> VAR38 = VAR43 ; VAR11 -> VAR40 = VAR41 ; } } else if ( ! FUN2 ( VAR5 , , 17 ) ) { if ( VAR9 == ' ' { return ; } VAR11 -> VAR44 = VAR43 ; VAR11 -> VAR46 = VAR41 ; } } else { return ; } VAR11 -> VAR12 = VAR7 ; VAR11 -> VAR13 = VAR8 ; VAR11 -> VAR6 = VAR6 ; return NULL ; } #0
466#466#int FUN1 ( VAR1 * VAR2 ) { AVPacket VAR3 ; if ( ! VAR2 -> VAR4 && VAR2 -> VAR5 ) { VAR3 = * VAR2 ; VAR2 -> VAR5 = NULL ; VAR2 -> VAR6 = NULL ; FUN2 ( VAR2 -> VAR5 , VAR3 . VAR5 , VAR2 -> VAR7 , 1 , VAR8 ) ; if ( VAR2 -> VAR9 ) { int VAR10 ; FUN2 ( VAR2 -> VAR6 , VAR3 . VAR6 , VAR2 -> VAR9 * sizeof ( * VAR2 -> VAR6 ) , 0 , VAR11 ) ; memset ( VAR2 -> VAR6 , 0 , VAR2 -> VAR9 * sizeof ( * VAR2 -> VAR6 ) ) ; for ( VAR10 = 0 ; VAR10 < VAR2 -> VAR9 ; VAR10 ++ ) { FUN2 ( VAR2 -> VAR6 [ VAR10 ] . VAR5 , VAR3 . VAR6 [ VAR10 ] . VAR5 , VAR3 . VAR6 [ VAR10 ] . VAR7 , 1 , VAR11 ) ; VAR2 -> VAR6 [ VAR10 ] . VAR7 = VAR3 . VAR6 [ VAR10 ] . VAR7 ; VAR2 -> VAR6 [ VAR10 ] . VAR12 = VAR3 . VAR6 [ VAR10 ] . VAR12 ; } } } return 0 ; VAR13 : FUN3 ( VAR2 ) ; return FUN4 ( VAR14 ) ; } #1
467#467#static av_cold void FUN1 ( VAR1 * VAR2 ) { FUN2 ( & VAR2 -> VAR3 ) ; } #0
468#468#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR9 ; int VAR10 = 0 ; int VAR11 = 0 ; unsigned int VAR12 , VAR13 ; int VAR14 = 0 ; int FUN2 ( VAR15 ) ; while ( ! VAR11 ) { VAR12 = FUN3 ( VAR9 ) ; VAR13 = VAR6 -> VAR16 ? FUN4 ( VAR9 ) : FUN3 ( VAR9 ) ; if ( VAR13 <= 8 ) return VAR17 ; VAR13 -= 8 ; switch ( VAR12 ) { case VAR18 : if ( VAR13 < 32 ) return VAR17 ; FUN5 ( VAR9 , 32 ) ; VAR13 -= 32 ; case VAR19 : case VAR20 : case VAR21 : case VAR22 : if ( ! VAR6 -> VAR23 ) { FUN5 ( VAR9 , VAR13 ) ; break ; } else if ( VAR6 -> VAR23 == VAR24 || VAR6 -> VAR23 == VAR25 ) { VAR15 = FUN3 ( VAR9 ) ; FUN5 ( VAR9 , 8 ) ; VAR13 -= 12 ; } VAR10 = FUN6 ( VAR9 , VAR4 , VAR13 ) ; if ( VAR10 < 0 ) return VAR10 ; VAR4 -> VAR26 = VAR6 -> VAR27 ; switch ( VAR6 -> VAR23 ) { case VAR28 : case VAR29 : case VAR30 : case VAR31 : VAR4 -> VAR32 = FUN7 ( VAR4 -> VAR33 ) ; break ; case VAR34 : VAR4 -> VAR32 = FUN8 ( VAR4 -> VAR33 ) ; break ; case VAR35 : VAR4 -> VAR32 = VAR10 * 2 / VAR6 -> VAR36 ; break ; case VAR24 : case VAR25 : VAR4 -> VAR32 = VAR15 ; break ; default : VAR4 -> VAR32 = VAR13 / ( VAR6 -> VAR37 * VAR6 -> VAR36 ) ; } VAR11 = 1 ; break ; case 0 : case VAR38 : case VAR39 : case VAR40 : case VAR41 : VAR10 = FUN9 ( VAR42 ) ; VAR11 = 1 ; break ; case VAR43 : case VAR44 : case VAR45 : case VAR46 : case VAR47 : VAR14 = VAR48 ; case VAR49 : case VAR50 : case VAR51 : case VAR52 : FUN10 ( VAR9 , -8 , VAR53 ) ; VAR13 += 8 ; goto VAR54 ; case VAR55 : FUN5 ( VAR9 , 8 ) ; VAR13 -= 8 ; goto VAR54 ; case VAR56 : case VAR57 : case VAR58 : VAR14 = VAR48 ; case VAR59 : VAR54 : VAR10 = FUN6 ( VAR9 , VAR4 , VAR13 ) ; if ( VAR10 < 0 ) return VAR10 ; VAR4 -> VAR26 = VAR6 -> VAR60 ; VAR4 -> VAR61 |= VAR14 ; VAR11 = 1 ; break ; default : FUN5 ( VAR9 , VAR13 ) ; break ; } } return VAR10 ; } #0
469#469#"static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { uint8_t VAR5 [ 256 ] = { 0 } ; uint8_t VAR6 [ 256 ] ; int VAR7 [ 256 ] = { 0 } ; int VAR8 , VAR9 , VAR10 , VAR11 ; #VAR12 FUN2(VAR10,VAR11) VAR2->VAR13[0][(VAR10) + (VAR11)*VAR2->VAR14[0]] for (VAR11 = 0; VAR11<VAR4; VAR11++) { for (VAR10 = 0; VAR10<VAR3; VAR10++) { int VAR15 = FUN2(VAR10,VAR11) + 1; int VAR16 = VAR10     ? FUN2(VAR10-1,VAR11) + 1 : 0; int VAR17 = VAR10+1<VAR3 ? FUN2(VAR10+1,VAR11) + 1 : 0; int VAR18 = VAR11     ? FUN2(VAR10,VAR11-1) + 1 : 0; int VAR19 = VAR11+1<VAR4 ? FUN2(VAR10,VAR11+1) + 1 : 0; VAR7[VAR15-1] += !!((VAR15!=VAR16) + (VAR15!=VAR17) + (VAR15!=VAR18) + (VAR15!=VAR19)); } } #VAR12 FUN3(VAR10,VAR11) VAR5[ VAR2->VAR13[0][(VAR10) + (VAR11)*VAR2->VAR14[0]] ]  for (VAR9 = 0; VAR9<256; VAR9++) { int VAR20[256] = {0}; int VAR21 = 0; int VAR22 = 0; for (VAR11 = 0; VAR11<VAR4; VAR11++) { for (VAR10 = 0; VAR10<VAR3; VAR10++) { int VAR15 = VAR2->VAR13[0][VAR10 + VAR11*VAR2->VAR14[0]]; int VAR23 = VAR5[VAR15]; int VAR24 = VAR10     ? FUN3(VAR10-1, VAR11) : 1; int VAR25 = VAR10+1<VAR3 ? FUN3(VAR10+1, VAR11) : 1; int VAR26 = VAR11     ? FUN3(VAR10, VAR11-1) : 1; int VAR27 = VAR11+1<VAR4 ? FUN3(VAR10, VAR11+1) : 1; int VAR28; if (VAR23) continue; VAR20[VAR15] += VAR24 + VAR25 + VAR26 + VAR27; VAR28 = 1024LL*VAR20[VAR15] / VAR7[VAR15]; if (VAR28 > VAR21) { VAR21 = VAR28; VAR22 = VAR15; } } } if (!VAR21) break; VAR5    [ VAR22 ] = 1; VAR6[     VAR9 ] = VAR22; }  VAR8 = FUN4(VAR9 - 1, 1); for (VAR9--; VAR9>=0; VAR9--) { int VAR15 = VAR9*255/VAR8; FUN5(VAR2->VAR13[1] + 4*VAR6[VAR9], FUN6(VAR15/2,VAR15,VAR15/2,VAR15)); } } "#1
470#470#"static int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 , VAR6 ; int64_t VAR7 ; int VAR8 = 0 ; if ( FUN2 ( & VAR2 -> VAR9 ) < 30 ) { FUN3 ( VAR2 -> VAR10 , VAR11 , , VAR3 ) ; return VAR12 ; } VAR4 = FUN6 ( & VAR2 -> VAR9 ) ; if ( VAR4 != 1 ) { FUN3 ( VAR2 -> VAR10 , VAR11 , , VAR2 -> VAR13 ) ; return VAR12 ; } VAR2 -> VAR14 = FUN8 ( & VAR2 -> VAR9 ) ; if ( ( VAR2 -> VAR14 > 30000 ) && ( VAR2 -> VAR10 -> VAR15 > VAR16 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , , VAR16 ) ; return VAR17 ; } VAR2 -> VAR18 = FUN8 ( & VAR2 -> VAR9 ) ; if ( ( VAR2 -> VAR18 > 30000 ) && ( VAR2 -> VAR10 -> VAR15 > VAR16 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , , VAR16 ) ; return VAR17 ; } if ( ( VAR8 = FUN9 ( VAR2 -> VAR10 , VAR2 -> VAR18 , VAR2 -> VAR14 ) ) < 0 ) return VAR8 ; VAR2 -> VAR19 = FUN6 ( & VAR2 -> VAR9 ) ; VAR5 = FUN6 ( & VAR2 -> VAR9 ) ; switch ( VAR5 ) { case 0 : VAR2 -> VAR5 = VAR20 ; break ; case 1 : VAR2 -> VAR5 = VAR21 ; break ; case 2 : VAR2 -> VAR5 = VAR22 ; break ; case 3 : VAR2 -> VAR5 = VAR23 ; break ; case 4 : VAR2 -> VAR5 = VAR24 ; break ; case 7 : VAR2 -> VAR5 = VAR25 ; break ; case 8 : VAR2 -> VAR5 = VAR26 ; break ; case 9 : VAR2 -> VAR5 = VAR27 ; break ; default : FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return VAR12 ; } if ( FUN2 ( & VAR2 -> VAR9 ) < ( VAR7 + 4 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return VAR12 ; } if ( FUN2 ( & VAR2 -> VAR9 ) < ( VAR7 + 4 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return VAR12 ; } if ( FUN2 ( & VAR2 -> VAR9 ) < VAR7 ) { FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return VAR12 ; } VAR2 -> VAR6 = FUN6 ( & VAR2 -> VAR9 ) ; switch ( VAR2 -> VAR6 ) { case 0 : case 1 : break ; case 2 : FUN10 ( VAR2 -> VAR10 , ) ; return VAR28 ; break ; default : FUN3 ( VAR2 -> VAR10 , VAR11 , "" "" , VAR6 ) ; return VAR12 ; } return VAR8 ; } "#1
471#471#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 ; VAR10 * VAR11 ; VAR12 * VAR13 = NULL ; int VAR14 ; VAR6 -> VAR15 = VAR2 ; VAR16 : VAR11 = FUN2 ( VAR2 , & VAR13 ) ; if ( ! VAR11 ) { VAR6 -> VAR17 = 0 ; if ( ! VAR6 -> VAR18 ) return VAR19 ; if ( FUN3 ( VAR2 -> VAR20 , VAR6 -> VAR18 , VAR21 ) != VAR6 -> VAR18 ) { FUN4 ( VAR6 -> VAR15 , VAR22 , , VAR6 -> VAR18 ) ; return VAR24 ; } VAR6 -> VAR18 = 0 ; if ( FUN5 ( VAR6 , VAR2 -> VAR20 , ( VAR25 ) { FUN6 ( VAR23VAR23 ) ; } else { memcpy ( VAR37 , VAR9 -> VAR40 , VAR39 ) ; VAR9 -> VAR35 = 0 ; } } #if CONFIG_DV_DEMUXER if ( VAR6 -> VAR41 && VAR9 -> VAR42 ) { FUN13 ( VAR6 -> VAR41 , VAR4 , VAR4 -> VAR43 , VAR4 -> VAR30 , VAR4 -> VAR29 ) ; FUN14 ( & VAR4 -> VAR43 ) ; VAR4 -> VAR30 = 0 ; VAR14 = FUN15 ( VAR6 -> VAR41 , VAR4 ) ; if ( VAR14 < 0 ) return VAR14 ; } #endif } VAR4 -> VAR44 = VAR9 -> VAR34 ; VAR4 -> VAR45 = VAR11 -> VAR46 ; if ( VAR9 -> VAR47 && VAR9 -> VAR48 < VAR9 -> VAR49 ) { VAR4 -> VAR50 = VAR4 -> VAR45 + VAR9 -> VAR51 + VAR9 -> VAR47 [ VAR9 -> VAR48 ] . VAR52 ; VAR9 -> VAR53 ++ ; if ( VAR9 -> VAR48 < VAR9 -> VAR49 && VAR9 -> VAR47 [ VAR9 -> VAR48 ] . VAR54 == VAR9 -> VAR53 ) { VAR9 -> VAR48 ++ ; VAR9 -> VAR53 = 0 ; } if ( VAR9 -> VAR55 ) VAR4 -> VAR45 = VAR56 ; } else { int64_t VAR57 = ( VAR9 -> VAR28 < VAR13 -> VAR58 ) ? VAR13 -> VAR59 [ VAR9 -> VAR28 ] . VAR46 : VAR13 -> VAR52 ; VAR4 -> VAR52 = VAR57 - VAR4 -> VAR45 ; VAR4 -> VAR50 = VAR4 -> VAR45 ; } if ( VAR13 -> VAR31 == VAR32 ) goto VAR16 ; VAR4 -> VAR60 |= VAR11 -> VAR60 & VAR61 ? VAR62 : 0 ; VAR4 -> VAR29 = VAR11 -> VAR29 ; return 0 ; } "#1
472#472#static inline void FUN1 ( unsigned char * VAR1 , unsigned char * VAR2 , int VAR3 , int VAR4 , int VAR5 ) { int VAR6 = VAR5 ; while ( VAR6 -- ) { memcpy ( VAR1 , VAR2 , VAR5 ) ; VAR1 += VAR3 ; VAR2 += VAR4 ; } } #1
473#473#static inline unsigned int FUN1 ( unsigned int VAR1 , unsigned int VAR2 ) { return FUN2 ( VAR1 ^ ( ( VAR1 ^ VAR2 ) | ( ( VAR1 - VAR2 ) ^ VAR2 ) ) ) ; } #1
474#474#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; int VAR8 ; VAR8 = FUN2 ( VAR6 ) ; if ( VAR8 < 0 ) return VAR8 ; if ( FUN3 ( VAR4 , VAR6 -> VAR9 * VAR6 -> VAR10 * 3 ) ) { return FUN4 ( VAR11 ) ; } VAR4 -> VAR12 = 0 ; memcpy ( VAR4 -> VAR13 , VAR6 -> VAR14 , VAR6 -> VAR9 * VAR6 -> VAR10 * 3 ) ; return 0 ; } #1
475#475#"static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int * VAR4 , VAR5 * VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; VAR10 * const VAR11 = & VAR8 -> VAR12 ; int VAR13 , VAR14 , VAR15 , VAR16 , VAR17 , VAR18 = VAR6 -> VAR19 ; const VAR20 * VAR21 = VAR6 -> VAR3 ; if ( VAR18 < 32 ) return VAR22 ; VAR16 = VAR21 [ 1 ] & 7 ; VAR17 = VAR21 [ 1 ] & 0xE0 ; VAR14 = FUN2 ( & VAR21 [ 14 ] ) ; VAR15 = FUN2 ( & VAR21 [ 16 ] ) ; VAR8 -> VAR23 = VAR21 [ 19 ] ; VAR8 -> VAR24 = FUN2 ( & VAR21 [ 20 ] ) ; VAR8 -> VAR25 = VAR21 + 32 ; VAR8 -> VAR26 = VAR8 -> VAR25 + VAR8 -> VAR24 ; VAR8 -> VAR27 = VAR18 - VAR8 -> VAR24 - 32 ; if ( VAR8 -> VAR24 > 512 ) return VAR22 ; if ( VAR18 < VAR8 -> VAR24 + 32 ) return VAR22 ; if ( VAR8 -> VAR23 < 1 ) return VAR22 ; if ( VAR17 ) { FUN3 ( VAR2 , , VAR16 , VAR8 -> VAR23 ) ; return VAR28 ; } if ( VAR11 -> VAR3 [ 0 ] ) VAR2 -> FUN7 ( VAR2 , VAR11 ) ; VAR11 -> VAR34 = 0 ; if ( ( VAR13 = VAR2 -> FUN8 ( VAR2 , VAR11 ) ) < 0 ) { FUN9 ( VAR2 , VAR35 , "" "" ) ; return VAR13 ; } VAR11 -> VAR36 = VAR37 ; if ( VAR16 ) { FUN10 ( & VAR8 -> VAR38 , & VAR8 -> VAR39 , VAR15 * VAR14 + VAR40 ) ; if ( ! VAR8 -> VAR38 ) return FUN11 ( VAR41 ) ; if ( VAR8 -> VAR23 == 8 ) FUN12 ( VAR8 ) ; else FUN13 ( VAR8 ) ; } else { FUN14 ( VAR8 ) ; } * VAR4 = sizeof ( VAR10 ) ; * ( VAR10 * ) VAR3 = VAR8 -> VAR12 ; return VAR18 ; } "#0
476#476#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , int VAR5 , int VAR6 ) { int VAR7 , VAR8 , VAR9 , VAR10 , VAR11 , VAR12 , VAR13 ; int VAR14 = VAR2 -> VAR15 ; VAR16 * VAR17 = ( ( VAR16 * ) VAR2 -> VAR18 ) + VAR4 + VAR3 * VAR14 ; VAR16 * VAR19 = ( VAR16 * ) VAR2 -> VAR20 ; VAR16 * VAR21 = ( VAR16 * ) VAR2 -> VAR22 ; uint32_t VAR23 ; VAR12 = FUN2 ( & VAR2 -> VAR24 ) ; VAR9 = FUN3 ( & VAR2 -> VAR24 ) ; VAR10 = FUN4 ( & VAR2 -> VAR24 ) ; VAR11 = FUN4 ( & VAR2 -> VAR24 ) ; VAR13 = FUN4 ( & VAR2 -> VAR24 ) ; FUN5 ( & VAR2 -> VAR24 , 9 ) ; VAR23 = FUN6 ( & VAR2 -> VAR24 ) ; FUN5 ( & VAR2 -> VAR24 , 8 ) ; if ( VAR23 > VAR2 -> VAR6 * VAR14 - VAR4 - VAR3 * VAR14 ) { VAR23 = VAR2 -> VAR6 * VAR14 - VAR4 - VAR3 * VAR14 ; FUN7 ( VAR2 -> VAR25 , VAR26 , , VAR10 ) ; switch ( VAR10 ) { case 0 : if ( FUN9 ( & VAR2 -> VAR24 ) < VAR5 * VAR6 ) return VAR28 ; for ( VAR8 = 0 ; VAR8 < VAR6 ; VAR8 ++ ) { FUN10 ( & VAR2 -> VAR24 , VAR17 , VAR5 ) ; VAR17 += VAR14 ; } break ; case 1 : if ( FUN9 ( & VAR2 -> VAR24 ) < ( ( VAR5 + 1 ) >> 1 ) * ( ( VAR6 + 1 ) >> 1 ) ) return VAR28 ; for ( VAR8 = 0 ; VAR8 < VAR6 ; VAR8 += 2 ) { for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 += 2 ) { VAR17 [ VAR7 ] = VAR17 [ VAR7 + 1 ] = VAR17 [ VAR14 + VAR7 ] = VAR17 [ VAR14 + VAR7 + 1 ] = FUN11 ( & VAR2 -> VAR24 ) ; } VAR17 += VAR14 * 2 ; } break ; case 2 : if ( VAR9 == VAR2 -> VAR27 + 1 ) { for ( VAR8 = 0 ; VAR8 < VAR6 ; VAR8 += 8 ) { for ( VAR7 = 0 ; VAR7 < VAR5 ; VAR7 += 8 ) { if ( FUN12 ( VAR2 , VAR17 + VAR7 , VAR19 + VAR7 , VAR21 + VAR7 , VAR14 , VAR12 + 8 , 8 ) ) return VAR28 ; } VAR17 += VAR14 * 8 ; VAR19 += VAR14 * 8 ; VAR21 += VAR14 * 8 ; } } break ; case 3 : memcpy ( VAR2 -> VAR18 , VAR2 -> VAR22 , VAR2 -> VAR15 * VAR2 -> VAR6 ) ; break ; case 4 : memcpy ( VAR2 -> VAR18 , VAR2 -> VAR20 , VAR2 -> VAR15 * VAR2 -> VAR6 ) ; break ; case 5 : if ( FUN13 ( VAR2 , VAR17 , VAR23 ) ) return VAR28 ; break ; default : FUN7 ( VAR2 -> VAR25 , VAR29 , "" "" , VAR10 ) ; return VAR30 ; } if ( VAR9 == VAR2 -> VAR27 + 1 ) VAR2 -> VAR31 = VAR11 ; else VAR2 -> VAR31 = 0 ; VAR2 -> VAR27 = VAR9 ; return 0 ; } "#0
477#477#int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , unsigned int VAR4 ) { unsigned char * VAR5 ; unsigned short VAR6 ; unsigned int VAR7 ; unsigned int VAR8 = 16 ; if ( VAR2 -> VAR9 ) VAR2 -> FUN2 ( 0 , VAR2 -> VAR10 , VAR11 , VAR3 , VAR4 , VAR2 , VAR2 -> VAR12 ) ; if ( 1 + 2 + 16 > VAR4 ) return 0 ; if ( VAR4 > VAR13 ) return 0 ; VAR6 = * VAR3 ++ ; FUN3 ( VAR3 , VAR7 ) ; if ( 1 + 2 + VAR7 + 16 > VAR4 ) return 0 ; VAR5 = VAR3 ; if ( VAR6 == VAR14 ) { unsigned char * VAR15 , * VAR16 ; unsigned int VAR17 = 1 + 2 + VAR7 + VAR8 ; int VAR18 ; if ( VAR17 > VAR13 ) return 0 ; VAR15 = FUN4 ( VAR17 ) ; if ( VAR15 == NULL ) return -1 ; VAR16 = VAR15 ; * VAR16 ++ = VAR19 ; FUN5 ( VAR7 , VAR16 ) ; memcpy ( VAR16 , VAR5 , VAR7 ) ; VAR16 += VAR7 ; if ( FUN6 ( VAR16 , VAR8 ) <= 0 ) { FUN7 ( VAR15 ) ; return -1 ; } VAR18 = FUN8 ( VAR2 , VAR11 , VAR15 , VAR17 ) ; if ( VAR18 >= 0 && VAR2 -> VAR9 ) VAR2 -> FUN2 ( 1 , VAR2 -> VAR10 , VAR11 , VAR15 , VAR17 , VAR2 , VAR2 -> VAR12 ) ; FUN7 ( VAR15 ) ; if ( VAR18 < 0 ) return VAR18 ; } else if ( VAR6 == VAR19 ) { unsigned int VAR20 ; FUN3 ( VAR5 , VAR20 ) ; if ( VAR7 == 18 && VAR20 == VAR2 -> VAR21 ) { FUN9 ( VAR2 ) ; VAR2 -> VAR21 ++ ; VAR2 -> VAR22 = 0 ; } } return 0 ; } #1
478#478#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR6 -> VAR10 ; VAR1 * VAR11 = VAR6 -> VAR12 [ 0 ] ; unsigned VAR13 , VAR14 ; if ( ! VAR9 -> VAR15 ) { VAR11 -> VAR16 = FUN2 ( VAR11 , VAR17 , VAR11 -> VAR18 , VAR11 -> VAR19 ) ; if ( ! VAR11 -> VAR16 ) return FUN3 ( VAR20 ) ; FUN4 ( VAR11 -> VAR16 , VAR4 ) ; VAR11 -> VAR16 -> VAR21 -> VAR18 = VAR11 -> VAR18 ; VAR11 -> VAR16 -> VAR21 -> VAR19 = VAR11 -> VAR19 ; if ( VAR9 -> VAR22 || VAR9 -> VAR23 ) FUN5 ( & VAR9 -> VAR24 , & VAR9 -> VAR25 , VAR11 -> VAR16 -> VAR26 , VAR11 -> VAR16 -> VAR27 , 0 , 0 , VAR11 -> VAR18 , VAR11 -> VAR19 ) ; } FUN6 ( VAR6 , & VAR13 , & VAR14 ) ; FUN7 ( & VAR9 -> VAR24 , VAR11 -> VAR16 -> VAR26 , VAR11 -> VAR16 -> VAR27 , VAR2 -> VAR28 -> VAR26 , VAR2 -> VAR28 -> VAR27 , VAR13 , VAR14 , 0 , 0 , VAR2 -> VAR18 , VAR2 -> VAR19 ) ; FUN8 ( & VAR2 -> VAR28 ) ; if ( ++ VAR9 -> VAR15 == VAR9 -> VAR29 ) FUN9 ( VAR6 ) ; return 0 ; } #0
479#479#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , const VAR3 * VAR5 ) { unsigned char * VAR6 = VAR2 -> VAR7 . VAR8 [ 0 ] + VAR2 -> VAR9 -> VAR10 * VAR2 -> VAR7 . VAR11 [ 0 ] ; int VAR12 ; int VAR13 ; int VAR14 ; int VAR15 ; int VAR16 , VAR17 , VAR18 , VAR19 ; GetBitContext VAR20 ; int VAR21 ; const unsigned char * VAR22 ; if ( VAR4 + 12 > VAR5 ) return -1 ; VAR12 = FUN2 ( & VAR4 [ 0 ] ) ; VAR13 = FUN2 ( & VAR4 [ 2 ] ) ; VAR14 = FUN2 ( & VAR4 [ 4 ] ) ; VAR15 = FUN2 ( & VAR4 [ 6 ] ) ; VAR4 += 12 ; if ( VAR12 > VAR2 -> VAR12 ) { VAR2 -> VAR23 = FUN3 ( VAR2 -> VAR23 , VAR12 * 2 * sizeof ( int ) ) ; VAR2 -> VAR12 = VAR12 ; } if ( VAR14 > VAR2 -> VAR14 ) { VAR2 -> VAR24 = FUN3 ( VAR2 -> VAR24 , VAR14 * 16 * sizeof ( unsigned char ) ) ; VAR2 -> VAR14 = VAR14 ; } VAR21 = ( VAR12 * 2 * 10 + 31 ) & ~ 31 ; if ( VAR4 + ( VAR21 >> 3 ) + 16 * VAR13 + 8 * VAR14 > VAR5 ) return -1 ; FUN4 ( & VAR20 , VAR4 , VAR21 ) ; for ( VAR16 = 0 ; VAR16 < VAR12 ; VAR16 ++ ) { VAR2 -> VAR23 [ VAR16 ] [ 0 ] = FUN5 ( & VAR20 , 10 ) ; VAR2 -> VAR23 [ VAR16 ] [ 1 ] = FUN5 ( & VAR20 , 10 ) ; } VAR4 += VAR21 >> 3 ; VAR22 = VAR4 ; VAR4 += VAR13 * 16 ; FUN4 ( & VAR20 , VAR4 , ( VAR5 - VAR4 ) << 3 ) ; for ( VAR16 = 0 ; VAR16 < VAR14 ; VAR16 ++ ) { int VAR25 [ 4 ] ; for ( VAR17 = 0 ; VAR17 < 4 ; VAR17 ++ ) VAR25 [ VAR17 ] = FUN6 ( & VAR20 , 8 ) ; for ( VAR17 = 0 ; VAR17 < 16 ; VAR17 ++ ) VAR2 -> VAR24 [ VAR16 ] [ 15 - VAR17 ] = VAR25 [ FUN6 ( & VAR20 , 2 ) ] ; } if ( FUN7 ( & VAR20 ) < VAR15 * ( VAR2 -> VAR9 -> VAR10 / 4 ) * ( VAR2 -> VAR9 -> VAR26 / 4 ) ) return -1 ; for ( VAR19 = 0 ; VAR19 < VAR2 -> VAR9 -> VAR10 / 4 ; VAR19 ++ ) for ( VAR18 = 0 ; VAR18 < VAR2 -> VAR9 -> VAR26 / 4 ; VAR18 ++ ) { unsigned int VAR27 = FUN6 ( & VAR20 , VAR15 ) ; const unsigned char * VAR28 ; int VAR29 ; if ( VAR27 < VAR12 ) { VAR28 = VAR2 -> VAR7 . VAR8 [ 0 ] + ( VAR19 * 4 + VAR2 -> VAR23 [ VAR27 ] [ 1 ] ) * VAR2 -> VAR7 . VAR11 [ 0 ] + VAR18 * 4 + VAR2 -> VAR23 [ VAR27 ] [ 0 ] ; VAR29 = VAR2 -> VAR7 . VAR11 [ 0 ] ; if ( VAR28 < VAR2 -> VAR7 . VAR8 [ 0 ] || VAR28 + 3 * VAR29 + 3 >= VAR6 ) continue ; } else { int VAR30 = VAR27 - VAR12 ; if ( VAR30 < VAR13 ) VAR28 = VAR22 + 16 * VAR30 ; else if ( VAR30 - VAR13 < VAR14 ) VAR28 = VAR2 -> VAR24 [ VAR30 - VAR13 ] ; else continue ; VAR29 = 4 ; } for ( VAR17 = 0 ; VAR17 < 4 ; VAR17 ++ ) for ( VAR16 = 0 ; VAR16 < 4 ; VAR16 ++ ) VAR2 -> VAR31 . VAR8 [ 0 ] [ ( VAR19 * 4 + VAR17 ) * VAR2 -> VAR31 . VAR11 [ 0 ] + ( VAR18 * 4 + VAR16 ) ] = VAR28 [ VAR17 * VAR29 + VAR16 ] ; } return 0 ; } #0
480#480#enum VAR1 FUN1 ( VAR2 * VAR3 , enum WORK_STATE VAR4 ) { VAR5 * VAR6 = NULL ; VAR7 * VAR8 = NULL ; int VAR9 ; if ( VAR4 == VAR10 ) { if ( VAR3 -> VAR11 -> VAR12 ) { VAR9 = VAR3 -> VAR11 -> FUN2 ( VAR3 , VAR3 -> VAR11 -> VAR13 ) ; if ( VAR9 < 0 ) { VAR3 -> VAR14 = VAR15 ; return VAR10 ; } if ( VAR9 == 0 ) { FUN3 ( VAR3 , VAR16 , VAR17 ) ; FUN4 ( VAR3 ) ; return 0 ; } VAR3 -> VAR14 = VAR18 ; } if ( FUN5 ( VAR3 ) ) return VAR19 ; VAR4 = VAR20 ; } if ( VAR4 == VAR20 ) { VAR9 = FUN6 ( VAR3 , & VAR6 , & VAR8 ) ; if ( VAR9 < 0 ) { VAR3 -> VAR14 = VAR15 ; return VAR20 ; } VAR3 -> VAR14 = VAR18 ; if ( ( VAR9 == 1 ) && ( VAR8 != NULL ) && ( VAR6 != NULL ) ) { if ( ! FUN7 ( VAR3 , VAR6 ) || ! FUN8 ( VAR3 , VAR8 ) ) VAR9 = 0 ; } else if ( VAR9 == 1 ) { VAR9 = 0 ; FUN9 ( VAR21 , VAR22 ) ; } FUN10 ( VAR6 ) ; FUN11 ( VAR8 ) ; if ( VAR9 && ! FUN5 ( VAR3 ) ) VAR9 = 0 ; if ( VAR9 == 0 ) { if ( VAR3 -> VAR23 == VAR24 ) { VAR3 -> VAR25 -> VAR26 . VAR27 = 0 ; FUN3 ( VAR3 , VAR28 , VAR29 ) ; return VAR19 ; } else { VAR3 -> VAR25 -> VAR26 . VAR27 = 2 ; if ( ! FUN12 ( VAR3 , 0 ) ) { FUN3 ( VAR3 , VAR16 , VAR17 ) ; FUN4 ( VAR3 ) ; return 0 ; } } } return VAR19 ; } return VAR30 ; } #0
481#481#static ossl_inline unsigned int FUN1 ( unsigned int VAR1 , unsigned int VAR2 ) { return FUN2 ( VAR1 ^ ( ( VAR1 ^ VAR2 ) | ( ( VAR1 - VAR2 ) ^ VAR2 ) ) ) ; } #1
482#482#"static int FUN1 ( VAR1 * VAR2 , char * VAR3 , FUN2 ( VAR1 ) * * VAR4 ) { char VAR5 [ VAR6 ] ; int VAR7 , VAR8 ; int VAR9 = 0 , VAR10 = 0 ; VAR1 * VAR11 = NULL ; FUN2 ( VAR1 ) * VAR12 ; char VAR13 , VAR14 , VAR15 ; VAR8 = strlen ( VAR3 ) ; VAR14 = 0 ; VAR13 = 0 ; VAR15 = 1 ; VAR12 = FUN3 ( ) ; * VAR4 = VAR12 ; while ( ( VAR7 = FUN4 ( VAR2 , VAR5 , VAR6 ) ) > 0 ) { VAR13 = FUN5 ( VAR5 , VAR7 , VAR3 , VAR8 ) ; if ( VAR13 == 1 ) { VAR15 = 1 ; VAR14 ++ ; } else if ( VAR13 == 2 ) { FUN6 ( VAR12 , VAR11 ) ; return 1 ; } else if ( VAR14 ) { VAR10 = FUN7 ( VAR5 , & VAR7 ) ; if ( VAR15 ) { VAR15 = 0 ; if ( VAR11 ) FUN6 ( VAR12 , VAR11 ) ; VAR11 = FUN8 ( FUN9 ( ) ) ; } else if ( VAR9 ) FUN10 ( VAR11 , "" "" , 2 ) ; VAR9 = VAR10 ; if ( VAR7 ) FUN10 ( VAR11 , VAR5 , VAR7 ) ; } } return 0 ; } "#0
483#483#VAR1 FUN1 ( VAR2 * VAR3 , size_t VAR4 ) { char * VAR5 ; size_t VAR6 ; if ( VAR3 -> VAR7 >= VAR4 ) { memset ( & VAR3 -> VAR8 [ VAR4 ] , 0 , VAR3 -> VAR7 - VAR4 ) ; VAR3 -> VAR7 = VAR4 ; return ( VAR4 ) ; } if ( VAR3 -> VAR9 >= VAR4 ) { memset ( & VAR3 -> VAR8 [ VAR3 -> VAR7 ] , 0 , VAR4 - VAR3 -> VAR7 ) ; VAR3 -> VAR7 = VAR4 ; return ( VAR4 ) ; } if ( VAR4 > VAR10 ) { FUN2 ( VAR11 , VAR12 ) ; return 0 ; } VAR6 = ( VAR4 + 3 ) / 3 * 4 ; if ( VAR3 -> VAR8 == NULL ) VAR5 = FUN3 ( VAR6 ) ; else VAR5 = FUN4 ( VAR3 -> VAR8 , VAR3 -> VAR9 , VAR6 ) ; if ( VAR5 == NULL ) { FUN2 ( VAR11 , VAR12 ) ; VAR4 = 0 ; } else { VAR3 -> VAR8 = VAR5 ; VAR3 -> VAR9 = VAR6 ; memset ( & VAR3 -> VAR8 [ VAR3 -> VAR7 ] , 0 , VAR4 - VAR3 -> VAR7 ) ; VAR3 -> VAR7 = VAR4 ; } return ( VAR4 ) ; } #1
484#484#int FUN1 ( VAR1 * VAR2 [ 4 ] , int VAR3 [ 4 ] , const VAR1 * VAR4 , enum AVPixelFormat VAR5 , int VAR6 , int VAR7 , int VAR8 ) { int VAR9 , VAR10 ; if ( ( VAR9 = FUN2 ( VAR6 , VAR7 , 0 , NULL ) ) < 0 ) return VAR9 ; if ( ( VAR9 = FUN3 ( VAR3 , VAR5 , VAR6 ) ) < 0 ) return VAR9 ; for ( VAR10 = 0 ; VAR10 < 4 ; VAR10 ++ ) VAR3 [ VAR10 ] = FUN4 ( VAR3 [ VAR10 ] , VAR8 ) ; return FUN5 ( VAR2 , VAR5 , VAR7 , ( VAR1 * ) VAR4 , VAR3 ) ; } #0
485#485#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , VAR7 * VAR8 , VAR9 * VAR10 , const VAR11 * VAR12 , int VAR13 , uint16_t VAR14 , int VAR15 ) { int VAR16 , VAR17 , VAR18 , VAR19 , VAR20 ; if ( ! VAR12 ) { if ( ! VAR4 -> VAR21 || VAR4 -> VAR22 + 2 > VAR4 -> VAR23 || VAR4 -> VAR24 <= 0 ) { FUN2 ( VAR2 , VAR25 , ) ; return VAR26 ; } if ( FUN4 ( VAR8 , VAR20 ) ) { FUN2 ( VAR2 , VAR25 , , VAR13 ) ; return VAR26 ; } VAR16 = FUN6 ( VAR12 ) ; VAR17 = VAR12 [ 3 ] >> 6 ; VAR18 = ( VAR12 [ 3 ] >> 4 ) & 3 ; VAR19 = VAR12 [ 3 ] & 0xf ; VAR20 = FUN3 ( VAR12 + 4 ) ; if ( VAR20 > VAR13 - 6 ) { FUN2 ( VAR2 , VAR25 , ) ; return VAR31 ; } if ( VAR18 ) { FUN2 ( VAR2 , VAR25 , ) ; return FUN5 ( VAR27 ) ; } VAR8 -> VAR28 = VAR6 -> VAR29 ; memcpy ( VAR8 -> VAR4 , VAR12 , VAR20 ) ; VAR12 += VAR20 ; VAR13 -= VAR20 ; VAR19 -- ; if ( VAR19 > 0 ) { if ( VAR13 > VAR4 -> VAR32 || ! VAR4 -> VAR21 ) { FUN7 ( & VAR4 -> VAR21 ) ; VAR4 -> VAR32 = 2 * VAR13 ; VAR4 -> VAR21 = FUN8 ( VAR4 -> VAR32 ) ; if ( ! VAR4 -> VAR21 ) { FUN2 ( VAR2 , VAR25 , ) ; return VAR26 ; } if ( ! VAR4 -> VAR34 ) { FUN2 ( VAR2 , VAR35 , ) ; return VAR37 ; } return 0 ; } } return FUN5 ( VAR36 ) ; } #0
486#486#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int * VAR5 ) { int VAR6 , VAR7 , VAR8 , VAR9 ; int VAR10 = 0 ; int VAR11 = FUN2 ( VAR2 -> VAR11 , VAR12 ) ; int VAR13 = FUN2 ( VAR2 -> VAR13 , VAR14 ) ; VAR15 * VAR16 = VAR4 -> VAR17 [ 0 ] ; for ( VAR7 = 0 ; VAR7 < VAR12 ; VAR7 += 8 ) { for ( VAR6 = 0 ; VAR6 < VAR14 ; VAR6 += 8 ) { for ( VAR9 = VAR7 ; VAR9 < VAR7 + 8 && VAR9 < VAR12 ; VAR9 ++ ) { for ( VAR8 = VAR6 ; VAR8 < VAR6 + 8 && VAR8 < VAR14 ; VAR8 += 2 ) { if ( VAR8 < VAR13 && VAR9 < VAR11 ) { VAR10 = ( VAR16 [ ( VAR8 + 0 + VAR9 * VAR4 -> VAR18 [ 0 ] ) ] + VAR16 [ ( VAR8 + 1 + VAR9 * VAR4 -> VAR18 [ 0 ] ) ] ) / 2 ; VAR5 [ 0 ] = VAR10 ; } VAR5 ++ ; } } } } } #1
487#487#int FUN1 ( VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int64_t VAR5 , const char * VAR6 ) { VAR7 * VAR8 = NULL ; int VAR9 ; for ( VAR9 = 0 ; VAR9 < VAR2 -> VAR10 ; VAR9 ++ ) if ( VAR2 -> VAR11 [ VAR9 ] -> VAR3 == VAR3 ) VAR8 = VAR2 -> VAR11 [ VAR9 ] ; if ( ! VAR8 ) { VAR8 = FUN2 ( sizeof ( VAR7 ) ) ; if ( ! VAR8 ) return FUN3 ( VAR12 ) ; FUN4 ( & VAR2 -> VAR11 , & VAR2 -> VAR10 , VAR8 ) ; } if ( VAR8 -> VAR6 ) FUN5 ( VAR8 -> VAR6 ) ; VAR8 -> VAR6 = FUN6 ( VAR6 ) ; VAR8 -> VAR3 = VAR3 ; VAR8 -> VAR4 = VAR4 ; VAR8 -> VAR5 = VAR5 ; return 0 ; } #0
488#488#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 ) { int VAR6 , VAR7 , VAR8 ; int VAR9 = 0 ; int64_t VAR10 = 0 ; for ( VAR8 = 0 ; VAR8 < 3 ; VAR8 ++ ) { const int VAR11 = VAR4 -> VAR12 -> VAR13 [ VAR8 ] ; const int VAR14 = VAR8 ? 1 : 2 ; for ( VAR7 = 0 ; VAR7 < VAR2 -> VAR15 * VAR14 ; VAR7 ++ ) { for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR16 * VAR14 ; VAR6 ++ ) { int VAR17 = VAR4 -> VAR18 ? 0 : 16 ; VAR19 * VAR20 = VAR4 -> VAR12 -> VAR21 [ VAR8 ] + 8 * ( VAR6 + VAR7 * VAR11 ) + VAR17 ; VAR19 * VAR22 = VAR5 -> VAR12 -> VAR21 [ VAR8 ] + 8 * ( VAR6 + VAR7 * VAR11 ) ; int VAR23 = VAR2 -> VAR24 . VAR25 [ 1 ] ( VAR2 , VAR20 , VAR22 , VAR11 , 8 ) ; switch ( VAR2 -> VAR26 -> VAR27 ) { case 0 : VAR9 = FUN2 ( VAR9 , VAR23 ) ; break ; case 1 : VAR9 += FUN3 ( VAR23 ) ; break ; case 2 : VAR9 += VAR23 * VAR23 ; break ; case 3 : VAR10 += FUN3 ( VAR23 * VAR23 * ( VAR28 ) VAR23 ) ; break ; case 4 : VAR10 += VAR23 * VAR23 * ( VAR28 ) ( VAR23 * VAR23 ) ; break ; } } } } if ( VAR9 ) VAR10 = VAR9 ; if ( VAR10 < VAR2 -> VAR26 -> VAR29 ) return 1 ; if ( VAR10 < ( ( VAR2 -> VAR26 -> VAR30 * ( VAR28 ) VAR2 -> VAR31 ) >> 8 ) ) return 1 ; return 0 ; } #0
489#489#static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { VAR6 * VAR7 ; FUN2 ( & VAR3 -> VAR8 -> mutex ) ; VAR7 = FUN3 ( VAR3 , VAR5 -> VAR9 ) ; if ( VAR7 == NULL ) { VAR7 = FUN4 ( VAR3 -> VAR8 , sizeof ( VAR6 ) ) ; if ( VAR7 == NULL ) { FUN5 ( & VAR3 -> VAR8 -> mutex ) ; return VAR10 ; } FUN6 ( ( VAR11 * ) & VAR7 -> VAR12 . VAR9 , VAR5 -> VAR9 , sizeof ( VAR13 ) ) ; FUN6 ( VAR7 -> VAR9 , & VAR5 -> VAR9 [ sizeof ( VAR13 ) ] , VAR14 - sizeof ( VAR13 ) ) ; FUN7 ( & VAR3 -> VAR15 -> VAR16 , & VAR7 -> VAR12 ) ; VAR7 -> VAR17 = 1 ; VAR7 -> VAR18 = 1 ; VAR7 -> VAR19 = VAR5 -> VAR19 ; VAR3 -> VAR15 -> VAR20 += VAR5 -> VAR19 ; } else { FUN8 ( & VAR7 -> VAR21 ) ; } VAR7 -> VAR22 = FUN9 ( ) + VAR3 -> VAR23 ; FUN10 ( & VAR3 -> VAR15 -> VAR21 , & VAR7 -> VAR21 ) ; FUN5 ( & VAR3 -> VAR8 -> mutex ) ; return VAR24 ; } #0
490#490#"int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; int VAR4 = ( VAR5 && VAR2 -> VAR6 -> VAR7 & VAR8 ) ? VAR2 -> VAR6 -> VAR9 : 1 ; if ( VAR2 -> VAR10 && VAR2 -> VAR6 -> VAR11 ) VAR4 = VAR2 -> VAR6 -> VAR11 ; if ( VAR2 -> VAR12 == VAR13 && ! VAR2 -> VAR14 ) VAR2 -> VAR15 = ( VAR2 -> VAR16 + 31 ) / 32 * 2 ; else VAR2 -> VAR15 = ( VAR2 -> VAR16 + 15 ) / 16 ; if ( VAR2 -> VAR6 -> VAR17 == VAR18 ) { FUN2 ( VAR2 -> VAR6 , VAR19 , "" "" , VAR4 , VAR21 ) ; VAR4 = VAR21 ; } if ( ( VAR2 -> VAR23 || VAR2 -> VAR16 ) && FUN4 ( VAR2 -> VAR23 , VAR2 -> VAR16 , 0 , VAR2 -> VAR6 ) ) return -1 ; FUN5 ( VAR2 ) ; VAR2 -> VAR24 = VAR2 -> VAR6 -> VAR24 ; VAR2 -> VAR25 = VAR2 -> VAR6 -> VAR25 ; FUN6 ( VAR2 -> VAR6 -> VAR17 , & VAR2 -> VAR26 , & VAR2 -> VAR27 ) ; VAR2 -> VAR28 = FUN7 ( VAR2 -> VAR6 -> VAR28 ) ; VAR2 -> VAR29 = FUN7 ( VAR2 -> VAR6 -> VAR29 ) ; VAR2 -> VAR6 -> VAR30 = & VAR2 -> VAR31 . VAR32 ; if ( VAR2 -> VAR10 ) { if ( VAR2 -> VAR33 ) { FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR34 , 2 * 2 * ( VAR35 + 1 ) * ( VAR36 + 1 ) * 2 * sizeof ( int ) , VAR37 ) ; } FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR6 -> VAR38 , 256 , VAR37 ) ; FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR39 , 64 * 32 * sizeof ( int ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR40 , 64 * 32 * sizeof ( int ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR41 , 64 * 32 * sizeof ( int ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR42 , 64 * 32 * 2 * sizeof ( VAR43 ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR44 , 64 * 32 * 2 * sizeof ( VAR43 ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR45 , 64 * 32 * 2 * sizeof ( VAR43 ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR46 , VAR47 * sizeof ( VAR48 * ) , VAR37 ) FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR49 , VAR47 * sizeof ( VAR48 * ) , VAR37 ) if ( VAR2 -> VAR6 -> VAR50 ) { FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR51 , 2 * 64 * sizeof ( VAR43 ) , VAR37 ) ; } } FUN8 ( VAR2 -> VAR6 , VAR2 -> VAR52 , VAR47 * sizeof ( VAR48 ) , VAR37 ) ; for ( VAR3 = 0 ; VAR3 < VAR47 ; VAR3 ++ ) { FUN9 ( & VAR2 -> VAR52 [ VAR3 ] . VAR32 ) ; } memset ( & VAR2 -> VAR53 , 0 , sizeof ( VAR2 -> VAR53 ) ) ; memset ( & VAR2 -> VAR54 , 0 , sizeof ( VAR2 -> VAR54 ) ) ; memset ( & VAR2 -> VAR31 , 0 , sizeof ( VAR2 -> VAR31 ) ) ; FUN9 ( & VAR2 -> VAR53 . VAR32 ) ; FUN9 ( & VAR2 -> VAR54 . VAR32 ) ; FUN9 ( & VAR2 -> VAR31 . VAR32 ) ; if ( FUN10 ( VAR2 ) ) goto VAR37 ; VAR2 -> VAR55 . VAR56 = -1 ; VAR2 -> VAR57 = 1 ; VAR2 -> VAR58 [ 0 ] = VAR2 ; if ( VAR4 > 1 ) { for ( VAR3 = 1 ; VAR3 < VAR4 ; VAR3 ++ ) { VAR2 -> VAR58 [ VAR3 ] = FUN11 ( sizeof ( VAR1 ) ) ; memcpy ( VAR2 -> VAR58 [ VAR3 ] , VAR2 , sizeof ( VAR1 ) ) ; } for ( VAR3 = 0 ; VAR3 < VAR4 ; VAR3 ++ ) { if ( FUN12 ( VAR2 -> VAR58 [ VAR3 ] ) < 0 ) goto VAR37 ; VAR2 -> VAR58 [ VAR3 ] -> VAR59 = ( VAR2 -> VAR15 * ( VAR3 ) + VAR4 / 2 ) / VAR4 ; VAR2 -> VAR58 [ VAR3 ] -> VAR60 = ( VAR2 -> VAR15 * ( VAR3 + 1 ) + VAR4 / 2 ) / VAR4 ; } } else { if ( FUN12 ( VAR2 ) < 0 ) goto VAR37 ; VAR2 -> VAR59 = 0 ; VAR2 -> VAR60 = VAR2 -> VAR15 ; } VAR2 -> VAR61 = VAR4 ; return 0 ; VAR37 : FUN13 ( VAR2 ) ; return -1 ; } "#1
491#491#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , int VAR6 ) { VAR3 * VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 ; VAR11 * VAR12 = VAR2 -> VAR12 ; VAR13 * VAR14 = VAR9 -> VAR15 ; int VAR16 ; VAR7 = FUN2 ( VAR5 * sizeof ( VAR3 ) ) ; if ( ! VAR7 ) return FUN3 ( VAR17 ) ; FUN4 ( VAR2 , VAR14 , VAR5 , ! ! ( VAR6 & VAR18 ) ) ; if ( VAR14 -> VAR19 -> VAR20 == VAR21 ) { for ( VAR16 = 0 ; VAR16 < VAR5 ; VAR16 += 2 ) { VAR7 [ VAR16 ] = VAR4 [ VAR16 + 1 ] ; VAR7 [ VAR16 + 1 ] = VAR4 [ VAR16 ] ; } FUN5 ( VAR12 , VAR7 , VAR5 ) ; } else { FUN5 ( VAR12 , VAR4 , VAR5 ) ; } VAR14 -> VAR22 ++ ; FUN6 ( VAR7 ) ; return 0 ; } #0
492#492#VAR1 FUN1 ( VAR2 * VAR3 , size_t VAR4 ) { ssize_t VAR5 ; if ( VAR4 == 0 ) { return VAR6 ; } for ( VAR5 = 0 ; VAR4 -- ; VAR3 ++ ) { if ( * VAR3 < ' ' || * VAR3 > ' ' ) { return VAR6 ; } VAR5 = VAR5 * 10 + ( * VAR3 - ' ' ) ; } if ( VAR5 < 0 ) { return VAR6 ; } else { return VAR5 ; } } #1
493#493#int FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 ) { int VAR5 ; long ( * VAR6 ) ( VAR1 * , int , const char * , int , long , long ) ; if ( ( VAR2 == NULL ) || ( VAR2 -> VAR7 == NULL ) || ( VAR2 -> VAR7 -> VAR8 == NULL ) ) { FUN2 ( VAR9 , VAR10 ) ; return ( -2 ) ; } VAR6 = VAR2 -> VAR11 ; if ( ( VAR6 != NULL ) && ( ( VAR5 = ( int ) FUN3 ( VAR2 , VAR12 , VAR3 , VAR4 , 0L , 1L ) ) <= 0 ) ) return ( VAR5 ) ; if ( ! VAR2 -> VAR13 ) { FUN2 ( VAR9 , VAR14 ) ; return ( -2 ) ; } VAR5 = VAR2 -> VAR7 -> FUN4 ( VAR2 , VAR3 , VAR4 ) ; if ( VAR5 > 0 ) VAR2 -> VAR15 += ( unsigned long ) VAR5 ; if ( VAR6 != NULL ) VAR5 = ( int ) FUN3 ( VAR2 , VAR12 | VAR16 , VAR3 , VAR4 , 0L , ( long ) VAR5 ) ; return ( VAR5 ) ; } #1
494#494#int FUN1 ( VAR1 * VAR2 ) { unsigned char * VAR3 , * VAR4 ; int VAR5 , VAR6 , VAR7 , VAR8 , VAR9 ; FUN2 ( VAR10 ) * VAR11 = NULL ; VAR10 * VAR12 ; VAR13 * VAR14 ; VAR14 = VAR2 -> VAR15 ; VAR4 = VAR3 = FUN3 ( VAR2 ) ; VAR3 ++ ; VAR9 = FUN4 ( VAR2 , VAR3 ) ; VAR4 [ 0 ] = VAR9 ; VAR3 += VAR9 ; VAR9 ++ ; if ( FUN5 ( VAR2 ) ) { const unsigned char * VAR16 ; unsigned char * VAR17 = VAR3 ; VAR7 = FUN6 ( VAR2 , & VAR16 ) ; VAR3 += 2 ; VAR7 = FUN7 ( VAR2 , VAR3 , VAR16 , VAR7 ) ; FUN8 ( VAR7 , VAR17 ) ; VAR3 += VAR7 ; VAR9 += VAR7 + 2 ; } VAR8 = VAR9 ; VAR3 += 2 ; VAR9 += 2 ; VAR11 = FUN9 ( VAR2 ) ; VAR7 = 0 ; if ( VAR11 != NULL ) { for ( VAR5 = 0 ; VAR5 < FUN10 ( VAR11 ) ; VAR5 ++ ) { VAR12 = FUN11 ( VAR11 , VAR5 ) ; VAR6 = FUN12 ( VAR12 , NULL ) ; if ( ! FUN13 ( VAR14 , FUN14 ( VAR2 ) + VAR9 + VAR6 + 2 ) ) { FUN15 ( VAR18 , VAR19 ) ; goto VAR20 ; } VAR3 = FUN3 ( VAR2 ) + VAR9 ; FUN8 ( VAR6 , VAR3 ) ; FUN12 ( VAR12 , & VAR3 ) ; VAR9 += 2 + VAR6 ; VAR7 += 2 + VAR6 ; } } VAR3 = FUN3 ( VAR2 ) + VAR8 ; FUN8 ( VAR7 , VAR3 ) ; if ( ! FUN16 ( VAR2 , VAR21 , VAR9 ) ) { FUN15 ( VAR18 , VAR22 ) ; goto VAR20 ; } VAR2 -> VAR23 -> VAR24 . VAR25 = 1 ; return 1 ; VAR20 : FUN17 ( VAR2 ) ; return 0 ; } #1
495#495#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 -> VAR6 ; VAR7 * VAR8 = VAR2 -> VAR9 ; VAR7 * VAR10 = VAR2 -> VAR5 -> VAR11 [ 0 ] -> VAR12 ; VAR1 * VAR13 = VAR2 -> VAR5 -> VAR11 [ 0 ] ; int VAR14 ; for ( VAR14 = 0 ; VAR10 -> VAR15 [ VAR14 ] ; VAR14 ++ ) { int VAR16 = VAR14 == 1 || VAR14 == 2 ? VAR4 -> VAR16 : 0 ; int VAR17 = VAR14 == 1 || VAR14 == 2 ? VAR4 -> VAR17 : 0 ; int VAR18 = VAR4 -> VAR19 [ VAR14 ] ; int VAR20 = VAR8 -> VAR21 -> VAR22 >> VAR17 ; int VAR23 = VAR10 -> VAR21 -> VAR24 >> VAR16 ; int VAR25 = VAR10 -> VAR21 -> VAR22 >> VAR17 ; VAR26 * VAR27 , * VAR28 ; int VAR29 , VAR30 ; int VAR31 , VAR32 ; VAR27 = VAR10 -> VAR15 [ VAR14 ] ; VAR29 = VAR10 -> VAR33 [ VAR14 ] ; VAR28 = VAR8 -> VAR15 [ VAR14 ] ; VAR30 = VAR8 -> VAR33 [ VAR14 ] ; if ( VAR4 -> VAR34 & 1 ) { VAR28 += VAR8 -> VAR33 [ VAR14 ] * ( VAR20 - 1 ) ; VAR30 *= -1 ; } if ( VAR4 -> VAR34 & 2 ) { VAR27 += VAR10 -> VAR33 [ VAR14 ] * ( VAR25 - 1 ) ; VAR29 *= -1 ; } for ( VAR32 = 0 ; VAR32 < VAR25 ; VAR32 ++ ) { switch ( VAR18 ) { case 1 : for ( VAR31 = 0 ; VAR31 < VAR23 ; VAR31 ++ ) VAR27 [ VAR31 ] = VAR28 [ VAR31 * VAR30 + VAR32 ] ; break ; case 2 : for ( VAR31 = 0 ; VAR31 < VAR23 ; VAR31 ++ ) * ( ( VAR35 * ) ( VAR27 + 2 * VAR31 ) ) = * ( ( VAR35 * ) ( VAR28 + VAR31 * VAR30 + VAR32 * 2 ) ) ; break ; case 3 : for ( VAR31 = 0 ; VAR31 < VAR23 ; VAR31 ++ ) { int32_t VAR36 = FUN2 ( VAR28 + VAR31 * VAR30 + VAR32 * 3 ) ; FUN3 ( VAR27 + 3 * VAR31 , VAR36 ) ; } break ; case 4 : for ( VAR31 = 0 ; VAR31 < VAR23 ; VAR31 ++ ) * ( ( VAR37 * ) ( VAR27 + 4 * VAR31 ) ) = * ( ( VAR37 * ) ( VAR28 + VAR31 * VAR30 + VAR32 * 4 ) ) ; break ; } VAR27 += VAR29 ; } } FUN4 ( VAR13 , 0 , VAR10 -> VAR21 -> VAR22 , 1 ) ; FUN5 ( VAR13 ) ; FUN6 ( VAR10 ) ; } #0
496#496#int FUN1 ( const VAR1 * VAR2 ) { int VAR3 = 0 ; VAR4 * VAR5 = NULL ; const VAR6 * VAR7 = NULL ; VAR8 * VAR9 = NULL ; if ( VAR2 == NULL || VAR2 -> VAR10 == NULL || VAR2 -> VAR11 == NULL ) { FUN2 ( VAR12 , VAR13 ) ; return 0 ; } if ( FUN3 ( VAR2 -> VAR10 , VAR2 -> VAR11 ) ) { FUN2 ( VAR12 , VAR14 ) ; goto VAR15 ; } if ( ( VAR5 = FUN4 ( ) ) == NULL ) goto VAR15 ; if ( ( VAR9 = FUN5 ( VAR2 -> VAR10 ) ) == NULL ) goto VAR15 ; if ( FUN6 ( VAR2 -> VAR10 , VAR2 -> VAR11 , VAR5 ) <= 0 ) { FUN2 ( VAR12 , VAR16 ) ; goto VAR15 ; } VAR7 = VAR2 -> VAR10 -> VAR7 ; if ( FUN7 ( VAR7 ) ) { FUN2 ( VAR12 , VAR17 ) ; goto VAR15 ; } if ( ! FUN8 ( VAR2 -> VAR10 , VAR9 , NULL , VAR2 -> VAR11 , VAR7 , VAR5 ) ) { FUN2 ( VAR12 , VAR18 ) ; goto VAR15 ; } if ( ! FUN3 ( VAR2 -> VAR10 , VAR9 ) ) { FUN2 ( VAR12 , VAR19 ) ; goto VAR15 ; } if ( VAR2 -> VAR20 != NULL ) { if ( FUN9 ( VAR2 -> VAR20 , VAR7 ) >= 0 ) { FUN2 ( VAR12 , VAR19 ) ; goto VAR15 ; } if ( ! FUN8 ( VAR2 -> VAR10 , VAR9 , VAR2 -> VAR20 , NULL , NULL , VAR5 ) ) { FUN2 ( VAR12 , VAR18 ) ; goto VAR15 ; } if ( FUN10 ( VAR2 -> VAR10 , VAR9 , VAR2 -> VAR11 , VAR5 ) != 0 ) { FUN2 ( VAR12 , VAR21 ) ; goto VAR15 ; } } VAR3 = 1 ; VAR15 : FUN11 ( VAR5 ) ; FUN12 ( VAR9 ) ; return VAR3 ; } #1
497#497#VAR1 FUN1 ( VAR2 * VAR3 , int64_t VAR4 , int VAR5 ) { int64_t VAR6 ; int64_t VAR7 ; int VAR8 = VAR5 & VAR9 ; VAR5 &= ~ VAR9 ; if ( ! VAR3 ) return FUN2 ( VAR10 ) ; VAR7 = VAR3 -> VAR7 - ( VAR3 -> VAR11 ? 0 : ( VAR3 -> VAR12 - VAR3 -> VAR13 ) ) ; if ( VAR5 != VAR14 && VAR5 != VAR15 ) return FUN2 ( VAR10 ) ; if ( VAR5 == VAR14 ) { VAR6 = VAR7 + ( VAR3 -> VAR16 - VAR3 -> VAR13 ) ; if ( VAR4 == 0 ) return VAR6 ; VAR4 += VAR6 ; } VAR6 = VAR4 - VAR7 ; if ( ! VAR3 -> VAR17 && VAR6 >= 0 && VAR6 < ( VAR3 -> VAR12 - VAR3 -> VAR13 ) ) { VAR3 -> VAR16 = VAR3 -> VAR13 + VAR6 ; } else if ( ( ! ( VAR3 -> VAR18 & VAR19 ) || VAR6 <= VAR3 -> VAR12 + VAR20 - VAR3 -> VAR13 ) && ! VAR3 -> VAR11 && VAR6 >= 0 && ( VAR5 != VAR21 || VAR8 ) ) { while ( VAR3 -> VAR7 < VAR4 && ! VAR3 -> VAR22 ) FUN3 ( VAR3 ) ; if ( VAR3 -> VAR22 ) return VAR23 ; VAR3 -> VAR16 = VAR3 -> VAR12 + VAR4 - VAR3 -> VAR7 ; } else { int64_t VAR24 ; if ( VAR3 -> VAR11 ) { FUN4 ( VAR3 ) ; VAR3 -> VAR17 = 1 ; } if ( ! VAR3 -> VAR25 ) return FUN2 ( VAR26 ) ; if ( ( VAR24 = VAR3 -> FUN5 ( VAR3 -> VAR27 , VAR4 , VAR15 ) ) < 0 ) return VAR24 ; if ( ! VAR3 -> VAR11 ) VAR3 -> VAR12 = VAR3 -> VAR13 ; VAR3 -> VAR16 = VAR3 -> VAR13 ; VAR3 -> VAR7 = VAR4 ; } VAR3 -> VAR22 = 0 ; return VAR4 ; } #0
498#498#int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , VAR5 * VAR6 , int * VAR7 ) { PACKET VAR8 = * VAR2 ; size_t VAR9 = 0 , VAR10 = 0 ; VAR3 * VAR11 = NULL ; while ( FUN2 ( & VAR8 ) > 0 ) { unsigned int VAR12 ; PACKET VAR13 ; if ( ! FUN3 ( & VAR8 , & VAR12 ) || ! FUN4 ( & VAR8 , & VAR13 ) ) { * VAR7 = VAR14 ; goto VAR15 ; } VAR9 ++ ; } if ( VAR9 > 0 ) { VAR11 = FUN5 ( sizeof ( * VAR11 ) * VAR9 ) ; if ( VAR11 == NULL ) { * VAR7 = VAR16 ; FUN6 ( VAR17 , VAR18 ) ; goto VAR15 ; } for ( VAR10 = 0 ; VAR10 < VAR9 ; VAR10 ++ ) { if ( ! FUN3 ( VAR2 , & VAR11 [ VAR10 ] . VAR12 ) || ! FUN4 ( VAR2 , & VAR11 [ VAR10 ] . VAR19 ) ) { * VAR7 = VAR16 ; FUN6 ( VAR17 , VAR20 ) ; goto VAR15 ; } } if ( FUN2 ( VAR2 ) != 0 ) { * VAR7 = VAR14 ; FUN6 ( VAR17 , VAR21 ) ; goto VAR15 ; } FUN7 ( VAR11 , VAR9 , sizeof ( * VAR11 ) , VAR22 ) ; for ( VAR10 = 1 ; VAR10 < VAR9 ; VAR10 ++ ) { if ( VAR11 [ VAR10 - 1 ] . VAR12 == VAR11 [ VAR10 ] . VAR12 ) { * VAR7 = VAR14 ; goto VAR15 ; } } } * VAR4 = VAR11 ; * VAR6 = VAR9 ; return 1 ; VAR15 : FUN8 ( VAR11 ) ; return 0 ; } #0
499#499#int FUN1 ( VAR1 * VAR2 , int VAR3 , void * VAR4 ) { int VAR5 ; if ( VAR2 -> VAR6 == NULL ) { if ( ( VAR2 -> VAR6 = FUN2 ( ) ) == NULL ) { FUN3 ( VAR7 , VAR8 ) ; return 0 ; } } for ( VAR5 = FUN4 ( VAR2 -> VAR6 ) ; VAR5 <= VAR3 ; ++ VAR5 ) { if ( ! FUN5 ( VAR2 -> VAR6 , NULL ) ) { FUN3 ( VAR7 , VAR8 ) ; return 0 ; } } FUN6 ( VAR2 -> VAR6 , VAR3 , VAR4 ) ; return 1 ; } #1
500#500#"int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 ; FUN2 ( ( unsigned ) VAR2 -> VAR5 <= VAR6 - VAR7 ) ; if ( ! VAR2 -> VAR5 ) return FUN3 ( VAR2 , VAR3 ) ; if ( ( unsigned ) VAR3 > VAR6 - ( VAR2 -> VAR5 + VAR7 ) ) return -1 ; VAR4 = VAR2 -> VAR5 + VAR3 + VAR7 ; if ( VAR2 -> VAR8 ) { int VAR9 = FUN4 ( & VAR2 -> VAR8 , VAR4 ) ; if ( VAR9 < 0 ) return VAR9 ; } else { VAR2 -> VAR8 = FUN5 ( VAR4 ) ; if ( ! VAR2 -> VAR8 ) return FUN6 ( VAR10 ) ; memcpy ( VAR2 -> VAR8 -> VAR11 , VAR2 -> VAR11 , FUN7 ( VAR2 -> VAR5 , VAR2 -> VAR5 + VAR3 ) ) ; #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS VAR2 - > VAR12 = VAR13 ; VAR14 #endif } VAR2 - > VAR11 = VAR2 - > VAR8 - > VAR11 ; VAR2 - > VAR5 + = VAR3 ; memset ( VAR2 - > VAR11 + VAR2 - > VAR5 , 0 , VAR7 ) ; return 0 ; } "#1
501#501#static int FUN1 ( int VAR1 , const char * VAR2 , const char * VAR3 , VAR4 * VAR5 , VAR6 * VAR7 ) { char * VAR8 ; int VAR9 ; VAR10 * VAR11 ; if ( VAR1 >= VAR12 / sizeof ( VAR10 ) || VAR1 <= 0 ) return VAR13 ; if ( FUN2 ( & VAR5 -> VAR14 ) < VAR1 * sizeof ( VAR10 ) ) return VAR13 ; VAR11 = FUN3 ( VAR1 * sizeof ( VAR10 ) ) ; if ( ! VAR11 ) return FUN4 ( VAR15 ) ; for ( VAR9 = 0 ; VAR9 < VAR1 ; VAR9 ++ ) VAR11 [ VAR9 ] = FUN5 ( & VAR5 -> VAR14 , VAR5 -> VAR16 ) ; VAR8 = FUN6 ( VAR11 , VAR1 , VAR3 ) ; FUN7 ( & VAR11 ) ; if ( ! VAR8 ) return FUN4 ( VAR15 ) ; FUN8 ( FUN9 ( VAR7 ) , VAR2 , VAR8 , VAR17 ) ; return 0 ; } #0
502#502#"static VAR1 * FUN1 ( char * VAR2 ) { size_t VAR3 = strlen ( VAR2 ) + 1 ; char * VAR4 = malloc ( VAR3 ) ; size_t VAR5 = VAR3 / 2 + 1 ; char * * VAR6 = malloc ( VAR5 * sizeof ( char * ) ) ; char * * VAR7 = malloc ( VAR5 * sizeof ( char * ) ) ; char * VAR8 = VAR2 , * VAR9 = VAR4 ; int VAR10 , VAR11 = 0 ; VAR1 * VAR12 = NULL ; int VAR13 ; if ( ! VAR4 || ! VAR6 || ! VAR7 ) { FUN2 ( VAR14 , ) ; goto VAR15 ; } VAR8 ++ ; while ( * VAR8 ) { VAR6 [ VAR11 ] = VAR9 ; while ( * VAR8 ) { if ( * VAR8 == ' ' ) if ( * ++ VAR8 ) * VAR9 ++ = * VAR8 ++ ; else { FUN2 ( VAR14 , , VAR11 ) ; goto VAR15 ; } VAR7 [ VAR11 ] = VAR9 ; while ( * VAR8 ) { if ( * VAR8 == ' ' ) if ( * ++ VAR8 ) * VAR9 ++ = * VAR8 ++ ; else { FUN2 ( VAR14 , , VAR6 [ VAR10 ] ) ; continue ; } if ( ! * VAR7 [ VAR10 ] ) { FUN2 ( VAR14 , "" "" , VAR6 [ VAR10 ] ) ; continue ; } if ( ! FUN5 ( VAR12 , VAR13 , VAR17 , ( unsigned char * ) VAR7 [ VAR10 ] , -1 , -1 , 0 ) ) goto VAR18 ; } free ( VAR7 ) ; free ( VAR6 ) ; free ( VAR4 ) ; return VAR12 ; VAR18 : FUN6 ( VAR12 ) ; VAR15 : free ( VAR7 ) ; free ( VAR6 ) ; free ( VAR4 ) ; return NULL ; } "#0
503#503#static inline int FUN1 ( int VAR1 , int VAR2 , int VAR3 ) { int VAR4 = ( ( ( ( VAR3 * VAR1 ) >> ( 24 - VAR2 ) ) + 1 ) >> 1 ) + ( VAR3 >> 1 ) ; FUN2 ( VAR4 >= 0 && VAR4 < VAR3 ) ; return VAR4 ; } #1
504#504#static void FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 , VAR5 , VAR6 , VAR7 , VAR8 ; int VAR9 , VAR10 , VAR11 ; for ( VAR8 = 0 ; VAR8 < VAR3 ; VAR8 ++ ) { VAR12 * VAR13 = & VAR2 -> VAR8 [ VAR8 ] . VAR13 ; VAR9 = 0 ; VAR10 = 0 ; VAR2 -> VAR8 [ VAR8 ] . VAR14 . VAR15 = 0 ; for ( VAR5 = 0 ; VAR5 < VAR13 -> VAR16 * 16 ; VAR5 += 16 ) { for ( VAR7 = 0 ; VAR7 < VAR13 -> VAR17 ; VAR7 ++ ) { if ( VAR2 -> VAR18 && ! VAR8 && VAR2 -> VAR19 [ VAR5 + VAR7 ] ) { for ( VAR4 = 0 ; VAR4 < VAR13 -> VAR20 [ VAR7 ] ; VAR4 ++ ) { VAR2 -> VAR8 [ 0 ] . VAR21 [ VAR9 + VAR4 ] = ( VAR2 -> VAR8 [ 0 ] . VAR21 [ VAR9 + VAR4 ] + VAR2 -> VAR8 [ 1 ] . VAR21 [ VAR9 + VAR4 ] ) / 2.0 ; VAR2 -> VAR8 [ 1 ] . VAR21 [ VAR9 + VAR4 ] = VAR2 -> VAR8 [ 0 ] . VAR21 [ VAR9 + VAR4 ] - VAR2 -> VAR8 [ 1 ] . VAR21 [ VAR9 + VAR4 ] ; } } VAR9 += VAR13 -> VAR20 [ VAR7 ] ; } for ( VAR11 = VAR13 -> VAR17 ; VAR11 > 0 && VAR2 -> VAR8 [ VAR8 ] . VAR22 [ VAR5 + VAR11 - 1 ] ; VAR11 -- ) ; VAR10 = FUN2 ( VAR10 , VAR11 ) ; } VAR13 -> VAR23 = VAR10 ; for ( VAR5 = 0 ; VAR5 < VAR13 -> VAR16 ; VAR5 += VAR13 -> VAR24 [ VAR5 ] ) { for ( VAR7 = 0 ; VAR7 < VAR13 -> VAR23 ; VAR7 ++ ) { VAR4 = 1 ; for ( VAR6 = VAR5 ; VAR6 < VAR5 + VAR13 -> VAR24 [ VAR5 ] ; VAR6 ++ ) { if ( ! VAR2 -> VAR8 [ VAR8 ] . VAR22 [ VAR6 * 16 + VAR7 ] ) { VAR4 = 0 ; break ; } } VAR2 -> VAR8 [ VAR8 ] . VAR22 [ VAR5 * 16 + VAR7 ] = VAR4 ; } } } if ( VAR3 > 1 && VAR2 -> VAR18 ) { VAR12 * VAR25 = & VAR2 -> VAR8 [ 0 ] . VAR13 ; VAR12 * VAR26 = & VAR2 -> VAR8 [ 1 ] . VAR13 ; int VAR27 = 0 ; VAR25 -> VAR23 = FUN2 ( VAR25 -> VAR23 , VAR26 -> VAR23 ) ; VAR26 -> VAR23 = VAR25 -> VAR23 ; for ( VAR5 = 0 ; VAR5 < VAR25 -> VAR16 * 16 ; VAR5 += 16 ) for ( VAR4 = 0 ; VAR4 < VAR25 -> VAR23 ; VAR4 ++ ) if ( VAR2 -> VAR19 [ VAR5 + VAR4 ] ) VAR27 ++ ; if ( VAR27 == 0 || VAR25 -> VAR23 == 0 ) VAR2 -> VAR28 = 0 ; else VAR2 -> VAR28 = VAR27 < VAR25 -> VAR23 * VAR25 -> VAR16 ? 1 : 2 ; } } #1
505#505#static VAR1 FUN1 ( char * VAR2 ) { ossl_ssize_t VAR3 = VAR4 . VAR5 - 1 ; size_t VAR6 = ( VAR4 . VAR7 + VAR2 - VAR4 . VAR8 ) / VAR4 . VAR9 ; for ( ; VAR6 ; VAR6 >>= 1 , VAR3 -- ) { if ( FUN2 ( VAR4 . VAR10 , VAR6 ) ) break ; FUN3 ( ( VAR6 & 1 ) == 0 ) ; } return VAR3 ; } #0
506#506#static void FUN1 ( FUNC_TYPE VAR1 , int VAR2 ) { VAR3 * VAR4 ; int VAR5 = 0 ; DISPLAY_COLUMNS VAR6 = { 0 } ; if ( ! VAR2 ) FUN2 ( & VAR6 ) ; for ( VAR4 = VAR7 ; VAR4 -> VAR8 != NULL ; VAR4 ++ ) { if ( VAR4 -> VAR9 != VAR1 ) continue ; if ( VAR2 ) { FUN3 ( VAR10 , ) ; FUN3 ( VAR10 , ) ; } #0
507#507#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 [ 0 ] -> VAR9 ; VAR11 * VAR12 = VAR2 -> VAR12 ; uint64_t VAR13 ; uint32_t VAR14 ; uint32_t VAR15 = VAR4 -> VAR13 ; VAR16 * VAR17 = VAR4 -> VAR18 ; int VAR19 = VAR9 -> VAR20 > 2 ? 4 : 0 ; VAR6 -> VAR21 += VAR4 -> VAR21 ; FUN2 ( VAR12 , ) ; VAR13 = FUN3 ( VAR17 ) ; VAR17 += 4 ; VAR15 -= 4 ; if ( VAR13 < 24 || VAR13 - 24 > VAR15 ) return VAR22 ; FUN4 ( VAR12 , VAR13 ) ; FUN5 ( VAR12 , 0x410 ) ; FUN6 ( VAR12 , 0 ) ; FUN6 ( VAR12 , 0 ) ; FUN4 ( VAR12 , -1 ) ; FUN4 ( VAR12 , VAR4 -> VAR23 ) ; VAR14 = FUN3 ( VAR17 + 4 ) ; FUN7 ( VAR12 , VAR17 , VAR25 ) ; VAR17 += VAR25 ; VAR15 -= VAR25 ; FUN7 ( VAR12 , VAR17 , VAR13 - 24 ) ; VAR17 += VAR13 - 24 ; VAR15 -= VAR13 - 24 ; } return 0 ; } #1
508#508#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 , int VAR6 , VAR3 * VAR7 , int VAR8 ) { int VAR9 ; VAR2 -> VAR10 . FUN2 ( VAR4 ) ; VAR9 = FUN3 ( VAR2 , VAR6 ) ; if ( VAR9 == 0xfffff ) { FUN4 ( VAR2 -> VAR11 , VAR12 , "" "" ) ; return VAR13 ; } VAR9 = ( VAR9 * ( VAR7 [ 0 ] << VAR8 ) ) + VAR2 -> VAR14 [ VAR5 ] ; VAR2 -> VAR14 [ VAR5 ] = VAR9 ; VAR4 [ 0 ] = VAR9 ; return 0 ; } "#0
509#509#static void FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , VAR1 * VAR5 ) { int VAR6 , VAR7 , VAR8 , VAR9 , VAR10 , VAR11 ; VAR6 = VAR4 + ( VAR4 == VAR12 ) ; * VAR5 = ( VAR3 + ( VAR6 * 3 ) - 4 ) / ( 3 * VAR6 ) ; VAR7 = * VAR5 * 3 ; if ( VAR4 > VAR13 ) { VAR10 = 1 ; for ( VAR8 = 1 ; VAR8 <= VAR7 ; VAR8 ++ ) { VAR11 = VAR2 [ VAR10 ] ; assert ( VAR11 >= 0 && VAR11 <= 24 ) ; for ( VAR9 = 1 ; VAR9 < VAR6 ; VAR9 ++ ) { if ( VAR2 [ VAR10 + VAR9 ] < VAR11 ) VAR11 = VAR2 [ VAR10 + VAR9 ] ; } VAR2 [ VAR8 ] = VAR11 ; VAR10 += VAR6 ; } } if ( VAR2 [ 0 ] > 15 ) VAR2 [ 0 ] = 15 ; for ( VAR8 = 1 ; VAR8 <= VAR7 ; VAR8 ++ ) VAR2 [ VAR8 ] = FUN2 ( VAR2 [ VAR8 ] , VAR2 [ VAR8 - 1 ] + 2 ) ; VAR8 -- ; while ( -- VAR8 >= 0 ) VAR2 [ VAR8 ] = FUN2 ( VAR2 [ VAR8 ] , VAR2 [ VAR8 + 1 ] + 2 ) ; if ( VAR4 > VAR13 ) { VAR10 = VAR7 * VAR6 ; for ( VAR8 = VAR7 ; VAR8 > 0 ; VAR8 -- ) { for ( VAR9 = 0 ; VAR9 < VAR6 ; VAR9 ++ ) VAR2 [ VAR10 - VAR9 ] = VAR2 [ VAR8 ] ; VAR10 -= VAR6 ; } } } #0
510#510#"int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 = 1 ; VAR2 -> VAR5 -- ; FUN2 ( VAR2 , 1 , -1 ) ; if ( ( VAR2 -> VAR5 == 0 ) && VAR2 -> VAR6 ) { if ( VAR3 ) FUN3 ( VAR7 ) ; VAR4 = VAR2 -> FUN4 ( VAR2 ) ; if ( VAR3 ) FUN5 ( VAR7 ) ; if ( ! VAR4 ) return 0 ; } #ifdef REF_CHECK if ( VAR2 -> VAR5 < 0 ) { fprintf ( VAR8 , "" "" ) ; FUN6 ( ) ; } #endif if ( ! FUN7 ( VAR2 , 0 ) ) { FUN8 ( VAR9 , VAR10 ) ; return 0 ; } return VAR4 ; } "#1
511#511#"VAR1 * FUN1 ( VAR2 * VAR3 ) { VAR1 * VAR4 ; if ( VAR3 == NULL ) { FUN2 ( VAR5 , VAR6 ) ; return NULL ; } if ( VAR3 -> VAR7 == NULL ) { FUN2 ( VAR5 , VAR8 ) ; return NULL ; } VAR4 = FUN3 ( sizeof ( * VAR4 ) ) ; if ( VAR4 == NULL ) goto VAR9 ; VAR4 -> VAR10 = 1 ; VAR4 -> VAR11 = FUN4 ( ) ; if ( VAR4 -> VAR11 == NULL ) { FUN5 ( VAR4 ) ; VAR4 = NULL ; goto VAR9 ; } if ( FUN6 ( ) == FUN7 ( ) ) { VAR4 -> VAR12 = FUN8 ( VAR13 , 0 , FUN9 ( ) ) ; if ( VAR4 -> VAR12 == NULL || FUN10 ( VAR4 -> VAR12 , ( const unsigned char * ) VAR14 , sizeof ( VAR14 ) - 1 ) == 0 ) goto VAR9 ; } FUN11 ( & VAR4 -> VAR15 , VAR4 ) ; VAR4 -> VAR16 = VAR3 -> VAR16 ; VAR4 -> VAR17 . VAR18 = VAR3 -> VAR17 . VAR18 ; VAR4 -> VAR19 = VAR3 -> VAR19 ; VAR4 -> VAR20 = VAR3 -> VAR20 ; VAR4 -> VAR21 = VAR3 -> VAR21 ; VAR4 -> VAR22 = VAR3 -> VAR22 ; VAR4 -> VAR23 = VAR3 -> VAR23 ; VAR4 -> VAR24 = FUN12 ( VAR3 -> VAR24 ) ; if ( VAR4 -> VAR24 == NULL ) goto VAR9 ; VAR4 -> VAR25 = FUN13 ( VAR3 -> VAR25 ) ; if ( VAR4 -> VAR25 == NULL ) goto VAR9 ; FUN14 ( & VAR4 -> VAR15 , VAR3 -> VAR26 ) ; VAR4 -> VAR27 = VAR3 -> VAR27 ; VAR4 -> VAR28 = VAR3 -> VAR28 ; VAR4 -> VAR29 = VAR3 -> VAR29 ; VAR4 -> VAR30 = VAR3 -> VAR30 ; VAR4 -> VAR31 = VAR3 -> VAR31 ; VAR4 -> VAR32 = VAR3 -> VAR32 ; VAR4 -> VAR33 = VAR3 -> VAR33 ; VAR4 -> VAR34 = VAR3 -> VAR34 ; if ( ! FUN15 ( VAR4 -> VAR34 <= sizeof ( VAR4 -> VAR35 ) ) ) goto VAR9 ; memcpy ( & VAR4 -> VAR35 , & VAR3 -> VAR35 , sizeof ( VAR4 -> VAR35 ) ) ; VAR4 -> VAR36 = VAR3 -> VAR37 ; VAR4 -> VAR38 = VAR3 -> VAR38 ; VAR4 -> VAR39 = FUN16 ( ) ; if ( VAR4 -> VAR39 == NULL ) goto VAR9 ; FUN17 ( VAR4 -> VAR39 , VAR3 -> VAR39 ) ; VAR4 -> VAR40 = VAR3 -> VAR40 ; VAR4 -> VAR41 . VAR42 = VAR3 -> VAR41 . VAR42 ; VAR4 -> VAR43 = VAR3 -> VAR43 ; VAR4 -> VAR44 = VAR3 -> VAR44 ; VAR4 -> VAR45 = VAR3 -> VAR45 ; if ( VAR4 -> VAR45 > 1 ) FUN14 ( & VAR4 -> VAR15 , 1 ) ; if ( VAR3 -> VAR46 > 0 ) FUN18 ( VAR4 , VAR3 -> VAR46 ) ; FUN19 ( VAR3 ) ; VAR4 -> VAR3 = VAR3 ; VAR4 -> VAR41 . VAR47 = 0 ; VAR4 -> VAR41 . VAR48 = NULL ; VAR4 -> VAR41 . VAR49 = 0 ; VAR4 -> VAR41 . VAR50 = VAR3 -> VAR41 . VAR50 ; VAR4 -> VAR41 . VAR51 = 0 ; VAR4 -> VAR41 . VAR52 . VAR53 = NULL ; VAR4 -> VAR41 . VAR52 . VAR54 = NULL ; VAR4 -> VAR41 . VAR52 . VAR55 = NULL ; VAR4 -> VAR41 . VAR52 . VAR56 = 0 ; FUN19 ( VAR3 ) ; VAR4 -> VAR57 = VAR3 ; #ifndef OPENSSL_NO_EC if ( VAR3 -> VAR41 . VAR58 ) { VAR4 -> VAR41 . VAR58 = FUN20 ( VAR3 -> VAR41 . VAR58 , VAR3 -> VAR41 . VAR59 ) ; if ( ! VAR4 -> VAR41 . VAR58 ) goto VAR9 ; VAR4 -> VAR41 . VAR59 = VAR3 -> VAR41 . VAR59 ; } if ( VAR3 -> VAR41 . VAR60 ) { VAR4 -> VAR41 . VAR60 = FUN20 ( VAR3 -> VAR41 . VAR60 , VAR3 -> VAR41 . VAR61 * sizeof ( * VAR3 -> VAR41 . VAR60 ) ) ; if ( ! VAR4 -> VAR41 . VAR60 ) goto VAR9 ; VAR4 -> VAR41 . VAR61 = VAR3 -> VAR41 . VAR61 ; } #endif #ifndef OPENSSL_NO_NEXTPROTONEG VAR4 -> VAR41 . VAR62 = NULL ; #endif if ( VAR4 -> VAR3 -> VAR41 . VAR63 ) { VAR4 -> VAR41 . VAR63 = FUN21 ( VAR4 -> VAR3 -> VAR41 . VAR64 ) ; if ( VAR4 -> VAR41 . VAR63 == NULL ) goto VAR9 ; memcpy ( VAR4 -> VAR41 . VAR63 , VAR4 -> VAR3 -> VAR41 . VAR63 , VAR4 -> VAR3 -> VAR41 . VAR64 ) ; VAR4 -> VAR41 . VAR64 = VAR4 -> VAR3 -> VAR41 . VAR64 ; } VAR4 -> VAR65 = NULL ; VAR4 -> VAR66 = VAR67 ; VAR4 -> VAR68 = VAR3 -> VAR68 ; VAR4 -> VAR69 = VAR3 -> VAR69 ; VAR4 -> VAR7 = VAR3 -> VAR7 ; VAR4 -> VAR70 = VAR71 ; if ( ! VAR4 -> VAR7 -> FUN22 ( VAR4 ) ) goto VAR9 ; VAR4 -> VAR72 = ( VAR3 -> VAR7 -> VAR73 == VAR74 ) ? 0 : 1 ; if ( ! FUN23 ( VAR4 ) ) goto VAR9 ; if ( ! FUN24 ( VAR75 , VAR4 , & VAR4 -> VAR76 ) ) goto VAR9 ; #ifndef OPENSSL_NO_PSK VAR4 -> VAR77 = VAR3 -> VAR77 ; VAR4 -> VAR78 = VAR3 -> VAR78 ; #endif VAR4 -> VAR79 = VAR3 -> VAR79 ; VAR4 -> VAR80 = VAR3 -> VAR80 ; VAR4 -> VAR81 = NULL ; #ifndef OPENSSL_NO_CT if ( ! FUN25 ( VAR4 , VAR3 -> VAR82 , VAR3 -> VAR83 ) ) goto VAR9 ; #endif return VAR4 ; VAR9 : FUN26 ( VAR4 ) ; FUN2 ( VAR5 , VAR84 ) ; return NULL ; } "#0
512#512#"int FUN1 ( void * VAR1 , unsigned int VAR2 , unsigned int VAR3 ) { if ( ( int ) VAR2 > 0 && ( int ) VAR3 > 0 && ( VAR2 + 128 ) * ( VAR4 ) ( VAR3 + 128 ) < VAR5 / 4 ) return 0 ; FUN2 ( VAR1 , VAR6 , "" "" , VAR2 , VAR3 ) ; return -1 ; } "#1
513#513#void FUN1 ( VAR1 * VAR2 , void ( * VAR3 ) ( ) ) { int VAR4 ; if ( VAR2 == NULL ) return ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR5 ; VAR4 ++ ) if ( VAR2 -> VAR6 [ VAR4 ] != NULL ) FUN2 ( VAR2 -> VAR6 [ VAR4 ] ) ; FUN3 ( VAR2 ) ; } #1
514#514#static char * FUN1 ( VAR1 * VAR2 , size_t VAR3 ) { char * VAR4 ; VAR4 = FUN2 ( VAR3 ) ; if ( VAR2 -> VAR5 != NULL ) { if ( VAR4 != NULL ) { memcpy ( VAR4 , VAR2 -> VAR5 , VAR2 -> VAR6 ) ; FUN3 ( VAR2 -> VAR5 , VAR2 -> VAR6 ) ; VAR2 -> VAR5 = NULL ; } } return VAR4 ; } #1
515#515#static int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 , VAR5 * VAR6 , VAR7 * VAR8 ) { int VAR9 ; BN_ULONG VAR10 ; BN_ULONG VAR11 = VAR12 - VAR13 [ VAR14 - 1 ] ; VAR15 : if ( ! FUN2 ( VAR2 , VAR3 , VAR16 , VAR17 , VAR8 ) ) return 0 ; if ( VAR4 && ! FUN3 ( VAR2 , 1 ) ) return 0 ; for ( VAR9 = 1 ; VAR9 < VAR14 ; VAR9 ++ ) { BN_ULONG VAR18 = FUN4 ( VAR2 , ( VAR19 ) VAR13 [ VAR9 ] ) ; if ( VAR18 == ( VAR19 ) - 1 ) return 0 ; VAR6 [ VAR9 ] = ( VAR5 ) VAR18 ; } VAR10 = 0 ; VAR20 : for ( VAR9 = 1 ; VAR9 < VAR14 ; VAR9 ++ ) { if ( VAR3 <= 31 && VAR10 <= 0x7fffffff && FUN5 ( VAR13 [ VAR9 ] ) > FUN6 ( VAR2 ) + VAR10 ) break ; if ( VAR4 ? ( VAR6 [ VAR9 ] + VAR10 ) % VAR13 [ VAR9 ] <= 1 : ( VAR6 [ VAR9 ] + VAR10 ) % VAR13 [ VAR9 ] == 0 ) { VAR10 += VAR4 ? 4 : 2 ; if ( VAR10 > VAR11 ) goto VAR15 ; goto VAR20 ; } } if ( ! FUN7 ( VAR2 , VAR10 ) ) return 0 ; if ( FUN8 ( VAR2 ) != VAR3 ) goto VAR15 ; FUN9 ( VAR2 ) ; return 1 ; } #0
516#516#void FUN1 ( VAR1 * VAR2 , const VAR1 * VAR3 , int VAR4 , VAR1 * VAR5 ) { int VAR6 , VAR7 , VAR8 ; const VAR1 * VAR9 ; VAR1 * VAR10 ; VAR8 = VAR4 * 2 ; VAR9 = VAR3 ; VAR10 = VAR2 ; VAR10 [ 0 ] = VAR10 [ VAR8 - 1 ] = 0 ; VAR10 ++ ; VAR7 = VAR4 ; if ( -- VAR7 > 0 ) { VAR9 ++ ; VAR10 [ VAR7 ] = FUN2 ( VAR10 , VAR9 , VAR7 , VAR9 [ -1 ] ) ; VAR10 += 2 ; } for ( VAR6 = VAR4 - 2 ; VAR6 > 0 ; VAR6 -- ) { VAR7 -- ; VAR9 ++ ; VAR10 [ VAR7 ] = FUN3 ( VAR10 , VAR9 , VAR7 , VAR9 [ -1 ] ) ; VAR10 += 2 ; } FUN4 ( VAR2 , VAR2 , VAR2 , VAR8 ) ; FUN5 ( VAR5 , VAR3 , VAR4 ) ; FUN4 ( VAR2 , VAR2 , VAR5 , VAR8 ) ; } #1
517#517#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 ; VAR6 * const VAR7 = VAR4 -> VAR8 [ 0 ] ; VAR6 * const VAR9 = VAR4 -> VAR10 [ 0 ] ; VAR7 -> VAR11 = VAR2 -> VAR12 ; VAR7 -> VAR13 = VAR2 -> VAR13 ; VAR7 -> VAR14 = VAR2 -> VAR15 ; VAR7 -> VAR16 = VAR2 -> VAR16 ; VAR4 -> VAR17 -> FUN2 ( VAR4 ) ; memset ( VAR4 -> VAR18 , 0 , VAR4 -> VAR17 -> VAR19 ) ; if ( ( VAR5 = VAR4 -> VAR17 -> FUN3 ( VAR4 , NULL , NULL ) ) < 0 ) return VAR5 ; if ( ( VAR5 = VAR7 -> VAR20 -> FUN4 ( VAR7 ) ) < 0 ) return VAR5 ; return VAR9 -> VAR20 -> FUN4 ( VAR9 ) ; } #1
518#518#"int FUN1 ( const VAR1 * VAR2 ) { BN_ULONG VAR3 ; int VAR4 ; FUN2 ( VAR2 ) ; if ( VAR2 -> VAR5 == 0 ) return ( 0 ) ; VAR3 = VAR2 -> VAR6 [ VAR2 -> VAR5 - 1 ] ; VAR4 = ( VAR2 -> VAR5 - 1 ) * VAR7 ; if ( VAR3 == 0 ) { #if ! FUN3 ( VAR8 ) && ! FUN3 ( VAR9 ) fprintf ( VAR10 , "" "" "#1
519#519#static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * VAR5 = VAR2 -> VAR6 ; VAR7 * VAR8 = VAR2 -> VAR9 [ 0 ] ; double VAR10 = 0 ; if ( ( VAR5 -> VAR11 & VAR12 ) ) { if ( VAR5 -> VAR13 >= 0.0 ) VAR10 = VAR5 -> VAR13 ; else VAR10 = VAR5 -> VAR13 = FUN2 ( VAR2 , VAR5 -> VAR14 , VAR5 -> VAR15 ) ; FUN3 ( VAR2 , ) ; VAR2 -> VAR27 -> FUN7 ( VAR2 , VAR28 , & VAR17 , NULL , FUN8 ( VAR8 -> VAR25 , FUN9 ( VAR2 ) ) ) ; return 1 ; } return 0 ; } #1
520#520#static void FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 ; int VAR6 , VAR7 , VAR8 ; VAR9 * VAR10 ; int VAR11 , VAR12 , VAR13 ; int VAR14 , VAR15 ; VAR8 = 0 ; for ( VAR3 = 0 ; VAR3 < VAR16 ; VAR3 ++ ) { VAR17 * VAR18 = & VAR2 -> VAR19 [ VAR3 ] ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR20 ; VAR4 ++ ) { if ( VAR2 -> VAR21 [ VAR4 ] [ VAR3 ] == VAR22 ) continue ; VAR6 = VAR2 -> VAR21 [ VAR4 ] [ VAR3 ] + ( VAR2 -> VAR21 [ VAR4 ] [ VAR3 ] == VAR23 ) ; VAR7 = VAR24 [ VAR2 -> VAR21 [ VAR4 ] [ VAR3 ] - 1 ] [ VAR2 -> VAR25 [ VAR4 ] ] ; VAR8 += 4 + ( VAR7 * 7 ) ; VAR10 = VAR18 -> VAR26 [ VAR4 ] ; VAR15 = * VAR10 ++ ; VAR18 -> VAR27 [ VAR4 ] [ 0 ] = VAR15 ; for ( VAR5 = 1 ; VAR5 <= VAR7 ; VAR5 ++ ) { VAR14 = VAR15 ; VAR15 = VAR10 [ 0 ] ; VAR10 += VAR6 ; VAR11 = VAR15 - VAR14 + 2 ; VAR14 = VAR15 ; VAR15 = VAR10 [ 0 ] ; VAR10 += VAR6 ; VAR12 = VAR15 - VAR14 + 2 ; VAR14 = VAR15 ; VAR15 = VAR10 [ 0 ] ; VAR10 += VAR6 ; VAR13 = VAR15 - VAR14 + 2 ; VAR18 -> VAR27 [ VAR4 ] [ VAR5 ] = ( ( VAR11 * 5 + VAR12 ) * 5 ) + VAR13 ; } } } VAR2 -> VAR28 = VAR8 ; } #1
521#521#void FUN1 ( VAR1 * * VAR2 ) { VAR1 * VAR3 = * VAR2 , * VAR4 ; void ( * VAR5 ) ( VAR1 * ) ; while ( VAR3 ) { if ( ( VAR5 = FUN2 ( VAR3 -> VAR6 , 1 ) -> free ) ) FUN3 ( VAR3 -> VAR7 ) ; VAR4 = VAR3 -> VAR4 ; FUN4 ( & VAR3 ) ; VAR3 = VAR4 ; } } #1
522#522#static av_always_inline int FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 , int VAR5 , int VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 ; VAR10 * VAR11 = & VAR8 -> VAR12 [ VAR4 ] ; VAR10 * VAR13 = NULL , * VAR14 = NULL ; VAR15 * VAR16 = VAR8 -> VAR16 ; int VAR17 , VAR18 = VAR8 -> VAR18 ; VAR11 -> VAR19 = VAR5 ; for ( VAR17 = VAR4 ; VAR17 < VAR8 -> VAR20 ; VAR17 += VAR18 ) { if ( VAR17 >= VAR8 -> VAR20 ) break ; VAR11 -> VAR21 = VAR17 << 16 ; VAR8 -> FUN2 ( VAR2 , VAR3 , VAR4 , VAR5 ) ; if ( VAR8 -> VAR22 ) VAR8 -> FUN3 ( VAR2 , VAR3 , VAR4 , VAR5 ) ; FUN4 ( VAR11 , VAR17 , VAR23 & 0xFFFF ) ; VAR8 -> VAR24 . VAR25 -= 64 ; VAR8 -> VAR26 . VAR25 -= 64 ; if ( VAR2 -> VAR27 == VAR28 ) FUN5 ( & VAR16 -> VAR29 , VAR17 , 0 ) ; } return 0 ; } #1
523#523#int FUN1 ( uint64_t VAR1 ) { int VAR2 ; uint64_t VAR3 = VAR1 ; for ( VAR2 = 0 ; VAR3 ; VAR2 ++ ) VAR3 &= VAR3 - 1 ; return VAR2 ; } #0
524#524#static int FUN1 ( VAR1 * VAR2 , const unsigned char * VAR3 , const unsigned char * VAR4 , int VAR5 ) { if ( VAR5 ) FUN2 ( VAR3 , VAR2 -> VAR6 * 8 , VAR2 -> VAR7 ) ; else FUN3 ( VAR3 , VAR2 -> VAR6 * 8 , VAR2 -> VAR7 ) ; return 1 ; } #0
525#525#static void VAR1 FUN1 ( VAR2 * VAR3 , int VAR4 , int16_t VAR5 [ 4 ] , unsigned int VAR6 , VAR7 * VAR8 ) { const unsigned int VAR9 = 52 + VAR6 + VAR8 -> VAR10 ; const int VAR11 = VAR12 [ VAR9 ] ; const int VAR13 = ( VAR14 + 52 ) [ VAR6 + VAR8 -> VAR15 ] ; if ( VAR11 == 0 || VAR13 == 0 ) return ; if ( VAR5 [ 0 ] < 4 ) { int8_t VAR16 [ 4 ] ; VAR16 [ 0 ] = VAR17 [ VAR9 ] [ VAR5 [ 0 ] ] ; VAR16 [ 1 ] = VAR17 [ VAR9 ] [ VAR5 [ 1 ] ] ; VAR16 [ 2 ] = VAR17 [ VAR9 ] [ VAR5 [ 2 ] ] ; VAR16 [ 3 ] = VAR17 [ VAR9 ] [ VAR5 [ 3 ] ] ; VAR8 -> VAR18 . VAR19 . FUN2 ( VAR3 , VAR4 , VAR11 , VAR13 , VAR16 ) ; } else { VAR8 -> VAR18 . VAR19 . FUN3 ( VAR3 , VAR4 , VAR11 , VAR13 ) ; } } #1
526#526#static inline void FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , int VAR4 , int VAR5 ) { int VAR6 = FUN2 ( ( VAR5 * VAR2 -> VAR7 [ 0 ] + 2056 ) >> 4 ) ; int VAR8 ; for ( VAR8 = 0 ; VAR8 < 8 ; VAR8 ++ ) memset ( VAR3 + VAR8 * VAR4 , VAR6 , 8 ) ; } #1
527#527#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR6 ; VAR7 * VAR8 = VAR6 -> VAR9 ; VAR10 * VAR11 = & VAR8 -> VAR12 . VAR13 [ 0 ] ; VAR14 * VAR15 = & VAR2 -> VAR16 [ 0 ] , * VAR17 ; enum AVMatrixEncoding VAR18 = VAR19 ; int VAR20 , VAR21 , VAR22 , VAR23 , VAR24 , VAR25 , VAR26 ; int VAR27 [ VAR28 ] ; if ( VAR8 -> VAR29 & VAR30 ) { for ( VAR20 = 0 , VAR17 = VAR2 -> VAR16 ; VAR20 < VAR2 -> VAR31 ; VAR20 ++ , VAR17 ++ ) { if ( VAR20 < VAR2 -> VAR32 ) FUN2 ( VAR2 , VAR17 ) ; if ( ! VAR17 -> VAR33 ) VAR17 -> VAR34 = 0 ; } VAR2 -> VAR35 = 0 ; VAR2 -> VAR36 = 0 ; } VAR2 -> VAR37 = 0 ; for ( VAR20 = 0 , VAR17 = VAR2 -> VAR16 ; VAR20 < VAR2 -> VAR32 ; VAR20 ++ , VAR17 ++ ) { FUN3 ( VAR2 , VAR17 , 0 ) ; if ( VAR17 -> VAR38 != ( 1 << VAR17 -> VAR39 ) - 1 && ( VAR23 = FUN4 ( VAR2 , VAR17 ) ) < 0 ) return VAR23 ; if ( VAR2 -> VAR35 ) FUN5 ( VAR2 , VAR17 , 0 ) ; if ( VAR17 -> VAR40 > 1 ) { FUN3 ( VAR2 , VAR17 , 1 ) ; FUN5 ( VAR2 , VAR17 , 1 ) ; } VAR2 -> VAR37 |= VAR17 -> VAR41 ; } for ( VAR20 = 1 , VAR17 = & VAR2 -> VAR16 [ 1 ] ; VAR20 < VAR2 -> VAR31 ; VAR20 ++ , VAR17 ++ ) { if ( ! FUN6 ( VAR17 ) ) continue ; if ( VAR20 >= VAR2 -> VAR32 ) { for ( VAR21 = 0 ; VAR21 < VAR17 -> VAR40 ; VAR21 ++ ) if ( VAR17 -> VAR42 [ VAR21 ] . VAR34 ) FUN7 ( VAR2 , VAR17 , VAR21 ) ; break ; } for ( VAR21 = 0 ; VAR21 < VAR17 -> VAR40 ; VAR21 ++ ) if ( VAR17 -> VAR42 [ VAR21 ] . VAR34 ) FUN8 ( VAR2 , VAR17 , VAR21 ) ; } if ( VAR2 -> VAR40 > 1 ) { for ( VAR20 = 0 ; VAR20 < VAR2 -> VAR32 ; VAR20 ++ ) if ( ( VAR23 = FUN9 ( VAR2 , & VAR2 -> VAR16 [ VAR20 ] ) ) < 0 ) return VAR23 ; } if ( VAR8 -> VAR43 ) { if ( VAR2 -> VAR37 & VAR44 ) { VAR2 -> VAR45 [ VAR46 ] = VAR2 -> VAR45 [ VAR47 ] ; VAR2 -> VAR37 = ( VAR2 -> VAR37 & ~ VAR44 ) | VAR48 ; } if ( VAR2 -> VAR37 & VAR49 ) { VAR2 -> VAR45 [ VAR50 ] = VAR2 -> VAR45 [ VAR51 ] ; VAR2 -> VAR37 = ( VAR2 -> VAR37 & ~ VAR49 ) | VAR52 ; } } if ( VAR8 -> VAR43 == VAR53 && FUN10 ( VAR2 -> VAR37 ) && VAR15 -> VAR34 && ( VAR15 -> VAR54 == VAR55 || VAR15 -> VAR54 == VAR56 ) ) VAR26 = VAR53 ; else VAR26 = VAR2 -> VAR37 ; if ( ! FUN11 ( VAR6 , VAR27 , VAR26 ) ) return FUN12 ( VAR57 ) ; VAR6 -> VAR58 = VAR15 -> VAR59 << ( VAR2 -> VAR40 - 1 ) ; switch ( VAR15 -> VAR60 ) { case 16 : VAR6 -> VAR61 = VAR62 ; VAR24 = 16 - VAR15 -> VAR63 ; break ; case 20 : case 24 : VAR6 -> VAR61 = VAR64 ; VAR24 = 24 - VAR15 -> VAR63 ; break ; default : return FUN12 ( VAR57 ) ; } VAR6 -> VAR65 = VAR15 -> VAR60 ; VAR6 -> VAR66 = VAR67 ; VAR6 -> VAR68 = 0 ; VAR4 -> VAR69 = VAR25 = VAR2 -> VAR70 << ( VAR2 -> VAR40 - 1 ) ; if ( ( VAR23 = FUN13 ( VAR6 , VAR4 , 0 ) ) < 0 ) return VAR23 ; if ( VAR26 != VAR2 -> VAR37 ) { FUN14 ( VAR2 -> VAR71 , VAR2 -> VAR45 , VAR15 -> VAR72 , VAR25 , VAR2 -> VAR37 ) ; } for ( VAR20 = 0 ; VAR20 < VAR6 -> VAR73 ; VAR20 ++ ) { VAR74 * VAR75 = VAR2 -> VAR45 [ VAR27 [ VAR20 ] ] ; if ( VAR4 -> VAR76 == VAR62 ) { VAR77 * VAR78 = ( VAR77 * ) VAR4 -> VAR79 [ VAR20 ] ; for ( VAR22 = 0 ; VAR22 < VAR25 ; VAR22 ++ ) VAR78 [ VAR22 ] = FUN15 ( VAR75 [ VAR22 ] * ( 1 << VAR24 ) ) ; } else { VAR74 * VAR78 = ( VAR74 * ) VAR4 -> VAR79 [ VAR20 ] ; for ( VAR22 = 0 ; VAR22 < VAR25 ; VAR22 ++ ) VAR78 [ VAR22 ] = FUN16 ( VAR75 [ VAR22 ] * ( 1 << VAR24 ) ) * ( 1 << 8 ) ; } } if ( ! VAR11 -> VAR80 ) { if ( VAR11 -> VAR81 == VAR82 ) VAR18 = VAR83 ; else if ( VAR11 -> VAR81 == VAR84 ) VAR18 = VAR85 ; } else if ( VAR26 != VAR2 -> VAR37 && VAR15 -> VAR54 == VAR56 ) { VAR18 = VAR83 ; } if ( ( VAR23 = FUN17 ( VAR4 , VAR18 ) ) < 0 ) return VAR23 ; return 0 ; } #1
528#528#void * FUN1 ( unsigned int VAR1 ) { void * VAR2 ; VAR2 = FUN2 ( VAR1 ) ; if ( VAR2 ) memset ( VAR2 , 0 , VAR1 ) ; return VAR2 ; } #1
529#529#VAR1 FUN1 ( const VAR2 * VAR3 , unsigned char * VAR4 , size_t VAR5 ) { size_t VAR6 ; VAR6 = ( FUN2 ( VAR3 -> VAR7 ) + 7 ) / 8 ; if ( VAR3 -> VAR8 == NULL ) return 0 ; if ( VAR4 == NULL ) return VAR6 ; else if ( VAR5 < VAR6 ) return 0 ; if ( FUN3 ( VAR3 -> VAR8 , VAR4 , VAR6 ) == -1 ) { FUN4 ( VAR9 , VAR10 ) ; return 0 ; } return VAR6 ; } #1
530#530#"static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = & VAR2 -> VAR5 ; int VAR6 , VAR7 ; int VAR8 ; FUN2 ( & VAR4 -> VAR9 , 1 ) ; VAR4 -> VAR10 -> VAR11 = FUN3 ( & VAR4 -> VAR9 , 3 ) ; VAR4 -> VAR10 -> VAR12 = FUN3 ( & VAR4 -> VAR9 , 4 ) ; VAR4 -> VAR13 = FUN4 ( & VAR4 -> VAR9 ) ; VAR4 -> VAR14 = FUN3 ( & VAR4 -> VAR9 , 2 ) ; VAR6 = FUN3 ( & VAR4 -> VAR9 , 2 ) ; VAR7 = FUN3 ( & VAR4 -> VAR9 , 2 ) ; VAR4 -> VAR15 |= ( VAR6 << 12 ) ; VAR4 -> VAR16 |= ( VAR7 << 12 ) ; VAR8 = FUN3 ( & VAR4 -> VAR9 , 12 ) ; VAR4 -> VAR17 += ( VAR8 << 18 ) * 400 ; FUN5 ( & VAR4 -> VAR9 , ) ; VAR4 -> VAR25 = VAR4 -> VAR10 -> VAR25 = VAR26 ; if ( VAR4 -> VAR10 -> VAR27 & VAR28 ) FUN7 ( VAR4 -> VAR10 , VAR29 , "" "" , VAR4 -> VAR10 -> VAR11 , VAR4 -> VAR10 -> VAR12 , VAR4 -> VAR13 , VAR4 -> VAR14 , VAR4 -> VAR10 -> VAR18 , VAR4 -> VAR17 ) ; } "#0
531#531#"static int FUN1 ( VAR1 * VAR2 , int VAR3 ) { VAR4 * VAR5 ; uint16_t VAR6 ; uint32_t VAR7 ; uint8_t VAR8 ; if ( FUN2 ( & VAR2 -> VAR9 ) < 8 ) return FUN3 ( VAR10 ) ; VAR2 -> VAR11 = VAR6 = FUN4 ( & VAR2 -> VAR9 ) ; if ( ( unsigned ) VAR2 -> VAR11 >= VAR2 -> VAR12 * VAR2 -> VAR13 ) { VAR2 -> VAR11 = 0 ; return FUN3 ( VAR10 ) ; } VAR7 = FUN5 ( & VAR2 -> VAR9 ) ; VAR8 = FUN6 ( & VAR2 -> VAR9 ) ; FUN6 ( & VAR2 -> VAR9 ) ; if ( VAR8 >= FUN7 ( VAR2 -> VAR14 [ VAR2 -> VAR11 ] . VAR15 ) ) { FUN8 ( VAR2 -> VAR16 , VAR17 , "" "" , VAR8 ) ; return VAR18 ; } VAR2 -> VAR14 [ VAR2 -> VAR11 ] . VAR19 = VAR8 ; VAR5 = VAR2 -> VAR14 [ VAR2 -> VAR11 ] . VAR15 + VAR8 ; VAR5 -> VAR20 = VAR6 ; VAR5 -> VAR21 = VAR2 -> VAR9 . VAR22 + VAR7 - VAR3 - 2 ; if ( ! VAR8 ) { VAR23 * VAR14 = VAR2 -> VAR14 + VAR2 -> VAR11 ; memcpy ( VAR14 -> VAR24 , VAR2 -> VAR24 , VAR2 -> VAR25 * sizeof ( VAR26 ) ) ; memcpy ( VAR14 -> VAR27 , VAR2 -> VAR27 , VAR2 -> VAR25 * sizeof ( VAR28 ) ) ; } return 0 ; } "#1
532#532#static VAR1 FUN1 ( const unsigned char * VAR2 , size_t VAR3 , int VAR4 , unsigned char * * VAR5 ) { int VAR6 = 0 ; size_t VAR7 , VAR8 ; unsigned char * VAR9 , VAR10 = 0 ; const unsigned char * VAR11 ; if ( VAR2 == NULL || VAR3 == 0 ) VAR7 = 1 ; else { VAR7 = VAR3 ; VAR8 = VAR2 [ 0 ] ; if ( VAR7 == 1 && VAR8 == 0 ) VAR4 = 0 ; if ( ! VAR4 && ( VAR8 > 127 ) ) { VAR6 = 1 ; VAR10 = 0 ; } else if ( VAR4 ) { if ( VAR8 > 128 ) { VAR6 = 1 ; VAR10 = 0xFF ; } else if ( VAR8 == 128 ) { for ( VAR8 = 1 ; VAR8 < VAR3 ; VAR8 ++ ) if ( VAR2 [ VAR8 ] ) { VAR6 = 1 ; VAR10 = 0xFF ; break ; } } } VAR7 += VAR6 ; } if ( VAR5 == NULL ) return VAR7 ; VAR9 = * VAR5 ; if ( VAR6 ) * ( VAR9 ++ ) = VAR10 ; if ( VAR2 == NULL || VAR3 == 0 ) * VAR9 = 0 ; else if ( ! VAR4 ) memcpy ( VAR9 , VAR2 , VAR3 ) ; else { VAR11 = VAR2 + VAR3 ; VAR9 += VAR3 ; VAR8 = VAR3 ; while ( ! VAR11 [ -1 ] && VAR8 > 1 ) { * ( -- VAR9 ) = 0 ; VAR11 -- ; VAR8 -- ; } * ( -- VAR9 ) = ( ( * ( -- VAR11 ) ) ^ 0xff ) + 1 ; VAR8 -- ; for ( ; VAR8 > 0 ; VAR8 -- ) * ( -- VAR9 ) = * ( -- VAR11 ) ^ 0xff ; } * VAR5 += VAR7 ; return VAR7 ; } #1
533#533#static void FUN1 ( const VAR1 * VAR2 , VAR3 * restrict VAR4 , int VAR5 ) { int VAR6 ; for ( VAR6 = 0 ; VAR6 < 2 ; VAR6 ++ ) { VAR4 [ 0 ] = FUN2 ( VAR4 [ 0 ] + VAR2 [ 0 ] ) ; VAR4 [ 1 ] = FUN2 ( VAR4 [ 1 ] + VAR2 [ 1 ] ) ; VAR4 += VAR5 ; VAR2 += 8 ; } } #0
534#534#void FUN1 ( int * VAR1 , const int * VAR2 ) { int VAR3 [ VAR4 ] ; int * VAR5 = VAR3 ; int * VAR6 = VAR1 ; int VAR7 , VAR8 ; for ( VAR7 = 0 ; VAR7 < VAR4 ; VAR7 ++ ) { VAR5 [ VAR7 ] = VAR2 [ VAR7 ] * 16 ; for ( VAR8 = 0 ; VAR8 < VAR7 ; VAR8 ++ ) VAR5 [ VAR8 ] = ( ( int ) ( VAR2 [ VAR7 ] * ( unsigned ) VAR6 [ VAR7 - VAR8 - 1 ] ) >> 12 ) + VAR6 [ VAR8 ] ; FUN2 ( int * , VAR5 , VAR6 ) ; } for ( VAR7 = 0 ; VAR7 < VAR4 ; VAR7 ++ ) VAR1 [ VAR7 ] >>= 4 ; } #0
535#535#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = & VAR4 -> VAR8 [ VAR2 -> VAR9 ] ; const struct VAR10 * VAR10 = VAR2 -> VAR10 [ VAR2 -> VAR9 ] ; const struct VAR10 * VAR11 = VAR2 -> VAR9 ? VAR2 -> VAR10 [ VAR2 -> VAR9 - 1 ] : NULL ; FUN2 ( VAR7 ) ; if ( ! VAR11 ) { FUN3 ( ) ; FUN4 ( VAR7 , , VAR7 -> VAR13 [ 0 ] ? , VAR2 -> VAR10 [ VAR2 -> VAR9 ] -> VAR18 ) ; if ( VAR11 -> VAR15 & VAR16 ) { int VAR19 = VAR11 -> VAR20 == VAR21 ? VAR2 -> VAR22 : VAR2 -> VAR12 [ VAR2 -> VAR9 - 1 ] ; FUN4 ( VAR7 , , VAR7 -> VAR13 ) ; } #0
536#536#"int FUN1 ( VAR1 * VAR2 , int VAR3 ) { MMCO VAR4 [ VAR5 ] , * VAR6 = VAR3 ? VAR2 -> VAR6 : VAR4 ; int VAR7 = 0 , VAR8 ; assert ( VAR2 -> VAR9 + VAR2 -> VAR10 <= VAR2 -> VAR11 . VAR12 ) ; if ( VAR2 -> VAR10 && VAR2 -> VAR9 + VAR2 -> VAR10 == VAR2 -> VAR11 . VAR12 && ! ( FUN2 ( VAR2 ) && ! VAR2 -> VAR13 && VAR2 -> VAR14 -> VAR15 ) ) { VAR6 [ 0 ] . VAR16 = VAR17 ; VAR6 [ 0 ] . VAR18 = VAR2 -> VAR19 [ VAR2 -> VAR10 - 1 ] -> VAR20 ; VAR7 = 1 ; if ( FUN2 ( VAR2 ) ) { VAR6 [ 0 ] . VAR18 *= 2 ; VAR6 [ 1 ] . VAR16 = VAR17 ; VAR6 [ 1 ] . VAR18 = VAR6 [ 0 ] . VAR18 + 1 ; VAR7 = 2 ; } } if ( VAR3 ) { VAR2 -> VAR7 = VAR7 ; } else if ( ! VAR3 && VAR7 >= 0 && ( VAR7 != VAR2 -> VAR7 || ( VAR8 = FUN3 ( VAR2 -> VAR6 , VAR4 , VAR7 ) ) ) ) { FUN4 ( VAR2 -> VAR21 , VAR22 , "" "" , VAR7 , VAR2 -> VAR7 , VAR8 ) ; return VAR23 ; } return 0 ; } "#1
537#537#int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { switch ( VAR5 ) { case VAR6 : if ( ! FUN2 ( & VAR2 -> VAR7 . VAR8 , VAR4 ) ) return 0 ; break ; case VAR9 : if ( ! FUN3 ( & VAR2 -> VAR7 . VAR10 , VAR4 ) ) return 0 ; break ; default : FUN4 ( VAR11 , VAR12 ) ; return 0 ; } VAR2 -> VAR5 = VAR5 ; return 1 ; } #0
538#538#int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 ; if ( VAR2 -> VAR5 & VAR6 ) { VAR7 * VAR8 = VAR2 -> VAR9 -> VAR10 ; VAR8 -> VAR11 = VAR2 -> VAR11 ; VAR8 -> VAR12 = FUN2 ( VAR3 , sizeof ( int ) ) ; if ( ! VAR8 -> VAR12 ) { return FUN3 ( VAR13 ) ; } VAR8 -> VAR14 = VAR3 ; VAR8 -> VAR15 = FUN4 ( VAR8 -> VAR11 , sizeof ( VAR16 ) ) ; VAR8 -> VAR17 = FUN4 ( VAR8 -> VAR11 , sizeof ( VAR18 ) ) ; for ( VAR4 = 0 ; VAR4 < VAR8 -> VAR11 ; VAR4 ++ ) { pthread_mutex_init ( & VAR8 -> VAR15 [ VAR4 ] , NULL ) ; pthread_cond_init ( & VAR8 -> VAR17 [ VAR4 ] , NULL ) ; } } return 0 ; } #1
539#539#static void FUN1 ( VAR1 * VAR2 ) { VAR3 * * VAR4 , * VAR5 , * VAR6 ; VAR6 = VAR2 -> VAR7 [ VAR2 -> VAR8 + VAR2 -> VAR9 - 1 ] ; VAR2 -> VAR7 [ VAR2 -> VAR8 + VAR2 -> VAR9 - 1 ] = NULL ; if ( VAR2 -> VAR8 == 0 ) { VAR4 = ( VAR3 * * ) FUN2 ( VAR2 -> VAR7 , ( unsigned int ) ( sizeof ( VAR3 * ) * VAR2 -> VAR9 ) ) ; if ( VAR4 == NULL ) { VAR2 -> VAR10 ++ ; return ; } VAR2 -> VAR11 ++ ; VAR2 -> VAR12 /= 2 ; VAR2 -> VAR9 /= 2 ; VAR2 -> VAR8 = VAR2 -> VAR9 - 1 ; VAR2 -> VAR7 = VAR4 ; } else VAR2 -> VAR8 -- ; VAR2 -> VAR13 -- ; VAR2 -> VAR14 ++ ; VAR5 = VAR2 -> VAR7 [ ( int ) VAR2 -> VAR8 ] ; if ( VAR5 == NULL ) VAR2 -> VAR7 [ ( int ) VAR2 -> VAR8 ] = VAR6 ; else { while ( VAR5 -> VAR15 != NULL ) VAR5 = VAR5 -> VAR15 ; VAR5 -> VAR15 = VAR6 ; } } #1
540#540#FUN1 ( void ) FUN2 ( VAR1 * VAR2 , VAR3 * VAR4 ) { char * VAR5 = NULL ; apr_size_t VAR6 = 0 ; apr_size_t VAR7 = 0 ; char * VAR8 ; char * VAR9 ; apr_size_t VAR10 ; int VAR11 = 0 ; char * VAR12 ; VAR13 * VAR14 = FUN3 ( VAR2 -> VAR15 -> VAR16 ) ; while ( 1 ) { apr_status_t VAR17 ; VAR8 = NULL ; VAR17 = FUN4 ( & VAR8 , VAR2 -> VAR15 -> VAR18 + 2 , & VAR10 , VAR2 , 0 , VAR4 ) ; if ( VAR17 != VAR19 ) { if ( FUN5 ( VAR17 ) ) { VAR2 -> VAR20 = VAR21 ; } else { VAR2 -> VAR20 = VAR22 ; } if ( VAR17 == VAR23 ) { FUN6 ( VAR2 -> VAR24 , : ) ; return ; } while ( VAR8 [ 1 ] == ' ' || VAR8 [ 1 ] == ' ' ) { ++ VAR8 ; -- VAR10 ; } VAR27 = VAR6 + VAR10 + 1 ; if ( VAR27 >= ( VAR28 ) ( VAR2 -> VAR15 -> VAR18 ) ) { VAR2 -> VAR20 = VAR22 ; FUN6 ( VAR2 -> VAR24 , , ) ; FUN7 ( VAR25 , VAR26 , 0 , VAR2 , FUN8 ( 00563 ) ) ; return ; } if ( ! ( VAR14 -> VAR31 & VAR32 ) ) { if ( ! ( VAR9 = strchr ( VAR5 , ' ' ) ) ) { VAR2 -> VAR20 = VAR22 ; FUN7 ( VAR25 , VAR26 , 0 , VAR2 , FUN8 ( 00564 ) , ( int ) VAR34 , VAR5 ) ; return ; } VAR12 = VAR9 - 1 ; * VAR9 ++ = ' ' ; while ( * VAR9 == ' ' || * VAR9 == ' ' ) { ++ VAR9 ; } while ( VAR12 > VAR5 && ( * VAR12 == ' ' || * VAR12 == ' ' ) ) { * VAR12 -- = ' ' ; } } else { VAR9 = ( char * ) FUN11 ( VAR5 ) ; if ( ( VAR9 == VAR5 ) || * VAR9 != ' ' ) { VAR2 -> VAR20 = VAR22 ; FUN7 ( VAR25 , VAR26 , 0 , VAR2 , FUN8 ( 02426 ) , ( int ) VAR34 , VAR5 ) ; return ; } * VAR9 ++ = ' ' ; while ( * VAR9 == ' ' || * VAR9 == ' ' ) { ++ VAR9 ; } VAR12 = ( char * ) FUN12 ( VAR9 ) ; if ( * VAR12 != ' ' ) { VAR2 -> VAR20 = VAR22 ; FUN7 ( VAR25 , VAR26 , 0 , VAR2 , FUN8 ( 02427 ) , ( int ) VAR34 , VAR9 ) ; return ; } } FUN13 ( VAR2 -> VAR35 , VAR5 , VAR9 ) ; } if ( VAR10 == 0 ) { break ; } VAR7 = 0 ; VAR5 = VAR8 ; VAR6 = VAR10 ; } FUN14 ( VAR2 -> VAR35 , VAR36 ) ; FUN15 ( VAR37 , VAR2 , VAR2 -> VAR35 , NULL ) ; } #0
541#541#static av_cold int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 ; int VAR8 ; int VAR9 , VAR10 , VAR11 ; if ( ! VAR2 -> VAR7 || ( VAR2 -> VAR8 < 48 ) ) { FUN2 ( VAR2 , VAR12 , , 7 ) ) break ; VAR7 ++ ; VAR8 -- ; } if ( VAR8 < 12 ) { FUN2 ( VAR2 , VAR12 , , 7 ) ) { FUN2 ( VAR2 , VAR12 , ) ; return -1 ; } VAR7 += 8 ; VAR8 -= 8 ; VAR11 = FUN3 ( VAR7 ) ; if ( VAR11 > VAR8 ) { FUN2 ( VAR2 , VAR12 , , VAR11 ) ; if ( FUN3 ( VAR7 ) != FUN4 ( ' ' , ' ' , ' ' , ' ' ) ) { FUN2 ( VAR2 , VAR12 , , VAR4 -> VAR23 ) ; return -1 ; } FUN7 ( & VAR4 -> VAR32 , VAR4 -> VAR23 , VAR33 ) ; FUN8 ( & VAR4 -> VAR34 ) ; FUN9 ( VAR4 ) ; VAR2 -> VAR35 = VAR36 ; return 0 ; } #0
542#542#"static void FUN1 ( VAR1 * VAR2 , int64_t VAR3 ) { VAR4 * VAR5 = VAR2 -> VAR6 ; VAR7 * VAR8 = VAR2 -> VAR8 ; int64_t VAR9 ; VAR9 = FUN2 ( VAR3 , VAR5 -> VAR10 - VAR11 ) ; VAR9 = FUN3 ( VAR9 , VAR11 ) ; #ifdef VAR12 FUN4 ( VAR2 , VAR13 , VAR14 "" "" , VAR3 , VAR9 ) ; #endif FUN5 ( VAR8 , VAR9 , VAR15 ) ; } "#0
543#543#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 , VAR7 ; int VAR8 , VAR9 , * VAR10 [ 4 ] ; VAR11 * VAR12 ; Jpeg2000T1Context VAR13 ; for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR14 ; VAR5 ++ ) { VAR15 * VAR16 = VAR4 -> VAR16 + VAR5 ; VAR17 * VAR18 = VAR4 -> VAR18 + VAR5 ; for ( VAR6 = 0 ; VAR6 < VAR18 -> VAR19 ; VAR6 ++ ) { VAR20 * VAR21 = VAR16 -> VAR22 + VAR6 ; for ( VAR7 = 0 ; VAR7 < VAR21 -> VAR23 ; VAR7 ++ ) { int VAR24 , VAR25 ; VAR26 * VAR27 = VAR21 -> VAR27 + VAR7 ; int VAR28 , VAR29 , VAR30 = 0 , VAR31 ; VAR31 = VAR7 + ( VAR6 > 0 ) ; if ( VAR27 -> VAR32 [ 0 ] [ 0 ] == VAR27 -> VAR32 [ 0 ] [ 1 ] || VAR27 -> VAR32 [ 1 ] [ 0 ] == VAR27 -> VAR32 [ 1 ] [ 1 ] ) continue ; VAR24 = VAR21 -> VAR33 * VAR21 -> VAR34 ; for ( VAR25 = 0 ; VAR25 < VAR24 ; VAR25 ++ ) { VAR35 * VAR36 = VAR27 -> VAR36 + VAR25 ; for ( VAR30 = 0 ; VAR30 < VAR36 -> VAR37 * VAR36 -> VAR38 ; VAR30 ++ ) { int VAR8 , VAR9 ; int VAR39 , VAR40 ; VAR41 * VAR42 = VAR36 -> VAR42 + VAR30 ; FUN2 ( VAR2 , VAR18 , & VAR13 , VAR42 , VAR42 -> VAR32 [ 0 ] [ 1 ] - VAR42 -> VAR32 [ 0 ] [ 0 ] , VAR42 -> VAR32 [ 1 ] [ 1 ] - VAR42 -> VAR32 [ 1 ] [ 0 ] , VAR31 ) ; VAR8 = VAR42 -> VAR32 [ 0 ] [ 0 ] ; VAR9 = VAR42 -> VAR32 [ 1 ] [ 0 ] ; if ( VAR18 -> VAR43 == VAR44 ) FUN3 ( VAR8 , VAR9 , VAR42 , VAR16 , & VAR13 , VAR27 ) ; else FUN4 ( VAR8 , VAR9 , VAR42 , VAR16 , & VAR13 , VAR27 ) ; } } } } FUN5 ( & VAR16 -> VAR45 , VAR16 -> VAR46 ) ; VAR10 [ VAR5 ] = VAR16 -> VAR46 ; } if ( VAR4 -> VAR18 [ 0 ] . VAR47 ) FUN6 ( VAR2 , VAR4 ) ; if ( VAR2 -> VAR48 <= 8 ) { for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR14 ; VAR5 ++ ) { VAR15 * VAR16 = VAR4 -> VAR16 + VAR5 ; float * VAR49 = ( float * ) VAR16 -> VAR46 ; VAR50 * VAR51 = ( VAR50 * ) VAR16 -> VAR46 ; VAR9 = VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 1 ] [ 0 ] - VAR2 -> VAR52 ; VAR12 = VAR2 -> VAR53 -> VAR46 [ 0 ] + VAR9 * VAR2 -> VAR53 -> VAR54 [ 0 ] ; for ( ; VAR9 < VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 1 ] [ 1 ] - VAR2 -> VAR52 ; VAR9 += VAR2 -> VAR55 [ VAR5 ] ) { VAR11 * VAR56 ; VAR8 = VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 0 ] [ 0 ] - VAR2 -> VAR57 ; VAR56 = VAR12 + VAR8 * VAR2 -> VAR14 + VAR5 ; for ( ; VAR8 < VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 0 ] [ 1 ] - VAR2 -> VAR57 ; VAR8 += VAR2 -> VAR58 [ VAR5 ] ) { int VAR59 ; if ( VAR4 -> VAR18 -> VAR43 == VAR44 ) VAR59 = FUN7 ( * VAR49 ) + ( 1 << ( VAR2 -> VAR60 [ VAR5 ] - 1 ) ) ; else VAR59 = * VAR51 + ( 1 << ( VAR2 -> VAR60 [ VAR5 ] - 1 ) ) ; VAR59 = FUN8 ( VAR59 , 0 , ( 1 << VAR2 -> VAR60 [ VAR5 ] ) - 1 ) ; * VAR56 = VAR59 << ( 8 - VAR2 -> VAR60 [ VAR5 ] ) ; VAR49 ++ ; VAR51 ++ ; VAR56 += VAR2 -> VAR14 ; } VAR12 += VAR2 -> VAR53 -> VAR54 [ 0 ] ; } } } else { for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR14 ; VAR5 ++ ) { VAR15 * VAR16 = VAR4 -> VAR16 + VAR5 ; float * VAR49 = ( float * ) VAR16 -> VAR46 ; VAR50 * VAR51 = ( VAR50 * ) VAR16 -> VAR46 ; VAR61 * VAR62 ; VAR9 = VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 1 ] [ 0 ] - VAR2 -> VAR52 ; VAR62 = ( VAR61 * ) VAR2 -> VAR53 -> VAR46 [ 0 ] + VAR9 * ( VAR2 -> VAR53 -> VAR54 [ 0 ] >> 1 ) ; for ( ; VAR9 < VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 1 ] [ 1 ] - VAR2 -> VAR52 ; VAR9 += VAR2 -> VAR55 [ VAR5 ] ) { VAR61 * VAR56 ; VAR8 = VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 0 ] [ 0 ] - VAR2 -> VAR57 ; VAR56 = VAR62 + ( VAR8 * VAR2 -> VAR14 + VAR5 ) ; for ( ; VAR8 < VAR4 -> VAR16 [ VAR5 ] . VAR32 [ 0 ] [ 1 ] - VAR2 -> VAR57 ; VAR8 += VAR2 -> VAR58 [ VAR5 ] ) { int VAR59 ; if ( VAR4 -> VAR18 -> VAR43 == VAR44 ) VAR59 = FUN7 ( * VAR49 ) + ( 1 << ( VAR2 -> VAR60 [ VAR5 ] - 1 ) ) ; else VAR59 = * VAR51 + ( 1 << ( VAR2 -> VAR60 [ VAR5 ] - 1 ) ) ; VAR59 = FUN8 ( VAR59 , 0 , ( 1 << VAR2 -> VAR60 [ VAR5 ] ) - 1 ) ; * VAR56 = VAR59 << ( 16 - VAR2 -> VAR60 [ VAR5 ] ) ; VAR49 ++ ; VAR51 ++ ; VAR56 += VAR2 -> VAR14 ; } VAR62 += VAR2 -> VAR53 -> VAR54 [ 0 ] >> 1 ; } } } return 0 ; } #0
544#544#static void FUN1 ( VAR1 * VAR2 ) { register VAR3 * VAR4 = & VAR2 -> VAR5 ; uint64 VAR6 ; uint64 VAR7 ; uint32 VAR8 ; uint64 VAR9 ; uint64 VAR10 ; uint32 VAR11 ; uint64 VAR12 ; uint32 VAR13 ; uint32 VAR14 ; VAR15 * VAR16 ; VAR15 * VAR17 ; VAR6 = VAR4 -> VAR18 [ 0 ] ; VAR7 = VAR4 -> VAR19 [ 0 ] ; assert ( VAR4 -> VAR20 == VAR21 ) ; if ( ( VAR4 -> VAR22 == VAR23 ) && ( ! FUN2 ( VAR2 ) ) ) VAR8 = VAR4 -> VAR24 [ 1 ] ; else VAR8 = 1 ; VAR9 = FUN3 ( VAR2 , VAR8 ) ; if ( VAR9 > VAR25 ) { VAR10 = VAR9 ; VAR14 = VAR8 ; } else if ( VAR9 > 0 ) { uint32 VAR26 ; VAR26 = ( VAR27 ) ( VAR25 / VAR9 ) ; VAR14 = VAR26 * VAR8 ; VAR10 = VAR26 * VAR9 ; } else return ; if ( VAR14 >= VAR4 -> VAR28 ) return ; VAR12 = FUN4 ( VAR6 , VAR10 ) ; if ( ( VAR12 == 0 ) || ( VAR12 > 0xFFFFFFFF ) ) return ; VAR13 = ( VAR27 ) VAR12 ; VAR16 = ( VAR15 * ) FUN5 ( VAR2 , VAR13 , sizeof ( VAR15 ) , ) ; VAR17 = ( VAR15 * ) FUN5 ( VAR2 , VAR13 , sizeof ( VAR15 ) , ) ; if ( VAR16 == NULL || VAR17 == NULL ) { if ( VAR16 != NULL ) FUN6 ( VAR16 ) ; if ( VAR17 != NULL ) FUN6 ( VAR17 ) ; return ; } for ( VAR11 = 0 ; VAR11 < VAR13 ; VAR11 ++ ) { if ( VAR10 > VAR6 ) VAR10 = VAR6 ; VAR16 [ VAR11 ] = VAR10 ; VAR17 [ VAR11 ] = VAR7 ; VAR7 += VAR10 ; VAR6 -= VAR10 ; } VAR4 -> VAR31 = VAR4 -> VAR32 = VAR13 ; FUN7 ( VAR2 , VAR33 , VAR14 ) ; FUN6 ( VAR4 -> VAR18 ) ; FUN6 ( VAR4 -> VAR19 ) ; VAR4 -> VAR18 = VAR16 ; VAR4 -> VAR19 = VAR17 ; VAR4 -> VAR34 = 1 ; } #1
545#545#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 , VAR7 , VAR8 , VAR9 = 1 ; int VAR10 = 0 ; for ( VAR5 = 0 ; VAR5 < VAR2 -> VAR11 ; VAR5 ++ ) { if ( ! VAR2 -> VAR12 [ VAR5 ] ) { memcpy ( VAR2 -> VAR13 + VAR10 , VAR2 -> VAR13 + VAR10 - VAR2 -> VAR14 , VAR2 -> VAR14 * sizeof ( * VAR2 -> VAR13 ) ) ; VAR10 += VAR2 -> VAR14 ; continue ; } for ( VAR7 = 0 ; VAR7 < VAR2 -> VAR14 ; VAR7 ++ ) { if ( ! VAR2 -> VAR15 [ VAR10 ] ) { int VAR16 = 1 ; for ( VAR6 = VAR5 + 1 ; VAR6 < VAR2 -> VAR11 ; VAR6 ++ ) { if ( VAR2 -> VAR12 [ VAR6 ] ) break ; if ( VAR2 -> VAR15 [ VAR6 * VAR2 -> VAR14 + VAR7 ] ) { VAR16 = 0 ; break ; } } if ( VAR16 ) { VAR2 -> VAR13 [ VAR10 ++ ] = 0 ; continue ; } } if ( VAR9 ) { VAR8 = FUN2 ( VAR4 , 7 ) ; VAR9 = 0 ; } else { VAR8 += FUN3 ( VAR4 , VAR2 -> VAR17 . VAR18 , 9 , 3 ) - 60 ; } if ( VAR8 < 0 || VAR8 > 128 ) { FUN4 ( VAR2 -> VAR19 , VAR20 , "" "" , VAR8 ) ; return VAR21 ; } VAR2 -> VAR13 [ VAR10 ++ ] = VAR2 -> VAR22 [ VAR8 ] ; } } return 0 ; } "#1
546#546#void FUN1 ( const char * VAR1 , int ( * VAR2 ) ( int VAR3 ) , int VAR4 , int VAR5 ) { assert ( VAR6 != FUN2 ( VAR7 ) ) ; VAR7 [ VAR6 ] . VAR1 = VAR1 ; VAR7 [ VAR6 ] . VAR8 = VAR2 ; VAR7 [ VAR6 ] . VAR4 = VAR4 ; VAR7 [ VAR6 ] . VAR5 = VAR5 ; ++ VAR6 ; VAR9 += VAR4 ; } #1
547#547#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , MOVAtom VAR5 ) { char VAR6 [ 5 ] ; char * VAR7 , VAR8 [ 32 ] , VAR9 [ 4 ] = { 0 } ; const char * VAR10 = NULL ; uint16_t VAR11 = 0 ; uint32_t VAR12 = 0 , VAR13 , VAR14 ; int ( * VAR15 ) ( VAR1 * , VAR3 * , unsigned , const char * ) = NULL ; switch ( VAR5 . VAR16 ) { case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; VAR15 = VAR17 ; break ; case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( 0xa9 , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; VAR15 = VAR18 ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; VAR15 = VAR19 ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ; VAR15 = VAR20 ; break ; case FUN2 ( ' ' , ' ' , ' ' , ' ' ) : VAR10 = ) ; return VAR25 ; } } } else return 0 ; } else if ( VAR5 . VAR21 > 4 && VAR10 && ! VAR2 -> VAR22 ) { VAR13 = FUN8 ( VAR4 ) ; VAR11 = FUN8 ( VAR4 ) ; FUN9 ( VAR11 , VAR9 ) ; VAR5 . VAR21 -= 4 ; } else VAR13 = VAR5 . VAR21 ; if ( VAR2 -> VAR28 && ! VAR10 ) { snprintf ( VAR6 , 5 , ) ) { snprintf ( VAR8 , sizeof ( VAR8 ) , % 3 s % VAR34 % .4 s , VAR10 , VAR7 , ( char * ) & VAR5 . VAR16 , VAR14 , VAR5 . VAR21 ) ; FUN17 ( & VAR7 ) ; return 0 ; } #0
548#548#static int FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , int * VAR6 , int * VAR7 , int * VAR8 ) { VAR9 * VAR10 = & VAR2 -> VAR11 . VAR12 [ 0 ] ; GetBitContext VAR13 ; DCACoreFrameHeader VAR14 ; uint8_t VAR15 [ VAR16 + VAR17 ] = { 0 } ; int VAR18 , VAR19 ; if ( VAR5 < VAR16 ) return VAR20 ; if ( FUN2 ( VAR4 ) == VAR21 ) { if ( ( VAR18 = FUN3 ( & VAR2 -> VAR11 , VAR4 , VAR5 ) ) < 0 ) return VAR18 ; if ( VAR10 -> VAR22 & VAR23 ) { if ( ( VAR18 = FUN4 ( & VAR13 , VAR4 + VAR10 -> VAR24 , VAR10 -> VAR25 ) ) < 0 ) return VAR18 ; if ( FUN5 ( & VAR13 , 32 ) != VAR26 ) return VAR20 ; switch ( FUN6 ( & VAR13 , 8 ) ) { case VAR27 : VAR2 -> VAR28 = FUN6 ( & VAR13 , 8 ) ; case VAR29 : break ; default : return VAR20 ; } if ( VAR2 -> VAR28 >= FUN7 ( VAR30 ) ) return VAR20 ; * VAR7 = VAR30 [ VAR2 -> VAR28 ] ; * VAR6 = 1024 << VAR31 [ VAR2 -> VAR28 ] ; * VAR8 = VAR32 ; return 0 ; } if ( VAR10 -> VAR22 & VAR33 ) { int VAR34 ; if ( ( VAR18 = FUN4 ( & VAR13 , VAR4 + VAR10 -> VAR35 , VAR10 -> VAR36 ) ) < 0 ) return VAR18 ; if ( FUN5 ( & VAR13 , 32 ) != VAR37 ) return VAR20 ; if ( FUN6 ( & VAR13 , 4 ) ) return VAR20 ; FUN8 ( & VAR13 , 8 ) ; FUN9 ( & VAR13 , FUN6 ( & VAR13 , 5 ) + 1 ) ; FUN8 ( & VAR13 , 4 ) ; VAR34 = FUN6 ( & VAR13 , 4 ) + FUN6 ( & VAR13 , 4 ) ; if ( VAR34 > 24 ) return VAR20 ; * VAR7 = VAR10 -> VAR38 ; * VAR6 = ( 1 + ( * VAR7 > 96000 ) ) << VAR34 ; * VAR8 = VAR39 ; return 0 ; } return VAR20 ; } if ( ( VAR18 = FUN10 ( VAR4 , VAR16 , VAR15 , VAR16 ) ) < 0 ) return VAR18 ; if ( FUN11 ( & VAR14 , VAR15 , VAR18 ) < 0 ) return VAR20 ; * VAR6 = VAR14 . VAR40 * VAR41 ; * VAR7 = VAR42 [ VAR14 . VAR28 ] ; if ( * VAR8 != VAR43 ) return 0 ; * VAR8 = VAR44 ; if ( VAR14 . VAR45 ) { switch ( VAR14 . VAR46 ) { case VAR47 : case VAR48 : * VAR8 = VAR49 ; break ; case VAR50 : * VAR8 = VAR51 ; break ; } } VAR19 = FUN12 ( VAR14 . VAR19 , 4 ) ; if ( VAR5 - 4 < VAR19 ) return 0 ; VAR4 += VAR19 ; VAR5 -= VAR19 ; if ( FUN2 ( VAR4 ) != VAR21 ) return 0 ; if ( FUN3 ( & VAR2 -> VAR11 , VAR4 , VAR5 ) < 0 ) return 0 ; if ( VAR10 -> VAR22 & VAR33 ) * VAR8 = VAR39 ; else if ( VAR10 -> VAR22 & ( VAR52 | VAR53 | VAR54 ) ) * VAR8 = VAR55 ; return 0 ; } #0
549#549#static av_always_inline void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 [ 2 ] , const VAR3 * VAR5 [ 2 ] , const VAR3 * VAR6 [ 2 ] , const VAR3 * VAR7 [ 2 ] , VAR8 * VAR9 , int VAR10 , int VAR11 , int VAR12 , int VAR13 , enum PixelFormat VAR14 , int VAR15 ) { const VAR3 * VAR16 = VAR4 [ 0 ] , * VAR17 = VAR4 [ 1 ] , * VAR18 = VAR5 [ 0 ] , * VAR19 = VAR5 [ 1 ] , * VAR20 = VAR6 [ 0 ] , * VAR21 = VAR6 [ 1 ] , * VAR22 = VAR7 [ 0 ] , * VAR23 = VAR7 [ 1 ] ; int VAR24 = 4095 - VAR11 ; int VAR25 = 4095 - VAR12 ; int VAR26 ; for ( VAR26 = 0 ; VAR26 < ( VAR10 >> 1 ) ; VAR26 ++ ) { int VAR27 = ( VAR16 [ VAR26 * 2 ] * VAR24 + VAR17 [ VAR26 * 2 ] * VAR11 ) >> 19 ; int VAR28 = ( VAR16 [ VAR26 * 2 + 1 ] * VAR24 + VAR17 [ VAR26 * 2 + 1 ] * VAR11 ) >> 19 ; int VAR29 = ( VAR18 [ VAR26 ] * VAR25 + VAR19 [ VAR26 ] * VAR12 ) >> 19 ; int VAR30 = ( VAR20 [ VAR26 ] * VAR25 + VAR21 [ VAR26 ] * VAR12 ) >> 19 ; int VAR31 , VAR32 ; const void * VAR33 = VAR2 -> VAR34 [ VAR30 ] , * VAR35 = ( VAR2 -> VAR36 [ VAR29 ] + VAR2 -> VAR37 [ VAR30 ] ) , * VAR38 = VAR2 -> VAR39 [ VAR29 ] ; if ( VAR15 ) { VAR31 = ( VAR22 [ VAR26 * 2 ] * VAR24 + VAR23 [ VAR26 * 2 ] * VAR11 ) >> 19 ; VAR32 = ( VAR22 [ VAR26 * 2 + 1 ] * VAR24 + VAR23 [ VAR26 * 2 + 1 ] * VAR11 ) >> 19 ; } FUN2 ( VAR9 , VAR26 , VAR27 , VAR28 , VAR29 , VAR30 , VAR15 ? VAR31 : 0 , VAR15 ? VAR32 : 0 , VAR33 , VAR35 , VAR38 , VAR13 , VAR14 , VAR15 ) ; } } #0
550#550#static void FUN1 ( VAR1 * VAR2 [ 256 + 2 * VAR3 ] , const int VAR4 , const int VAR5 , void * VAR6 ) { int VAR7 ; VAR1 * VAR8 = VAR6 ; VAR8 -= VAR4 * ( VAR5 >> 9 ) ; for ( VAR7 = 0 ; VAR7 < 256 + 2 * VAR3 ; VAR7 ++ ) { int64_t VAR9 = FUN2 ( VAR7 - VAR3 , 0 , 255 ) * VAR5 ; VAR2 [ VAR7 ] = VAR8 + VAR4 * ( VAR9 >> 16 ) ; } } #1
551#551#static int FUN1 ( int VAR1 , const char * VAR2 , const char * VAR3 , VAR4 * VAR5 ) { char * VAR6 ; int VAR7 ; double * VAR8 ; if ( FUN2 ( & VAR5 -> VAR9 ) < VAR1 * sizeof ( VAR10 ) ) return -1 ; VAR8 = FUN3 ( VAR1 * sizeof ( double ) ) ; if ( ! VAR8 ) return FUN4 ( VAR11 ) ; for ( VAR7 = 0 ; VAR7 < VAR1 ; VAR7 ++ ) VAR8 [ VAR7 ] = FUN5 ( & VAR5 -> VAR9 , VAR5 -> VAR12 ) ; VAR6 = FUN6 ( VAR8 , VAR1 , VAR3 ) ; FUN7 ( & VAR8 ) ; if ( ! VAR6 ) return FUN4 ( VAR11 ) ; FUN8 ( & VAR5 -> VAR13 . VAR14 , VAR2 , VAR6 , VAR15 ) ; return 0 ; } #0
552#552#static ngx_inline void * FUN1 ( VAR1 * VAR2 , size_t VAR3 , ngx_uint_t VAR4 ) { VAR5 * VAR6 ; VAR1 * VAR7 ; VAR7 = VAR2 -> VAR8 ; do { VAR6 = VAR7 -> VAR9 . VAR10 ; if ( VAR4 ) { VAR6 = FUN2 ( VAR6 , VAR11 ) ; } if ( ( VAR12 ) ( VAR7 -> VAR9 . VAR13 - VAR6 ) >= VAR3 ) { VAR7 -> VAR9 . VAR10 = VAR6 + VAR3 ; return VAR6 ; } VAR7 = VAR7 -> VAR9 . VAR14 ; } while ( VAR7 ) ; return FUN3 ( VAR2 , VAR3 ) ; } #0
553#553#"static int FUN1 ( VAR1 * VAR2 ) { unsigned char VAR3 ; const VAR4 * VAR5 = VAR2 -> VAR6 ; int VAR7 ; if ( FUN2 ( VAR5 ) == 0xEFBBBF ) VAR5 += 3 ; for ( VAR7 = 0 ; VAR7 < 3 ; VAR7 ++ ) { if ( sscanf ( VAR5 , , & VAR3 ) != 1 && sscanf ( VAR5 , "" "" , & VAR3 ) != 1 ) return 0 ; VAR5 += FUN3 ( VAR5 ) ; } return VAR8 ; } "#0
554#554#static av_always_inline int FUN1 ( VAR1 * VAR2 , ptrdiff_t VAR3 , int VAR4 ) { LOAD_PIXELS return 2 * FUN2 ( VAR5 - VAR6 ) + ( FUN2 ( VAR7 - VAR8 ) >> 1 ) <= VAR4 ; } #1
555#555#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR4 -> VAR8 ; FUN2 ( & VAR2 -> VAR9 ) ; if ( ++ VAR7 -> VAR10 == VAR7 -> VAR11 ) FUN3 ( VAR4 ) ; return 0 ; } #1
556#556#int FUN1 ( VAR1 * VAR2 ) { int VAR3 = 1 ; if ( ( VAR2 -> VAR4 == 0 ) && VAR2 -> VAR5 ) VAR3 = VAR2 -> FUN2 ( VAR2 ) ; if ( VAR3 ) { VAR2 -> VAR6 ++ ; VAR2 -> VAR4 ++ ; FUN3 ( VAR2 , 0 , 1 ) FUN3 ( VAR2 , 1 , 1 ) } return VAR3 ; } #1
557#557#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { VAR5 * VAR6 = VAR2 -> VAR7 ; VAR8 * VAR9 = VAR2 -> VAR10 [ 0 ] ; int VAR11 = VAR9 -> VAR12 -> VAR13 ; int VAR14 = VAR9 -> VAR12 -> VAR15 >> 3 ; int64_t VAR16 = FUN2 ( VAR2 -> VAR17 ) ; int VAR18 = FUN3 ( VAR2 -> VAR17 , VAR4 , VAR11 ) ; if ( VAR18 < VAR11 ) VAR4 -> VAR19 |= VAR20 ; if ( VAR18 < 0 ) return VAR18 ; if ( ! VAR18 ) return VAR21 ; VAR4 -> VAR22 = 0 ; if ( VAR16 > 0 && VAR14 > 0 ) { VAR4 -> VAR23 = VAR4 -> VAR24 = FUN4 ( VAR16 , VAR9 -> VAR25 . VAR26 , VAR14 * ( VAR27 ) VAR9 -> VAR25 . VAR28 ) ; } if ( VAR6 -> VAR29 ) { if ( VAR18 == VAR11 ) FUN5 ( & VAR6 -> VAR30 , VAR4 -> VAR31 , VAR4 -> VAR31 , ( VAR11 >> 3 ) , VAR6 -> VAR32 , 1 ) ; else memset ( VAR6 -> VAR32 , 0 , 8 ) ; } return VAR18 ; } #0
558#558#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { int VAR6 ; int VAR7 = 0 ; uint8_t VAR8 [ VAR9 ] ; memset ( VAR8 , 128 , sizeof ( VAR8 ) ) ; for ( VAR6 = 0 ; VAR7 < 128 ; VAR6 ++ ) { int VAR10 = FUN2 ( VAR2 , VAR8 , 0 ) + 1 ; if ( VAR10 + VAR7 > 128 ) return -1 ; while ( VAR10 -- ) { VAR4 [ VAR7 ] = VAR5 * VAR6 ; VAR7 ++ ; } } for ( VAR7 = 1 ; VAR7 < 128 ; VAR7 ++ ) { VAR4 [ 256 - VAR7 ] = - VAR4 [ VAR7 ] ; } VAR4 [ 128 ] = - VAR4 [ 127 ] ; return 2 * VAR6 - 1 ; } #1
559#559#"int FUN1 ( VAR1 * VAR2 , int VAR3 , int VAR4 ) { int VAR5 ; long VAR6 ; #ifdef VAR7 #endif VAR6 = VAR2 -> VAR8 -> FUN2 ( VAR2 , VAR3 , VAR4 , VAR9 , 64 , & VAR5 ) ; if ( ! VAR5 ) return ( ( int ) VAR6 ) ; return FUN3 ( VAR2 , ( unsigned long ) VAR6 ) ; } "#0
560#560#static VAR1 FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 ) { VAR6 * VAR7 = FUN2 ( VAR5 -> VAR8 -> VAR9 , & VAR10 ) ; VAR11 * VAR12 = VAR3 -> VAR13 ; VAR14 * VAR15 = ( VAR14 * ) VAR12 -> VAR16 ; apr_status_t VAR17 ; apr_size_t VAR18 ; VAR18 = VAR15 -> VAR19 - VAR15 -> VAR20 ; VAR17 = FUN3 ( VAR15 -> VAR21 , ( char * ) VAR15 -> VAR22 + VAR15 -> VAR20 , & VAR18 ) ; if ( VAR23 != VAR17 ) { FUN4 ( VAR24 , VAR25 , VAR17 , VAR5 , FUN5 ( 02382 ) , VAR3 -> VAR13 -> VAR26 ) ; goto VAR27 ; } if ( VAR28 ) { apr_status_t VAR29 = FUN6 ( VAR28 ) ; if ( VAR29 != VAR23 ) { FUN4 ( VAR24 , VAR25 , VAR29 , VAR5 , FUN5 ( 02384 ) , VAR12 -> VAR26 ) ; FUN7 ( VAR15 -> VAR30 ) ; VAR15 -> VAR30 = NULL ; return VAR35 ; } } if ( VAR17 != VAR23 ) { FUN4 ( VAR24 , VAR36 , VAR17 , VAR5 , FUN5 ( 02386 ) , VAR15 -> VAR38 , ( VAR39 ) FUN10 ( VAR15 -> VAR34 - VAR5 -> VAR40 ) ) ; FUN7 ( VAR15 -> VAR30 ) ; VAR15 -> VAR30 = NULL ; return VAR23 ; VAR27 : if ( VAR28 ) { apr_status_t VAR29 = FUN6 ( VAR28 ) ; if ( VAR29 != VAR23 ) { FUN4 ( VAR24 , VAR25 , VAR29 , VAR5 , FUN5 ( 02388 ) , VAR12 -> VAR26 ) ; } } FUN7 ( VAR15 -> VAR30 ) ; VAR15 -> VAR30 = NULL ; return VAR17 ; } #1
561#561#void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , int VAR5 , int VAR6 , int VAR7 , int VAR8 , int VAR9 ) { VAR3 * VAR10 ; int VAR11 [ 3 ] ; if ( VAR5 ) { VAR5 += VAR12 / 2 - 1 ; FUN2 ( VAR2 -> VAR13 , VAR2 -> VAR14 , VAR5 ) ; VAR11 [ 0 ] = ( FUN3 ( & VAR2 -> VAR15 , VAR2 -> VAR13 ) * ( unsigned ) VAR8 ) >> 12 ; } else { VAR11 [ 0 ] = 0 ; } VAR11 [ 1 ] = ( VAR16 [ VAR6 ] * VAR8 ) >> 8 ; VAR11 [ 2 ] = ( VAR17 [ VAR7 ] * VAR8 ) >> 8 ; memmove ( VAR2 -> VAR14 , VAR2 -> VAR14 + VAR12 , ( VAR18 - VAR12 ) * sizeof ( * VAR2 -> VAR14 ) ) ; VAR10 = VAR2 -> VAR14 + VAR18 - VAR12 ; FUN4 ( VAR10 , VAR9 , VAR5 , VAR11 , VAR5 ? VAR2 -> VAR13 : NULL , VAR19 [ VAR6 ] , VAR20 [ VAR7 ] ) ; memcpy ( VAR2 -> VAR21 , VAR2 -> VAR21 + VAR12 , VAR22 * sizeof ( * VAR2 -> VAR21 ) ) ; if ( FUN5 ( VAR2 -> VAR21 + VAR22 , VAR4 , VAR10 , VAR12 , VAR22 , 1 , 0 , 0xfff ) ) memset ( VAR2 -> VAR21 , 0 , ( VAR22 + VAR12 ) * sizeof ( * VAR2 -> VAR21 ) ) ; } #0
562#562#static int FUN1 ( VAR1 * VAR2 ) { int VAR3 , VAR4 , VAR5 ; for ( VAR4 = 0 ; VAR4 < VAR2 -> VAR6 ; VAR4 ++ ) { if ( FUN2 ( 1 , VAR2 -> VAR7 ) >= VAR8 / sizeof ( VAR9 ) ) { FUN3 ( VAR2 -> VAR10 , VAR11 , ) ; return VAR12 ; } if ( ( VAR5 = FUN4 ( & VAR2 -> VAR16 [ VAR4 ] , sizeof ( VAR9 ) , FUN2 ( 1 , VAR2 -> VAR7 ) ) ) < 0 ) return VAR5 ; if ( ( VAR5 = FUN4 ( & VAR2 -> VAR17 [ VAR4 ] , ( VAR2 -> VAR13 + VAR2 -> VAR15 ) , sizeof ( VAR2 -> VAR17 [ 0 ] [ 0 ] ) ) ) < 0 ) return VAR5 ; for ( VAR3 = 0 ; VAR3 < VAR2 -> VAR15 ; VAR3 ++ ) VAR2 -> VAR17 [ VAR4 ] [ VAR3 ] = 0 ; VAR2 -> VAR18 [ VAR4 ] = VAR2 -> VAR17 [ VAR4 ] + VAR2 -> VAR15 ; } if ( ( VAR5 = FUN4 ( & VAR2 -> VAR19 , VAR2 -> VAR15 , sizeof ( * VAR2 -> VAR19 ) ) ) < 0 ) return VAR5 ; return 0 ; } #1
563#563#int FUN1 ( const VAR1 * VAR2 , enum AVPixelFormat VAR3 , int VAR4 , int VAR5 , unsigned char * VAR6 , int VAR7 ) { int VAR8 , VAR9 , VAR10 = 0 , VAR11 [ 4 ] ; const VAR12 * VAR13 = FUN2 ( VAR3 ) ; int VAR14 = FUN3 ( VAR3 , VAR4 , VAR5 ) ; if ( VAR14 > VAR7 || VAR14 < 0 ) return FUN4 ( VAR15 ) ; for ( VAR8 = 0 ; VAR8 < VAR13 -> VAR16 ; VAR8 ++ ) VAR10 = FUN5 ( VAR13 -> VAR17 [ VAR8 ] . VAR18 , VAR10 ) ; VAR10 ++ ; FUN6 ( VAR11 , VAR3 , VAR4 ) ; for ( VAR8 = 0 ; VAR8 < VAR10 ; VAR8 ++ ) { int VAR19 , VAR20 = ( VAR8 == 1 || VAR8 == 2 ) ? VAR13 -> VAR21 : 0 ; const unsigned char * VAR22 = VAR2 -> VAR23 [ VAR8 ] ; VAR19 = ( VAR5 + ( 1 << VAR20 ) - 1 ) >> VAR20 ; for ( VAR9 = 0 ; VAR9 < VAR19 ; VAR9 ++ ) { memcpy ( VAR6 , VAR22 , VAR11 [ VAR8 ] ) ; VAR6 += VAR11 [ VAR8 ] ; VAR22 += VAR2 -> VAR24 [ VAR8 ] ; } } if ( VAR13 -> VAR25 & VAR26 ) memcpy ( ( unsigned char * ) ( ( ( VAR27 ) VAR6 + 3 ) & ~ 3 ) , VAR2 -> VAR23 [ 1 ] , 256 * 4 ) ; return VAR14 ; } #1
564#564#int FUN1 ( VAR1 * VAR2 , int VAR3 ) { int VAR4 ; size_t VAR5 ; size_t VAR6 ; int VAR7 = 1 ; size_t VAR8 , VAR9 , VAR10 , VAR11 , VAR12 ; if ( ! FUN2 ( VAR2 ) ) return -1 ; if ( VAR2 -> VAR13 -> VAR14 < FUN3 ( VAR2 ) ) return -1 ; if ( VAR2 -> VAR15 == 0 && VAR3 == VAR16 ) FUN4 ( VAR2 -> VAR17 == VAR2 -> VAR13 -> VAR18 . VAR19 + VAR20 ) ; if ( VAR2 -> VAR21 ) { if ( VAR2 -> VAR22 && ( FUN5 ( FUN6 ( VAR2 -> VAR22 ) ) & VAR23 ) != 0 ) VAR10 = 0 ; else VAR10 = FUN7 ( VAR2 -> VAR21 ) ; } else VAR10 = 0 ; if ( VAR2 -> VAR22 && ( FUN8 ( VAR2 -> VAR22 ) == VAR24 ) ) VAR11 = 2 * FUN9 ( VAR2 -> VAR22 ) ; else VAR11 = 0 ; VAR9 = 0 ; VAR2 -> VAR25 = VAR26 ; while ( VAR2 -> VAR17 > 0 ) { if ( VAR3 == VAR16 && VAR2 -> VAR15 != 0 ) { if ( VAR9 > 0 ) { if ( VAR2 -> VAR15 <= VAR20 ) { return -1 ; } VAR2 -> VAR15 -= VAR20 ; VAR2 -> VAR17 += VAR20 ; } else { VAR9 = VAR2 -> VAR13 -> VAR18 . VAR9 ; } } VAR12 = FUN10 ( VAR2 -> VAR27 ) + VAR28 + VAR10 + VAR11 ; if ( VAR2 -> VAR13 -> VAR14 > VAR12 ) VAR6 = VAR2 -> VAR13 -> VAR14 - VAR12 ; else VAR6 = 0 ; if ( VAR6 <= VAR20 ) { VAR4 = FUN11 ( VAR2 -> VAR27 ) ; if ( VAR4 <= 0 ) { VAR2 -> VAR25 = VAR29 ; return VAR4 ; } VAR12 = VAR28 + VAR10 + VAR11 ; if ( VAR2 -> VAR13 -> VAR14 > VAR12 + VAR20 ) { VAR6 = VAR2 -> VAR13 -> VAR14 - VAR12 ; } else { return -1 ; } } if ( ( ( unsigned int ) VAR2 -> VAR17 ) > VAR6 ) VAR8 = VAR6 ; else VAR8 = VAR2 -> VAR17 ; if ( VAR3 == VAR16 ) { if ( VAR8 < VAR20 ) { return -1 ; } FUN12 ( VAR2 , VAR9 , VAR8 - VAR20 ) ; FUN13 ( VAR2 , ( unsigned char * ) & VAR2 -> VAR30 -> VAR31 [ VAR2 -> VAR15 ] ) ; } VAR4 = FUN14 ( VAR2 , VAR3 , & VAR2 -> VAR30 -> VAR31 [ VAR2 -> VAR15 ] , VAR8 , & VAR5 ) ; if ( VAR4 < 0 ) { if ( VAR7 && FUN15 ( FUN16 ( VAR2 ) , VAR32 , 0 , NULL ) > 0 ) { if ( ! ( FUN17 ( VAR2 ) & VAR33 ) ) { if ( ! FUN2 ( VAR2 ) ) return -1 ; VAR7 = 0 ; } else return -1 ; } else { return ( -1 ) ; } } else { FUN4 ( VAR8 == VAR5 ) ; if ( VAR3 == VAR16 && ! VAR2 -> VAR13 -> VAR34 ) { unsigned char * VAR35 = ( unsigned char * ) & VAR2 -> VAR30 -> VAR31 [ VAR2 -> VAR15 ] ; const struct VAR36 * VAR37 = & VAR2 -> VAR13 -> VAR18 ; size_t VAR38 ; if ( VAR9 == 0 && VAR2 -> VAR39 != VAR40 ) { * VAR35 ++ = VAR37 -> VAR3 ; FUN18 ( VAR37 -> VAR19 , VAR35 ) ; FUN19 ( VAR37 -> VAR41 , VAR35 ) ; FUN18 ( 0 , VAR35 ) ; FUN18 ( VAR37 -> VAR19 , VAR35 ) ; VAR35 -= VAR20 ; VAR38 = VAR5 ; } else { VAR35 += VAR20 ; VAR38 = VAR5 - VAR20 ; } if ( ! FUN20 ( VAR2 , VAR35 , VAR38 ) ) return -1 ; } if ( VAR5 == VAR2 -> VAR17 ) { if ( VAR2 -> VAR42 ) VAR2 -> FUN21 ( 1 , VAR2 -> VAR39 , VAR3 , VAR2 -> VAR30 -> VAR31 , ( VAR43 ) ( VAR2 -> VAR15 + VAR2 -> VAR17 ) , VAR2 , VAR2 -> VAR44 ) ; VAR2 -> VAR15 = 0 ; VAR2 -> VAR17 = 0 ; return 1 ; } VAR2 -> VAR15 += VAR5 ; VAR2 -> VAR17 -= VAR5 ; VAR5 -= VAR20 ; VAR9 += VAR5 ; FUN12 ( VAR2 , VAR9 , 0 ) ; } } return 0 ; } #1
565#565#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { VAR6 * VAR7 = & VAR4 -> VAR8 [ VAR5 ] ; int VAR9 , VAR10 , VAR11 = VAR2 -> VAR12 ; for ( VAR10 = 0 ; VAR10 < VAR4 -> VAR13 ; VAR10 ++ ) { int VAR14 = FUN2 ( VAR2 , VAR4 , VAR5 , VAR10 ) ; if ( VAR14 ) { VAR15 * VAR16 = VAR7 -> VAR17 [ VAR10 ] ; if ( VAR7 -> VAR18 [ VAR10 ] ) { VAR15 * VAR19 = VAR7 -> VAR20 [ VAR10 ] ; int VAR21 = VAR7 -> VAR22 [ VAR10 ] ; for ( VAR9 = 0 ; VAR9 < VAR11 ; VAR9 ++ ) VAR16 [ VAR9 ] = VAR16 [ VAR9 ] * ( 1 << VAR14 ) + ( VAR19 [ VAR9 ] << VAR21 ) ; } else { for ( VAR9 = 0 ; VAR9 < VAR11 ; VAR9 ++ ) VAR16 [ VAR9 ] = VAR16 [ VAR9 ] * ( 1 << VAR14 ) ; } } } } #1
566#566#"int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 ; int VAR7 ; VAR8 * VAR9 ; VAR10 * VAR11 ; unsigned int VAR12 ; unsigned char VAR13 [ VAR14 ] ; VAR11 = FUN2 ( & VAR2 -> VAR15 ) ; VAR9 = VAR2 -> VAR16 ; VAR11 -> VAR17 = & ( FUN3 ( & VAR2 -> VAR15 ) [ VAR18 ] ) ; if ( VAR11 -> VAR19 > VAR20 ) { VAR6 = VAR21 ; FUN4 ( VAR22 , VAR23 ) ; goto VAR24 ; } VAR11 -> VAR25 = VAR11 -> VAR17 ; VAR11 -> VAR26 = VAR11 -> VAR19 ; if ( FUN5 ( VAR2 ) && VAR2 -> VAR27 ) { unsigned char * VAR28 ; VAR12 = FUN6 ( VAR2 -> VAR27 ) ; FUN7 ( VAR12 <= VAR14 ) ; if ( VAR11 -> VAR26 < VAR12 ) { VAR6 = VAR29 ; FUN4 ( VAR22 , VAR30 ) ; goto VAR24 ; } VAR11 -> VAR19 -= VAR12 ; VAR28 = VAR11 -> VAR25 + VAR11 -> VAR19 ; VAR5 = VAR2 -> VAR31 -> VAR32 -> FUN8 ( VAR2 , VAR11 , VAR13 , 0 ) ; if ( VAR5 < 0 || FUN9 ( VAR13 , VAR28 , ( VAR33 ) VAR12 ) != 0 ) { VAR6 = VAR34 ; FUN4 ( VAR22 , VAR35 ) ; goto VAR24 ; } } VAR7 = VAR2 -> VAR31 -> VAR32 -> FUN10 ( VAR2 , VAR11 , 1 , 0 ) ; if ( VAR7 == 0 ) { VAR11 -> VAR19 = 0 ; FUN11 ( & VAR2 -> VAR15 ) ; goto VAR36 ; } #ifdef VAR37 FUN12 ( , VAR11 -> VAR25 [ VAR38 ] , ( ( VAR38 + 1 ) % 16 ) ? ' ' : ' ' ; } FUN12 ( "" "" ) ; #endif if ( ( VAR9 != NULL ) && ! FUN5 ( VAR2 ) && ( VAR2 -> VAR39 != NULL ) && ( FUN13 ( VAR2 -> VAR27 ) != NULL ) ) { unsigned char * VAR28 = NULL ; unsigned char VAR40 [ VAR14 ] ; VAR12 = FUN6 ( VAR2 -> VAR27 ) ; FUN7 ( VAR12 <= VAR14 ) ; if ( VAR11 -> VAR26 < VAR12 || ( FUN14 ( VAR2 -> VAR39 ) == VAR41 && VAR11 -> VAR26 < VAR12 + 1 ) ) { VAR6 = VAR29 ; FUN4 ( VAR22 , VAR30 ) ; goto VAR24 ; } if ( FUN14 ( VAR2 -> VAR39 ) == VAR41 ) { VAR28 = VAR40 ; FUN15 ( VAR40 , VAR11 , VAR12 ) ; VAR11 -> VAR19 -= VAR12 ; } else { VAR11 -> VAR19 -= VAR12 ; VAR28 = & VAR11 -> VAR25 [ VAR11 -> VAR19 ] ; } VAR5 = VAR2 -> VAR31 -> VAR32 -> FUN8 ( VAR2 , VAR11 , VAR13 , 0 ) ; if ( VAR5 < 0 || VAR28 == NULL || FUN9 ( VAR13 , VAR28 , ( VAR33 ) VAR12 ) != 0 ) VAR7 = -1 ; if ( VAR11 -> VAR19 > VAR42 + VAR12 ) VAR7 = -1 ; } if ( VAR7 < 0 ) { VAR11 -> VAR19 = 0 ; FUN11 ( & VAR2 -> VAR15 ) ; goto VAR36 ; } if ( VAR2 -> VAR43 != NULL ) { if ( VAR11 -> VAR19 > VAR42 ) { VAR6 = VAR21 ; FUN4 ( VAR22 , VAR44 ) ; goto VAR24 ; } if ( ! FUN16 ( VAR2 , VAR11 ) ) { VAR6 = VAR45 ; FUN4 ( VAR22 , VAR46 ) ; goto VAR24 ; } } if ( VAR11 -> VAR19 > VAR47 ) { VAR6 = VAR21 ; FUN4 ( VAR22 , VAR48 ) ; goto VAR24 ; } VAR11 -> VAR49 = 0 ; FUN11 ( & VAR2 -> VAR15 ) ; FUN17 ( VAR2 , VAR4 ) ; return ( 1 ) ; VAR24 : FUN18 ( VAR2 , VAR50 , VAR6 ) ; VAR36 : return ( 0 ) ; } "#0
567#567#"static int FUN1 ( ) { VAR1 * VAR2 , * VAR3 [ 2 ] , * VAR4 , * VAR5 ; int VAR6 , VAR7 , VAR8 = 0 ; int VAR9 [ ] = { 163 , 7 , 6 , 3 , 0 , -1 } ; int VAR10 [ ] = { 193 , 15 , 0 , -1 } ; VAR2 = FUN2 ( ) ; VAR3 [ 0 ] = FUN2 ( ) ; VAR3 [ 1 ] = FUN2 ( ) ; VAR4 = FUN2 ( ) ; VAR5 = FUN2 ( ) ; FUN3 ( VAR9 , VAR3 [ 0 ] ) ; FUN3 ( VAR10 , VAR3 [ 1 ] ) ; for ( VAR6 = 0 ; VAR6 < VAR11 ; VAR6 ++ ) { FUN4 ( VAR2 , 1024 , 0 , 0 ) ; for ( VAR7 = 0 ; VAR7 < 2 ; VAR7 ++ ) { FUN5 ( VAR4 , VAR2 , VAR3 [ VAR7 ] , VAR12 ) ; FUN6 ( VAR5 , VAR2 ) ; FUN7 ( VAR5 , VAR2 , VAR5 , VAR3 [ VAR7 ] , VAR12 ) ; FUN8 ( VAR5 , VAR4 , VAR5 ) ; if ( ! FUN9 ( VAR5 ) ) { FUN10 ( "" "" ) ; goto VAR13 ; } } } VAR8 = 1 ; VAR13 : FUN11 ( VAR2 ) ; FUN11 ( VAR3 [ 0 ] ) ; FUN11 ( VAR3 [ 1 ] ) ; FUN11 ( VAR4 ) ; FUN11 ( VAR5 ) ; return VAR8 ; } "#0
568#568#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 = VAR4 -> VAR8 ; VAR9 * VAR10 ; VAR11 * VAR8 ; int VAR12 = VAR13 ; int VAR14 = ~ 0 ; int VAR15 = 0 ; int VAR16 , VAR17 , VAR18 ; for ( VAR16 = 0 ; VAR16 < VAR4 -> VAR19 ; VAR16 ++ ) { VAR1 * VAR20 = VAR4 -> VAR21 [ VAR16 ] ; if ( ! VAR7 -> VAR22 [ VAR16 ] && ( VAR18 = FUN2 ( VAR20 ) ) < 0 ) return VAR18 ; if ( VAR16 == 0 ) { VAR15 = VAR7 -> VAR22 [ 0 ] -> VAR23 -> VAR15 ; for ( VAR17 = 1 ; ! VAR16 && VAR17 < VAR4 -> VAR19 ; VAR17 ++ ) VAR4 -> VAR21 [ VAR17 ] -> VAR24 = VAR15 ; } } for ( VAR16 = 0 ; VAR16 < VAR7 -> VAR25 ; VAR16 ++ ) { VAR26 * VAR27 = & VAR7 -> VAR28 [ VAR16 ] ; VAR9 * VAR29 = VAR7 -> VAR22 [ VAR27 -> VAR30 ] ; VAR7 -> VAR31 [ VAR16 ] = VAR29 -> VAR32 [ VAR27 -> VAR33 ] ; VAR12 = FUN3 ( VAR12 , VAR29 -> VAR12 [ 0 ] ) ; VAR14 &= VAR29 -> VAR14 ; } FUN4 ( VAR15 > 0 ) ; VAR10 = FUN5 ( VAR7 -> VAR31 , VAR12 , VAR14 , VAR15 , VAR2 -> VAR34 , VAR2 -> VAR35 ) ; if ( ! VAR10 ) return FUN6 ( VAR36 ) ; VAR10 -> VAR10 -> free = VAR37 ; VAR10 -> VAR38 = VAR7 -> VAR22 [ 0 ] -> VAR38 ; if ( ! ( VAR8 = FUN7 ( sizeof ( * VAR8 ) ) ) ) goto VAR39 ; if ( ! ( VAR8 -> VAR40 = FUN7 ( sizeof ( * VAR8 -> VAR40 ) * VAR4 -> VAR19 ) ) ) goto VAR39 ; for ( VAR16 = 0 ; VAR16 < VAR4 -> VAR19 ; VAR16 ++ ) VAR8 -> VAR40 [ VAR16 ] = VAR7 -> VAR22 [ VAR16 ] ; VAR8 -> VAR41 = VAR4 -> VAR19 ; VAR10 -> VAR10 -> VAR8 = VAR8 ; FUN8 ( VAR2 , VAR10 ) ; memset ( VAR7 -> VAR22 , 0 , sizeof ( * VAR7 -> VAR22 ) * VAR4 -> VAR19 ) ; return 0 ; VAR39 : FUN9 ( VAR10 ) ; if ( VAR8 ) FUN10 ( & VAR8 -> VAR40 ) ; FUN10 ( & VAR8 ) ; return FUN6 ( VAR36 ) ; } #0
569#569#"int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { int VAR5 , VAR6 ; if ( VAR2 -> VAR7 > 8 ) { FUN2 ( VAR2 , VAR8 , "" "" ) ; return VAR9 ; } VAR5 = 1 << VAR2 -> VAR7 ; VAR5 = FUN3 ( VAR2 -> VAR10 / 3 , VAR5 ) ; for ( VAR6 = 0 ; VAR6 < VAR5 ; VAR6 ++ ) { VAR4 [ VAR6 ] = 0xFF000000 | FUN4 ( VAR2 -> VAR11 + VAR6 * 3 ) ; } return 0 ; } "#0
570#570#static void FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 ) { if ( VAR4 && VAR4 -> VAR5 ) { const int * VAR6 = VAR4 -> VAR5 ; int VAR7 = 0 ; int VAR8 = VAR9 ; for ( ; * VAR6 ; VAR6 ++ ) { int VAR10 = FUN2 ( VAR2 -> VAR4 -> VAR11 - * VAR6 ) ; if ( VAR10 < VAR8 ) { VAR8 = VAR10 ; VAR7 = * VAR6 ; } } if ( VAR8 ) { int VAR12 ; const int * VAR13 = VAR4 -> VAR5 ; FUN3 ( VAR2 -> VAR4 , VAR14 , , VAR2 -> VAR4 -> VAR11 , VAR7 , VAR4 -> VAR15 ) ; for ( VAR12 = 0 ; VAR13 [ VAR12 ] ; VAR12 ++ ) { if ( ! VAR13 [ VAR12 + 1 ] ) FUN3 ( VAR2 -> VAR4 , VAR14 , ) ; FUN3 ( VAR2 -> VAR4 , VAR14 , ) ; } VAR2 -> VAR4 -> VAR11 = VAR7 ; } } #1
571#571#static int FUN1 ( const char * VAR1 , const char * VAR2 ) { int VAR3 ; for ( VAR3 = 0 ; VAR2 [ VAR3 ] ; VAR3 ++ ) { if ( VAR2 [ VAR3 ] != VAR1 [ VAR3 ] ) return 0 ; } return ! FUN2 ( VAR1 [ VAR3 ] ) ; } #1
572#572#int FUN1 ( VAR1 * VAR2 ) { int VAR3 ; int VAR4 ; unsigned long VAR5 , VAR6 ; long VAR7 ; unsigned short VAR8 , VAR9 , VAR10 ; const unsigned char * VAR11 ; unsigned char * VAR12 ; VAR7 = VAR2 -> VAR13 -> FUN2 ( VAR2 , VAR14 , VAR15 , VAR16 , VAR17 , & VAR4 ) ; if ( ! VAR4 ) return ( ( int ) VAR7 ) ; VAR11 = ( unsigned char * ) VAR2 -> VAR18 ; if ( VAR7 < 3 ) { VAR3 = VAR19 ; FUN3 ( VAR20 , VAR21 ) ; goto VAR22 ; } FUN4 ( VAR11 , VAR5 ) ; VAR7 -= 3 ; if ( VAR5 != ( unsigned long ) VAR7 || VAR7 < 4 ) { VAR3 = VAR19 ; FUN3 ( VAR20 , VAR21 ) ; goto VAR22 ; } FUN5 ( VAR11 , VAR8 ) ; VAR7 -= 2 ; if ( VAR8 != VAR23 ) { VAR3 = VAR24 ; FUN3 ( VAR20 , VAR25 ) ; goto VAR22 ; } FUN5 ( VAR11 , VAR6 ) ; VAR7 -= 2 ; if ( VAR6 != ( unsigned long ) VAR7 || VAR7 < 1 ) { VAR3 = VAR19 ; FUN3 ( VAR20 , VAR21 ) ; goto VAR22 ; } VAR9 = * ( VAR11 ++ ) ; VAR7 -= 1 ; if ( VAR9 != VAR26 ) { VAR3 = VAR24 ; FUN3 ( VAR20 , VAR27 ) ; goto VAR22 ; } if ( VAR7 < 2 ) { VAR3 = VAR19 ; FUN3 ( VAR20 , VAR21 ) ; goto VAR22 ; } FUN5 ( VAR11 , VAR10 ) ; VAR7 -= 2 ; if ( VAR10 != ( unsigned long ) VAR7 ) { VAR3 = VAR19 ; FUN3 ( VAR20 , VAR21 ) ; goto VAR22 ; } VAR12 = FUN6 ( VAR2 -> VAR28 -> VAR29 , VAR10 ) ; if ( VAR12 == NULL ) { FUN3 ( VAR20 , VAR30 ) ; return 0 ; } VAR2 -> VAR28 -> VAR31 = VAR10 ; VAR2 -> VAR28 -> VAR29 = VAR12 ; memcpy ( VAR2 -> VAR28 -> VAR29 , VAR11 , VAR10 ) ; return 1 ; VAR22 : FUN7 ( VAR2 , VAR32 , VAR3 ) ; return -1 ; } #1
573#573#static const VAR1 * FUN1 ( enum AVPixelFormat VAR2 , enum HWAccelID VAR3 ) { int VAR4 ; for ( VAR4 = 0 ; VAR5 [ VAR4 ] . VAR6 ; VAR4 ++ ) if ( VAR5 [ VAR4 ] . VAR2 == VAR2 && ( ! VAR3 || VAR3 == VAR7 || VAR5 [ VAR4 ] . VAR8 == VAR3 ) ) return & VAR5 [ VAR4 ] ; return NULL ; } #1
574#574#static av_always_inline void FUN1 ( VAR1 * VAR2 , const VAR3 * VAR4 , const VAR3 * VAR5 [ 2 ] , const VAR3 * VAR6 [ 2 ] , const VAR3 * VAR7 , VAR8 * VAR9 , int VAR10 , int VAR11 , int VAR12 , enum AVPixelFormat VAR13 , int VAR14 ) { const VAR3 * VAR15 = VAR5 [ 0 ] , * VAR16 = VAR6 [ 0 ] ; int VAR17 ; int VAR18 = ( VAR13 == VAR19 || VAR13 == VAR20 ) ? 3 : 4 ; int VAR21 [ 4 ] = { 0 } ; if ( VAR13 == VAR22 || VAR13 == VAR23 || VAR13 == VAR24 || VAR13 == VAR25 ) VAR18 = 1 ; if ( VAR11 < 2048 ) { int VAR26 = 0 ; for ( VAR17 = 0 ; VAR17 < VAR10 ; VAR17 ++ ) { int VAR27 = VAR4 [ VAR17 ] << 2 ; int VAR28 = ( VAR15 [ VAR17 ] - ( 128 << 7 ) ) << 2 ; int VAR29 = ( VAR16 [ VAR17 ] - ( 128 << 7 ) ) << 2 ; if ( VAR14 ) { VAR26 = ( VAR7 [ VAR17 ] + 64 ) >> 7 ; if ( VAR26 & 0x100 ) VAR26 = FUN2 ( VAR26 ) ; } FUN3 ( VAR2 , VAR9 , VAR17 , VAR27 , VAR26 , VAR28 , VAR29 , VAR12 , VAR13 , VAR14 , VAR21 ) ; VAR9 += VAR18 ; } } else { const VAR3 * VAR30 = VAR5 [ 1 ] , * VAR31 = VAR6 [ 1 ] ; int VAR26 = 0 ; for ( VAR17 = 0 ; VAR17 < VAR10 ; VAR17 ++ ) { int VAR27 = VAR4 [ VAR17 ] << 2 ; int VAR28 = ( VAR15 [ VAR17 ] + VAR30 [ VAR17 ] - ( 128 << 8 ) ) << 1 ; int VAR29 = ( VAR16 [ VAR17 ] + VAR31 [ VAR17 ] - ( 128 << 8 ) ) << 1 ; if ( VAR14 ) { VAR26 = ( VAR7 [ VAR17 ] + 64 ) >> 7 ; if ( VAR26 & 0x100 ) VAR26 = FUN2 ( VAR26 ) ; } FUN3 ( VAR2 , VAR9 , VAR17 , VAR27 , VAR26 , VAR28 , VAR29 , VAR12 , VAR13 , VAR14 , VAR21 ) ; VAR9 += VAR18 ; } } VAR2 -> VAR32 [ 0 ] [ VAR17 ] = VAR21 [ 0 ] ; VAR2 -> VAR32 [ 1 ] [ VAR17 ] = VAR21 [ 1 ] ; VAR2 -> VAR32 [ 2 ] [ VAR17 ] = VAR21 [ 2 ] ; } #0
575#575#int FUN1 ( int * VAR1 , int VAR2 , int VAR3 , int * VAR4 , int VAR5 , int VAR6 , int * VAR7 , VAR8 * VAR9 ) { int VAR10 ; elbg_data VAR11 ; VAR12 * VAR13 = & VAR11 ; int VAR14 , VAR15 , VAR16 , VAR17 , VAR18 = 0 , VAR19 = 0 ; int * VAR20 = FUN2 ( VAR3 * sizeof ( int ) ) ; int * VAR21 = FUN2 ( VAR5 * sizeof ( int ) ) ; VAR22 * VAR23 = FUN2 ( VAR3 * sizeof ( VAR22 ) ) ; VAR22 * VAR24 ; int VAR25 , VAR26 = 0 ; VAR13 -> VAR27 = VAR28 ; VAR13 -> VAR2 = VAR2 ; VAR13 -> VAR5 = VAR5 ; VAR13 -> VAR4 = VAR4 ; VAR13 -> VAR29 = FUN2 ( VAR5 * sizeof ( VAR22 * ) ) ; VAR13 -> VAR30 = FUN2 ( VAR5 * sizeof ( int ) ) ; VAR13 -> VAR31 = VAR7 ; VAR13 -> VAR1 = VAR1 ; VAR13 -> VAR32 = FUN2 ( VAR5 * sizeof ( int ) ) ; VAR13 -> VAR33 = FUN2 ( 5 * VAR2 * sizeof ( int ) ) ; if ( ! VAR20 || ! VAR21 || ! VAR23 || ! VAR13 -> VAR29 || ! VAR13 -> VAR30 || ! VAR13 -> VAR32 || ! VAR13 -> VAR33 ) { VAR19 = FUN3 ( VAR34 ) ; goto VAR35 ; } VAR13 -> VAR9 = VAR9 ; do { VAR24 = VAR23 ; VAR17 = VAR13 -> VAR27 ; VAR18 ++ ; memset ( VAR13 -> VAR30 , 0 , VAR5 * sizeof ( int ) ) ; memset ( VAR13 -> VAR29 , 0 , VAR5 * sizeof ( VAR22 * ) ) ; VAR13 -> VAR27 = 0 ; for ( VAR14 = 0 ; VAR14 < VAR3 ; VAR14 ++ ) { VAR25 = FUN4 ( VAR13 -> VAR1 + VAR14 * VAR13 -> VAR2 , VAR13 -> VAR4 + VAR26 * VAR13 -> VAR2 , VAR2 , VAR28 ) ; for ( VAR16 = 0 ; VAR16 < VAR13 -> VAR5 ; VAR16 ++ ) { VAR10 = FUN4 ( VAR13 -> VAR1 + VAR14 * VAR13 -> VAR2 , VAR13 -> VAR4 + VAR16 * VAR13 -> VAR2 , VAR2 , VAR25 ) ; if ( VAR10 < VAR25 ) { VAR25 = VAR10 ; VAR26 = VAR16 ; } } VAR13 -> VAR31 [ VAR14 ] = VAR26 ; VAR20 [ VAR14 ] = VAR25 ; VAR13 -> VAR27 += VAR20 [ VAR14 ] ; VAR13 -> VAR30 [ VAR13 -> VAR31 [ VAR14 ] ] += VAR20 [ VAR14 ] ; VAR24 -> VAR36 = VAR14 ; VAR24 -> VAR37 = VAR13 -> VAR29 [ VAR13 -> VAR31 [ VAR14 ] ] ; VAR13 -> VAR29 [ VAR13 -> VAR31 [ VAR14 ] ] = VAR24 ; VAR24 ++ ; } FUN5 ( VAR13 ) ; memset ( VAR21 , 0 , VAR5 * sizeof ( int ) ) ; memset ( VAR13 -> VAR4 , 0 , VAR13 -> VAR5 * VAR2 * sizeof ( int ) ) ; for ( VAR14 = 0 ; VAR14 < VAR3 ; VAR14 ++ ) { VAR21 [ VAR13 -> VAR31 [ VAR14 ] ] ++ ; for ( VAR15 = 0 ; VAR15 < VAR13 -> VAR2 ; VAR15 ++ ) VAR13 -> VAR4 [ VAR13 -> VAR31 [ VAR14 ] * VAR13 -> VAR2 + VAR15 ] += VAR13 -> VAR1 [ VAR14 * VAR13 -> VAR2 + VAR15 ] ; } for ( VAR14 = 0 ; VAR14 < VAR13 -> VAR5 ; VAR14 ++ ) FUN6 ( VAR13 -> VAR4 + VAR14 * VAR13 -> VAR2 , VAR13 -> VAR4 + VAR14 * VAR13 -> VAR2 , VAR21 [ VAR14 ] , VAR13 -> VAR2 ) ; } while ( ( ( VAR17 - VAR13 -> VAR27 ) > VAR38 * VAR13 -> VAR27 ) && ( VAR18 < VAR6 ) ) ; VAR35 : FUN7 ( VAR20 ) ; FUN7 ( VAR21 ) ; FUN7 ( VAR13 -> VAR30 ) ; FUN7 ( VAR23 ) ; FUN7 ( VAR13 -> VAR29 ) ; FUN7 ( VAR13 -> VAR32 ) ; FUN7 ( VAR13 -> VAR33 ) ; return VAR19 ; } #1
576#576#"static int FUN1 ( VAR1 * VAR2 , int VAR3 , const VAR4 * VAR5 , int VAR6 ) { VAR7 * VAR8 = & VAR2 -> VAR8 ; VAR9 * VAR10 = & VAR8 -> VAR10 ; int VAR11 , VAR12 ; int VAR13 ; FUN2 ( & VAR2 -> VAR8 . VAR10 , VAR5 , VAR6 * 8 ) ; VAR13 = VAR2 -> FUN3 ( VAR2 , VAR10 , & VAR2 -> VAR14 ) ; if ( VAR13 < 0 ) { FUN4 ( VAR8 -> VAR15 , VAR16 , ) ; return VAR20 ; } VAR2 -> VAR14 . VAR3 = VAR3 ; VAR8 -> VAR21 = VAR2 -> VAR14 . VAR22 ; VAR8 -> VAR23 = VAR2 -> VAR14 . VAR3 - VAR2 -> VAR14 . VAR24 ; VAR2 -> VAR8 . VAR25 = 0 ; VAR11 = VAR8 -> VAR26 + VAR8 -> VAR27 * VAR8 -> VAR28 ; if ( VAR2 -> VAR14 . VAR24 != VAR11 ) { FUN4 ( VAR8 -> VAR15 , VAR16 , "" "" , VAR2 -> VAR14 . VAR24 , VAR11 ) ; VAR8 -> VAR26 = VAR2 -> VAR14 . VAR24 % VAR8 -> VAR28 ; VAR8 -> VAR27 = VAR2 -> VAR14 . VAR24 / VAR8 -> VAR28 ; } memset ( VAR2 -> VAR29 , -1 , VAR2 -> VAR30 * 4 * 2 * sizeof ( * VAR2 -> VAR29 ) ) ; VAR8 -> VAR31 = 1 ; VAR8 -> VAR32 = VAR8 -> VAR26 ; VAR8 -> VAR33 = VAR8 -> VAR27 ; FUN5 ( VAR8 ) ; while ( ! FUN6 ( VAR2 , VAR8 ) ) { FUN7 ( VAR8 ) ; if ( VAR2 -> VAR14 . VAR17 ) VAR13 = FUN8 ( VAR2 , VAR2 -> VAR34 + VAR8 -> VAR26 * 4 + 4 ) ; else VAR13 = FUN9 ( VAR2 , VAR2 -> VAR34 + VAR8 -> VAR26 * 4 + 4 ) ; if ( VAR13 < 0 ) { FUN10 ( VAR8 , VAR8 -> VAR32 , VAR8 -> VAR33 , VAR8 -> VAR26 - 1 , VAR8 -> VAR27 , VAR35 ) ; return -1 ; } if ( ++ VAR8 -> VAR26 == VAR8 -> VAR28 ) { VAR8 -> VAR26 = 0 ; VAR8 -> VAR27 ++ ; FUN5 ( VAR8 ) ; memmove ( VAR2 -> VAR29 , VAR2 -> VAR34 , VAR2 -> VAR30 * 4 * sizeof ( * VAR2 -> VAR29 ) ) ; memset ( VAR2 -> VAR34 , -1 , VAR2 -> VAR30 * 4 * sizeof ( * VAR2 -> VAR29 ) ) ; if ( VAR2 -> VAR36 && VAR8 -> VAR27 >= 2 ) VAR2 -> FUN11 ( VAR2 , VAR8 -> VAR27 - 2 ) ; if ( VAR37 && ( VAR8 -> VAR15 -> VAR38 & VAR39 ) ) FUN12 ( & VAR8 -> VAR40 -> VAR41 , VAR8 -> VAR27 - 2 , 0 ) ; } if ( VAR8 -> VAR26 == VAR8 -> VAR32 ) VAR8 -> VAR31 = 0 ; VAR8 -> VAR23 -- ; } FUN10 ( VAR8 , VAR8 -> VAR32 , VAR8 -> VAR33 , VAR8 -> VAR26 - 1 , VAR8 -> VAR27 , VAR42 ) ; return VAR8 -> VAR27 == VAR8 -> VAR43 ; } "#0
577#577#static av_cold int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , const VAR5 * VAR6 , int * VAR7 ) { int VAR8 = 0 ; int VAR9 = 256 ; VAR10 * VAR11 = VAR2 -> VAR12 ; const char VAR13 [ ] = VAR14 ; const int VAR15 = sizeof ( VAR13 ) ; const int VAR16 = 100 + VAR15 ; int64_t VAR17 , VAR18 = VAR2 -> VAR19 >> ( VAR11 -> VAR20 ) ; VAR11 -> VAR2 = VAR2 ; VAR11 -> VAR21 = 2 ; VAR11 -> VAR22 = 0 ; VAR11 -> VAR23 = 0 ; VAR11 -> VAR24 = 0 ; VAR17 = ( FUN2 ( VAR18 , VAR11 -> VAR2 -> VAR25 . VAR26 , VAR11 -> VAR2 -> VAR25 . VAR27 ) >> 3 ) - VAR16 ; while ( VAR9 > 255 ) { VAR11 -> VAR28 = FUN3 ( FUN2 ( VAR17 , 1 , VAR11 -> VAR29 * VAR11 -> VAR30 ) , VAR11 -> VAR21 ) ; VAR11 -> VAR28 += 4 + VAR11 -> VAR22 ; VAR9 = VAR11 -> VAR28 / VAR11 -> VAR21 ; VAR11 -> VAR21 <<= 1 ; } VAR11 -> VAR31 = VAR11 -> VAR28 - VAR11 -> VAR28 * ( VAR11 -> VAR32 / 100.0f ) ; VAR8 = FUN4 ( VAR11 , VAR4 , VAR6 , VAR13 , VAR16 , VAR11 -> VAR20 ) ; if ( VAR8 ) return VAR8 ; if ( VAR11 -> VAR20 ) { VAR8 = FUN4 ( VAR11 , VAR4 , VAR6 , VAR13 , VAR16 , 2 ) ; if ( VAR8 ) return VAR8 ; } FUN5 ( & VAR11 -> VAR33 ) ; VAR4 -> VAR34 = FUN6 ( & VAR11 -> VAR33 ) >> 3 ; * VAR7 = 1 ; return 0 ; } #0
578#578#"static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , int VAR5 ) { MPEG4AudioConfig VAR6 ; if ( VAR5 > VAR7 ) { FUN2 ( VAR2 , VAR8 , ) ; return VAR9 ; } if ( VAR6 . VAR11 > VAR13 && VAR6 . VAR11 != VAR12 ) { FUN2 ( VAR2 , VAR8 , "" "" , VAR6 . VAR11 ) ; return VAR9 ; } VAR2 -> VAR14 = VAR6 . VAR15 ; VAR2 -> VAR11 = VAR6 . VAR11 ; return 0 ; } "#0
579#579#"static char * FUN1 ( char * VAR1 , int VAR2 , VAR3 * VAR4 , int VAR5 , VAR6 * VAR7 ) { char * VAR8 = NULL ; switch ( VAR4 -> VAR9 ) { case VAR10 : { int VAR11 = 1 ; if ( VAR7 && VAR7 -> VAR12 && VAR7 -> VAR12 -> VAR13 && FUN2 ( VAR7 -> VAR14 , ) ) VAR11 = 0 ; if ( VAR4 -> VAR15 ) { VAR8 = FUN3 ( VAR4 ) ; } FUN4 ( VAR1 , VAR2 , , VAR5 , VAR5 , VAR11 , VAR8 ? VAR8 : , , VAR5 ) ; if ( VAR8 ) FUN4 ( VAR1 , VAR2 , ) ; break ; case VAR22 : if ( VAR7 && VAR7 -> VAR12 -> VAR13 && FUN2 ( VAR7 -> VAR14 , ) ) { VAR8 = FUN7 ( VAR4 ) ; if ( ! VAR8 ) return NULL ; FUN4 ( VAR1 , VAR2 , , VAR5 , VAR4 -> VAR23 , VAR4 -> VAR24 , VAR5 , FUN8 ( VAR4 ) , VAR8 ) ; } else { if ( VAR4 -> VAR15 ) { VAR8 = FUN6 ( VAR4 ) ; } else { FUN9 ( VAR4 , VAR25 , , VAR5 , VAR4 -> VAR23 , VAR4 -> VAR24 ) ; break ; case VAR28 : if ( VAR5 >= VAR27 ) FUN4 ( VAR1 , VAR2 , , VAR5 , VAR4 -> VAR23 , VAR4 -> VAR24 ) ; break ; case VAR30 : FUN4 ( VAR1 , VAR2 , , VAR5 , VAR4 -> VAR23 , VAR4 -> VAR24 , VAR5 ) ; break ; case VAR31 : FUN4 ( VAR1 , VAR2 , , VAR5 , VAR4 -> VAR23 , VAR4 -> VAR24 , VAR5 ) ; break ; case VAR32 : if ( VAR4 -> VAR15 ) VAR8 = FUN10 ( VAR4 ) ; else FUN9 ( VAR4 , VAR25 , ; break ; case VAR36 : VAR34 = ; break ; default : FUN9 ( VAR4 , VAR25 , ) ; if ( ! VAR8 ) return NULL ; FUN4 ( VAR1 , VAR2 , "" "" "" "" , VAR5 , VAR5 , VAR4 -> VAR18 , VAR4 -> VAR19 , VAR34 , VAR8 ) ; break ; } case VAR38 : FUN4 ( VAR1 , VAR2 , "" "" , VAR5 ) ; break ; case VAR39 : if ( VAR5 >= VAR27 ) FUN4 ( VAR1 , VAR2 , "" "" , VAR5 ) ; break ; case VAR40 : if ( VAR5 >= VAR27 ) FUN4 ( VAR1 , VAR2 , "" "" , VAR5 , 8000 , VAR4 -> VAR24 ) ; break ; case VAR41 : { if ( VAR5 >= VAR27 ) FUN4 ( VAR1 , VAR2 , "" "" , VAR5 , VAR4 -> VAR42 * 8 , VAR4 -> VAR23 ) ; break ; } case VAR43 : FUN4 ( VAR1 , VAR2 , "" "" "" "" , VAR5 , VAR4 -> VAR23 , VAR5 , VAR4 -> VAR44 == 38 ? 20 : 30 ) ; break ; case VAR45 : FUN4 ( VAR1 , VAR2 , "" "" , VAR5 , VAR4 -> VAR23 ) ; break ; case VAR46 : FUN4 ( VAR1 , VAR2 , "" "" , VAR5 ) ; if ( VAR4 -> VAR24 == 2 ) { FUN4 ( VAR1 , VAR2 , "" "" , VAR5 ) ; } break ; default : break ; } FUN11 ( VAR8 ) ; return VAR1 ; } "#0
580#580#static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 ; VAR8 * VAR9 = VAR2 -> VAR9 ; int64_t VAR10 = FUN2 ( VAR9 ) ; int VAR11 ; FUN3 ( VAR9 ) ; VAR4 -> VAR12 = FUN3 ( VAR9 ) ; FUN3 ( VAR9 ) ; FUN3 ( VAR9 ) ; VAR4 -> VAR13 = FUN4 ( FUN5 ( FUN3 ( VAR9 ) ) , VAR14 ) ; VAR4 -> VAR15 = FUN3 ( VAR9 ) ; VAR4 -> VAR16 = FUN3 ( VAR9 ) ; VAR9 -> VAR17 = FUN3 ( VAR9 ) ; if ( VAR10 > 0 && ( ! VAR9 -> VAR17 || VAR10 < VAR9 -> VAR17 ) ) VAR9 -> VAR17 = VAR10 ; VAR4 -> VAR18 = FUN3 ( VAR9 ) ; FUN3 ( VAR9 ) ; VAR4 -> VAR19 = FUN3 ( VAR9 ) ; VAR4 -> VAR20 = FUN3 ( VAR9 ) ; VAR4 -> VAR21 = VAR4 -> VAR16 ; VAR4 -> VAR22 = VAR4 -> VAR19 ; FUN6 ( VAR9 , VAR4 -> VAR18 , VAR23 ) ; VAR4 -> VAR24 = FUN3 ( VAR9 ) ; FUN7 ( VAR9 , VAR4 -> VAR25 , 16 ) ; for ( VAR11 = 0 ; VAR11 < VAR4 -> VAR24 ; VAR11 ++ ) { if ( VAR4 -> VAR25 [ VAR11 ] == 0 ) { if ( VAR4 -> VAR26 ) break ; VAR7 = FUN8 ( VAR2 , NULL ) ; if ( ! VAR7 ) return FUN9 ( VAR27 ) ; FUN10 ( VAR7 , 64 , VAR4 -> VAR13 . VAR28 , VAR4 -> VAR13 . VAR29 ) ; VAR7 -> VAR30 -> VAR31 = VAR32 ; VAR7 -> VAR30 -> VAR33 = VAR34 ; VAR7 -> VAR30 -> VAR35 = 0 ; VAR7 -> VAR30 -> VAR36 = FUN3 ( VAR9 ) ; VAR7 -> VAR30 -> VAR37 = FUN3 ( VAR9 ) ; VAR7 -> VAR30 -> VAR38 = FUN11 ( VAR4 -> VAR13 ) ; VAR7 -> VAR39 = VAR7 -> VAR40 = VAR4 -> VAR15 ; VAR4 -> VAR26 = VAR7 ; VAR4 -> VAR41 = VAR7 -> VAR42 ; if ( VAR4 -> VAR12 == 0x11000 ) FUN3 ( VAR9 ) ; } else if ( VAR4 -> VAR25 [ VAR11 ] == 1 ) { if ( VAR4 -> VAR43 != 0 ) break ; VAR7 = FUN8 ( VAR2 , NULL ) ; if ( ! VAR7 ) return FUN9 ( VAR27 ) ; VAR7 -> VAR30 -> VAR31 = VAR44 ; VAR7 -> VAR30 -> VAR33 = VAR45 ; VAR7 -> VAR30 -> VAR35 = 0 ; VAR7 -> VAR30 -> VAR46 = FUN3 ( VAR9 ) ; VAR7 -> VAR30 -> VAR38 = FUN3 ( VAR9 ) ; VAR7 -> VAR40 = FUN3 ( VAR9 ) ; FUN10 ( VAR7 , 64 , 1 , VAR7 -> VAR30 -> VAR38 ) ; VAR4 -> VAR47 = VAR7 -> VAR42 ; VAR4 -> VAR43 = 1 ; } } return 0 ; } #1
581#581#VAR1 * FUN1 ( VAR2 * VAR3 , VAR1 * * VAR4 ) { VAR1 * VAR5 ; char * VAR6 ; if ( ! FUN2 ( VAR3 ) ) return NULL ; if ( ! VAR4 || ! * VAR4 ) { if ( ! ( VAR5 = FUN3 ( ) ) ) return NULL ; if ( VAR4 ) * VAR4 = VAR5 ; } else VAR5 = * VAR4 ; if ( VAR3 -> VAR7 == VAR8 ) { if ( ! FUN4 ( VAR5 , VAR3 -> VAR9 , VAR3 -> VAR10 ) ) return NULL ; return VAR5 ; } if ( ! FUN4 ( VAR5 , NULL , VAR3 -> VAR10 + 2 ) ) return NULL ; VAR6 = ( char * ) VAR5 -> VAR9 ; if ( VAR3 -> VAR9 [ 0 ] >= ' ' ) strcpy ( VAR6 , ) ; FUN5 ( VAR6 , ( char * ) VAR3 -> VAR9 , VAR3 -> VAR10 + 3 ) ; return VAR5 ; } #1
582#582#static int FUN1 ( VAR1 * VAR2 , void * VAR3 , int VAR4 ) { const void * const * VAR5 ; int VAR6 ; if ( VAR2 == NULL ) return -1 ; if ( VAR2 -> VAR7 == NULL ) { for ( VAR6 = 0 ; VAR6 < VAR2 -> VAR8 ; VAR6 ++ ) if ( VAR2 -> VAR3 [ VAR6 ] == VAR3 ) return ( VAR6 ) ; return ( -1 ) ; } FUN2 ( VAR2 ) ; if ( VAR3 == NULL ) return ( -1 ) ; VAR5 = FUN3 ( & VAR3 , VAR2 -> VAR3 , VAR2 -> VAR8 , sizeof ( void * ) , VAR2 -> VAR7 , VAR4 ) ; if ( VAR5 == NULL ) return ( -1 ) ; return ( int ) ( ( char * * ) VAR5 - VAR2 -> VAR3 ) ; } #1
583#583#"int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR5 * VAR6 , const VAR7 * VAR8 , int VAR9 ) { uint8_t VAR10 = 0 ; int VAR11 ; int VAR12 = 0 ; int VAR13 = 0 ; int VAR14 = 0 ; int VAR15 ; if ( VAR6 != VAR8 -> VAR16 && VAR8 -> VAR17 ) VAR10 = FUN2 ( VAR2 ) ; if ( VAR10 ) { const VAR5 * VAR18 ; int VAR19 ; unsigned VAR20 ; uint8_t VAR21 = 0 ; uint8_t VAR22 ; if ( VAR9 ) { unsigned int VAR23 = FUN3 ( VAR2 ) + 1 ; if ( VAR23 > VAR8 -> VAR17 ) { FUN4 ( VAR4 , VAR24 , , VAR20 ) ; return VAR25 ; } VAR19 = ( 1 - ( VAR22 << 1 ) ) * VAR20 ; for ( VAR15 = 0 ; VAR15 <= VAR18 -> VAR27 ; VAR15 ++ ) { int VAR28 = VAR6 -> VAR28 [ VAR14 ] = FUN2 ( VAR2 ) ; if ( ! VAR28 ) VAR21 = FUN2 ( VAR2 ) ; if ( VAR28 || VAR21 ) { if ( VAR15 < VAR18 -> VAR27 ) VAR11 = VAR19 + VAR18 -> VAR11 [ VAR15 ] ; else VAR11 = VAR19 ; VAR6 -> VAR11 [ VAR14 ] = VAR11 ; if ( VAR11 < 0 ) VAR12 ++ ; else VAR13 ++ ; VAR14 ++ ; } } VAR6 -> VAR27 = VAR14 ; VAR6 -> VAR29 = VAR12 ; if ( VAR6 -> VAR27 != 0 ) { int VAR28 , VAR30 ; for ( VAR15 = 1 ; VAR15 < VAR6 -> VAR27 ; VAR15 ++ ) { VAR11 = VAR6 -> VAR11 [ VAR15 ] ; VAR28 = VAR6 -> VAR28 [ VAR15 ] ; for ( VAR14 = VAR15 - 1 ; VAR14 >= 0 ; VAR14 -- ) { VAR30 = VAR6 -> VAR11 [ VAR14 ] ; if ( VAR11 < VAR30 ) { VAR6 -> VAR11 [ VAR14 + 1 ] = VAR30 ; VAR6 -> VAR28 [ VAR14 + 1 ] = VAR6 -> VAR28 [ VAR14 ] ; VAR6 -> VAR11 [ VAR14 ] = VAR11 ; VAR6 -> VAR28 [ VAR14 ] = VAR28 ; } } } } if ( ( VAR6 -> VAR29 >> 1 ) != 0 ) { int VAR28 ; VAR14 = VAR6 -> VAR29 - 1 ; for ( VAR15 = 0 ; VAR15 < VAR6 -> VAR29 > > 1 ; VAR15 ++ ) { VAR11 = VAR6 -> VAR11 [ VAR15 ] ; VAR28 = VAR6 -> VAR28 [ VAR15 ] ; VAR6 -> VAR11 [ VAR15 ] = VAR6 -> VAR11 [ VAR14 ] ; VAR6 -> VAR28 [ VAR15 ] = VAR6 -> VAR28 [ VAR14 ] ; VAR6 -> VAR11 [ VAR14 ] = VAR11 ; VAR6 -> VAR28 [ VAR14 ] = VAR28 ; VAR14 -- ; } } } else { unsigned int VAR31 , VAR32 ; VAR6 -> VAR29 = FUN3 ( VAR2 ) ; VAR32 = FUN3 ( VAR2 ) ; if ( VAR6 -> VAR29 >= VAR33 || VAR32 >= VAR33 ) { FUN4 ( VAR4 , VAR24 , "" "" ) ; return VAR25 ; } VAR6 -> VAR27 = VAR6 -> VAR29 + VAR32 ; if ( VAR6 -> VAR27 ) { VAR31 = 0 ; for ( VAR15 = 0 ; VAR15 < VAR6 -> VAR29 ; VAR15 ++ ) { VAR11 = FUN3 ( VAR2 ) + 1 ; VAR31 -= VAR11 ; VAR6 -> VAR11 [ VAR15 ] = VAR31 ; VAR6 -> VAR28 [ VAR15 ] = FUN2 ( VAR2 ) ; } VAR31 = 0 ; for ( VAR15 = 0 ; VAR15 < VAR32 ; VAR15 ++ ) { VAR11 = FUN3 ( VAR2 ) + 1 ; VAR31 += VAR11 ; VAR6 -> VAR11 [ VAR6 -> VAR29 + VAR15 ] = VAR31 ; VAR6 -> VAR28 [ VAR6 -> VAR29 + VAR15 ] = FUN2 ( VAR2 ) ; } } } return 0 ; } "#1
584#584#static int FUN1 ( VAR1 * VAR2 ) { FUN2 ( VAR2 ) ; FUN3 ( VAR2 ) ; FUN4 ( VAR2 ) ; FUN5 ( VAR2 , VAR3 ) ; FUN5 ( VAR2 , VAR4 ) ; return 0 ; } #0
585#585#static int FUN1 ( VAR1 * VAR2 , int VAR3 , unsigned char * VAR4 , int VAR5 , int VAR6 ) { size_t VAR7 , VAR8 ; if ( FUN2 ( VAR2 , VAR3 ) == NULL ) return 0 ; for ( VAR7 = 0 , VAR8 = VAR5 ; VAR7 < VAR3 * sizeof VAR2 -> VAR9 [ 0 ] ; VAR7 ++ , VAR8 += VAR6 ) { ( ( unsigned char * ) VAR2 -> VAR9 ) [ VAR7 ] = VAR4 [ VAR8 ] ; } VAR2 -> VAR3 = VAR3 ; FUN3 ( VAR2 ) ; return 1 ; } #1
586#586#VAR1 FUN1 ( VAR2 * VAR3 , uint32 VAR4 , void * VAR5 , tmsize_t VAR6 ) { static const char VAR7 [ ] = , ( unsigned long ) VAR4 , ( unsigned long ) VAR9 -> VAR17 ) ; return ( ( VAR1 ) ( -1 ) ) ; } VAR11 = VAR9 -> VAR19 ; if ( VAR11 > VAR9 -> VAR20 ) VAR11 = VAR9 -> VAR20 ; VAR12 = ( ( VAR9 -> VAR20 + VAR11 - 1 ) / VAR11 ) ; VAR13 = ( VAR4 % VAR12 ) ; VAR14 = ( VAR21 ) ( VAR4 / VAR12 ) ; VAR15 = VAR9 -> VAR20 - VAR13 * VAR11 ; if ( VAR15 > VAR11 ) VAR15 = VAR11 ; VAR16 = FUN4 ( VAR3 , VAR15 ) ; if ( VAR16 == 0 ) return ( ( VAR1 ) ( -1 ) ) ; if ( VAR9 -> VAR22 == VAR23 && VAR6 != ( VAR1 ) ( -1 ) && VAR6 >= VAR16 && ! FUN5 ( VAR3 ) && ( ( VAR3 -> VAR24 & VAR25 ) == 0 ) ) { if ( FUN6 ( VAR3 , VAR4 , VAR5 , VAR16 , VAR7 ) != VAR16 ) return ( ( VAR1 ) ( -1 ) ) ; if ( ! FUN7 ( VAR3 , VAR9 -> VAR26 ) && ( VAR3 -> VAR24 & VAR27 ) == 0 ) FUN8 ( VAR5 , VAR16 ) ; ( * VAR3 -> VAR28 ) ( VAR3 , VAR5 , VAR16 ) ; return ( VAR16 ) ; } if ( ( VAR6 != ( VAR1 ) ( -1 ) ) && ( VAR6 < VAR16 ) ) VAR16 = VAR6 ; if ( ! FUN9 ( VAR3 , VAR4 ) ) return ( ( VAR1 ) ( -1 ) ) ; if ( ( * VAR3 -> VAR29 ) ( VAR3 , VAR5 , VAR16 , VAR14 ) <= 0 ) return ( ( VAR1 ) ( -1 ) ) ; ( * VAR3 -> VAR28 ) ( VAR3 , VAR5 , VAR16 ) ; return ( VAR16 ) ; } #0
587#587#static int FUN1 ( VAR1 * VAR2 , VAR3 * * VAR4 , int * VAR5 , int VAR6 , VAR7 * * VAR8 , int * VAR9 ) { int VAR10 = 0 , VAR11 , VAR12 = * VAR5 ; VAR3 * VAR13 = * VAR4 ; VAR7 * VAR14 ; if ( ! VAR6 ) { * VAR9 = 1 ; * VAR8 = FUN2 ( sizeof ( int ) ) ; if ( ! * VAR8 ) return FUN3 ( VAR15 ) ; * VAR8 [ 0 ] = VAR12 ; return 0 ; } FUN4 ( VAR12 > 0 ) ; * VAR9 = * VAR13 + 1 ; VAR13 += 1 ; VAR12 -= 1 ; VAR14 = FUN2 ( * VAR9 * sizeof ( int ) ) ; if ( ! VAR14 ) return FUN3 ( VAR15 ) ; switch ( VAR6 ) { case 0x1 : { uint8_t VAR16 ; uint32_t VAR17 = 0 ; for ( VAR11 = 0 ; VAR10 == 0 && VAR11 < * VAR9 - 1 ; VAR11 ++ ) { while ( 1 ) { if ( VAR12 == 0 ) { VAR10 = VAR18 ; break ; } VAR16 = * VAR13 ; VAR14 [ VAR11 ] += VAR16 ; VAR13 += 1 ; VAR12 -= 1 ; if ( VAR16 != 0xff ) break ; } VAR17 += VAR14 [ VAR11 ] ; } if ( VAR12 <= VAR17 ) { VAR10 = VAR19 ; break ; } VAR14 [ VAR11 ] = VAR12 - VAR17 ; break ; } case 0x2 : if ( VAR12 % ( * VAR9 ) ) { VAR10 = VAR19 ; break ; } for ( VAR11 = 0 ; VAR11 < * VAR9 ; VAR11 ++ ) VAR14 [ VAR11 ] = VAR12 / * VAR9 ; break ; case 0x3 : { uint64_t VAR20 ; uint32_t VAR17 ; VAR11 = FUN5 ( VAR2 , VAR13 , VAR12 , & VAR20 ) ; if ( VAR11 < 0 ) { FUN6 ( VAR2 -> VAR21 , VAR22 , ) ; VAR10 = VAR24 ; break ; } VAR13 += VAR24 ; VAR12 -= VAR24 ; VAR14 [ VAR11 ] = VAR14 [ VAR11 - 1 ] + VAR23 ; VAR17 += VAR14 [ VAR11 ] ; } if ( VAR12 <= VAR17 ) { VAR10 = VAR19 ; break ; } VAR14 [ * VAR9 - 1 ] = VAR12 - VAR17 ; break ; } } * VAR4 = VAR13 ; * VAR8 = VAR14 ; * VAR5 = VAR12 ; return VAR10 ; } #0
588#588#int FUN1 ( VAR1 * VAR2 , unsigned char * VAR3 , size_t VAR4 , const unsigned char * VAR5 , size_t VAR6 ) { VAR7 * VAR8 = & VAR2 -> VAR8 ; if ( VAR5 != NULL && VAR6 != 0 ) { FUN2 ( VAR2 , VAR5 , VAR6 , NULL , 0 , NULL , 0 ) ; if ( VAR2 -> VAR9 & VAR10 ) { VAR5 = NULL ; VAR6 = 1 ; } } else { VAR6 = 0 ; } for ( ; ; ) { FUN3 ( VAR8 ) ; if ( VAR4 < 16 ) { FUN4 ( VAR8 -> VAR11 , VAR8 -> VAR12 , & VAR8 -> VAR13 ) ; memcpy ( VAR3 , VAR8 -> VAR12 , VAR4 ) ; break ; } FUN4 ( VAR8 -> VAR11 , VAR3 , & VAR8 -> VAR13 ) ; VAR3 += 16 ; VAR4 -= 16 ; if ( VAR4 == 0 ) break ; } FUN2 ( VAR2 , VAR5 , VAR6 , NULL , 0 , NULL , 0 ) ; return 1 ; } #0
589#589#int FUN1 ( const VAR1 * VAR2 , int VAR3 , int64_t VAR4 , int VAR5 ) { int VAR6 , VAR7 , VAR8 ; int64_t VAR9 ; VAR6 = -1 ; VAR7 = VAR3 ; if ( VAR7 && VAR2 [ VAR7 - 1 ] . VAR9 < VAR4 ) VAR6 = VAR7 - 1 ; while ( VAR7 - VAR6 > 1 ) { VAR8 = ( VAR6 + VAR7 ) >> 1 ; while ( ( VAR2 [ VAR8 ] . VAR5 & VAR10 ) && VAR8 < VAR7 && VAR8 < VAR3 - 1 ) { VAR8 ++ ; if ( VAR8 == VAR7 && VAR2 [ VAR8 ] . VAR9 >= VAR4 ) { VAR8 = VAR7 - 1 ; break ; } } VAR9 = VAR2 [ VAR8 ] . VAR9 ; if ( VAR9 >= VAR4 ) VAR7 = VAR8 ; if ( VAR9 <= VAR4 ) VAR6 = VAR8 ; } VAR8 = ( VAR5 & VAR11 ) ? VAR6 : VAR7 ; if ( ! ( VAR5 & VAR12 ) ) while ( VAR8 >= 0 && VAR8 < VAR3 && ! ( VAR2 [ VAR8 ] . VAR5 & VAR13 ) ) VAR8 += ( VAR5 & VAR11 ) ? -1 : 1 ; if ( VAR8 == VAR3 ) return -1 ; return VAR8 ; } #0
590#590#static int FUN1 ( VAR1 * VAR2 , VAR3 * VAR4 , VAR3 * VAR5 , int VAR6 ) { unsigned char VAR7 , VAR8 ; unsigned char * VAR9 = VAR4 ; while ( 1 ) { if ( FUN2 ( & VAR2 -> VAR10 ) < 1 ) return VAR11 ; VAR7 = FUN3 ( & VAR2 -> VAR10 ) ; if ( ! ( VAR8 = ( VAR7 & 0x7f ) ) ) { return ( VAR4 - VAR9 ) / VAR6 ; } if ( VAR4 + VAR6 * VAR8 >= VAR5 ) return -1 ; if ( VAR7 & 0x80 ) { while ( VAR8 -- ) { * VAR4 = FUN4 ( & VAR2 -> VAR10 ) ; VAR4 += VAR6 ; } } else { VAR7 = FUN4 ( & VAR2 -> VAR10 ) ; while ( VAR8 -- ) { * VAR4 = VAR7 ; VAR4 += VAR6 ; } } } } #0
591#591#"static VAR1 * FUN1 ( VAR2 * VAR3 , VAR4 * VAR5 , int VAR6 ) { VAR1 * VAR7 ; const VAR8 * VAR9 ; if ( VAR6 == -1 ) { if ( ! VAR3 || ! VAR3 -> VAR10 ) return NULL ; VAR6 = VAR3 -> VAR10 -> VAR11 ; } #ifndef OPENSSL_NO_ENGINE if ( VAR3 && VAR3 -> VAR12 ) VAR5 = VAR3 -> VAR12 ; if ( VAR5 ) { if ( ! FUN2 ( VAR5 ) ) { FUN3 ( VAR13 , VAR14 ) ; return NULL ; } } else VAR5 = FUN4 ( VAR6 ) ; if ( VAR5 ) VAR9 = FUN5 ( VAR5 , VAR6 ) ; else #endif VAR9 = FUN6 ( VAR6 ) ; if ( VAR9 == NULL ) { FUN3 ( VAR13 , VAR15 ) ; return NULL ; } VAR7 = FUN7 ( sizeof ( * VAR7 ) ) ; if ( VAR7 == NULL ) { #ifndef VAR16 FUN8 ( VAR5 ) ; #endif FUN3 ( VAR13 , VAR17 ) ; return NULL ; } VAR7 -> VAR12 = VAR5 ; VAR7 -> VAR9 = VAR9 ; VAR7 -> VAR18 = VAR19 ; VAR7 -> VAR3 = VAR3 ; if ( VAR3 ) FUN9 ( & VAR3 -> VAR20 , 1 , VAR21 ) ; if ( VAR9 -> VAR22 ) { if ( VAR9 -> FUN10 ( VAR7 ) <= 0 ) { FUN11 ( VAR7 ) ; return NULL ; } } return VAR7 ; } "#0
592#592#void FUN1 ( unsigned VAR1 , unsigned * VAR2 , size_t VAR3 , VAR4 * * VAR5 , VAR6 * * * VAR7 , VAR4 * VAR8 ) { unsigned VAR9 ; VAR1 = FUN2 ( VAR1 , * VAR2 ) ; * VAR5 = FUN3 ( * VAR5 , sizeof ( VAR4 ) * ( * VAR2 + 1 ) ) ; * VAR7 = FUN3 ( * VAR7 , sizeof ( VAR6 * ) * ( * VAR2 + 1 ) ) ; memmove ( * VAR5 + VAR1 + 1 , * VAR5 + VAR1 , sizeof ( VAR4 ) * ( * VAR2 - VAR1 ) ) ; memmove ( * VAR7 + VAR1 + 1 , * VAR7 + VAR1 , sizeof ( VAR6 * ) * ( * VAR2 - VAR1 ) ) ; memcpy ( * VAR5 + VAR1 , VAR8 , sizeof ( VAR4 ) ) ; ( * VAR7 ) [ VAR1 ] = NULL ; ( * VAR2 ) ++ ; for ( VAR9 = VAR1 + 1 ; VAR9 < * VAR2 ; VAR9 ++ ) if ( * VAR7 [ VAR9 ] ) ( * ( unsigned * ) ( ( VAR10 * ) * VAR7 [ VAR9 ] + VAR3 ) ) ++ ; } #1
593#593#"int FUN1 ( VAR1 * * VAR2 , int * VAR3 , VAR4 * * VAR5 , VAR6 * * VAR7 , const char * VAR8 ) { char * VAR9 ; char * VAR10 , * VAR11 = NULL , * VAR12 = NULL , * VAR13 ; int VAR14 = -1 ; int VAR15 = 0 ; unsigned int VAR16 ; VAR4 * VAR17 = NULL ; VAR6 * VAR18 = NULL ; VAR9 = FUN2 ( VAR8 ) ; if ( ! VAR9 ) { FUN3 ( VAR19 , ) ; goto VAR20 ; } if ( ! FUN5 ( * VAR2 , VAR10 ) ) { FUN3 ( VAR19 , , VAR11 ) ; goto VAR20 ; } if ( VAR14 == 7 ) VAR14 = VAR24 ; else if ( VAR14 == 8 ) { if ( ! VAR12 ) { FUN3 ( VAR19 , , VAR12 ) ; goto VAR20 ; } if ( VAR5 ) * VAR5 = VAR17 ; else FUN8 ( VAR17 ) ; } else if ( ( VAR14 == 9 ) || ( VAR14 == 10 ) ) { if ( ! VAR12 ) { FUN3 ( VAR19 , ) ; goto VAR20 ; } if ( ! FUN10 ( VAR18 , VAR12 ) ) { FUN3 ( VAR19 , "" "" , VAR12 ) ; goto VAR20 ; } if ( VAR14 == 9 ) VAR14 = VAR26 ; else VAR14 = VAR27 ; } } if ( VAR3 ) * VAR3 = VAR14 ; if ( VAR7 ) { * VAR7 = VAR18 ; VAR18 = NULL ; } VAR15 = 1 ; VAR20 : FUN11 ( VAR9 ) ; FUN12 ( VAR18 ) ; return VAR15 ; } "#0
594#594#"static void FUN1 ( struct VAR1 * VAR2 ) { apr_status_t VAR3 ; if ( ! ( VAR4 < VAR5 ) ) return ; VAR2 -> read = 0 ; VAR2 -> VAR6 = 0 ; VAR2 -> VAR7 = 0 ; VAR2 -> VAR8 = 0 ; VAR2 -> VAR9 = 0 ; VAR2 -> VAR10 = 0 ; if ( VAR2 -> VAR11 ) FUN2 ( VAR2 -> VAR11 ) ; FUN3 ( & VAR2 -> VAR11 , VAR12 ) ; if ( ( VAR3 = FUN4 ( & VAR2 -> VAR13 , VAR14 -> VAR15 , VAR16 , 0 , VAR2 -> VAR11 ) ) != VAR17 ) { FUN5 ( , VAR3 ) ; } if ( VAR19 != 0 ) { VAR3 = FUN6 ( VAR2 -> VAR13 , VAR20 , VAR19 ) ; if ( VAR3 != VAR17 && VAR3 != VAR21 ) { FUN5 ( , VAR3 ) ; } } VAR2 -> VAR23 = VAR24 = FUN7 ( ) ; #ifdef USE_SSL if ( VAR25 ) { VAR26 * VAR27 ; apr_os_sock_t VAR28 ; if ( ( VAR2 -> VAR29 = FUN8 ( VAR30 ) ) == NULL ) { FUN9 ( VAR31 , ) ; FUN5 ( "" "" , VAR3 ) ; } VAR2 -> VAR36 = VAR50 ; FUN1 ( VAR2 ) ; return ; } } VAR2 -> VAR36 = VAR51 ; VAR4 ++ ; #ifdef USE_SSL if ( VAR2 -> VAR29 ) { FUN24 ( VAR2 ) ; } else #endif { FUN25 ( VAR2 ) ; } } "#0
595#595#"static int FUN1 ( VAR1 * VAR2 ) { VAR3 * VAR4 = VAR2 -> VAR5 ; VAR6 * VAR7 ; VAR8 * VAR9 = FUN2 ( VAR2 , NULL ) ; if ( ! VAR9 ) return FUN3 ( VAR10 ) ; VAR7 = VAR2 -> VAR11 [ 0 ] -> VAR12 ; if ( FUN4 ( VAR2 -> VAR13 ) != 0x8000 ) return VAR14 ; VAR4 -> VAR15 = FUN4 ( VAR2 -> VAR13 ) + 4 ; FUN5 ( VAR2 -> VAR13 , -4 , VAR16 ) ; if ( FUN6 ( VAR2 , VAR7 , VAR2 -> VAR13 , VAR4 -> VAR15 ) < 0 ) return FUN3 ( VAR10 ) ; if ( VAR7 -> VAR17 < 12 ) { FUN7 ( VAR2 , VAR18 , , VAR7 -> VAR19 ) ; return VAR14 ; } if ( VAR7 -> VAR21 <= 0 ) { FUN7 ( VAR2 , VAR18 , "" "" , VAR7 -> VAR21 ) ; return VAR14 ; } VAR7 -> VAR22 = VAR23 ; VAR7 -> VAR24 = VAR2 -> VAR25 -> VAR26 ; VAR7 -> VAR27 = VAR7 -> VAR21 * VAR7 -> VAR19 * VAR28 * 8LL / VAR29 ; FUN10 ( VAR9 , 64 , VAR29 , VAR7 -> VAR21 ) ; return 0 ; } "#1
